   1:				.include "extern_symbols.s" ;include monitor symbols.
**** include/extern_symbols.s ****
   1:				;This file is generated by the build script.
   2:				;Do not make any changes here!
   3:				
   4:     -	14A5          	?a0000 equ 0x14A5
   5:     -	1562          	?a0001 equ 0x1562
   6:     -	00D0          	ADDR_RTC equ 0xD0
   7:     -	01BE          	A_RTS_OFF equ 0x1BE
   8:     -	01C7          	A_RTS_ON equ 0x1C7
   9:     -	0083          	BOOT_PHASE0 equ 0x83
  10:     -	00A5          	BOOT_PHASE1 equ 0xA5
  11:     -	00AE          	BOOT_PHASE1_LOOP equ 0xAE
  12:     -	00B9          	BOOT_PHASE2 equ 0xB9
  13:     -	0050          	B_BEEP equ 0x50
  14:     -	0071          	B_DSKSEL equ 0x71
  15:     -	007A          	B_FATCD equ 0x7A
  16:     -	007D          	B_FATCREATE equ 0x7D
  17:     -	0074          	B_FATOPEN equ 0x74
  18:     -	0077          	B_FATREAD equ 0x77
  19:     -	0080          	B_FATWRITE equ 0x80
  20:     -	0056          	B_IICRECV equ 0x56
  21:     -	0053          	B_IICSEND equ 0x53
  22:     -	006B          	B_KEYREAD equ 0x6B
  23:     -	006E          	B_KEYSEND equ 0x6E
  24:     -	0062          	B_PRINTAHEX equ 0x62
  25:     -	0059          	B_PRINTCHAR equ 0x59
  26:     -	005F          	B_PRINTINLINE equ 0x5F
  27:     -	0065          	B_PRINTLN equ 0x65
  28:     -	005C          	B_PRINTSTR equ 0x5C
  29:     -	0068          	B_READCHAR equ 0x68
  30:     -	1944          	COMMAND equ 0x1944
  31:     -	1985          	COMMAND_BACKSPACE equ 0x1985
  32:     -	18B2          	COMMAND_LUT equ 0x18B2
  33:     -	19AB          	COMMAND_PROCESS equ 0x19AB
  34:     -	19E6          	COMMAND_PROCESS_FOUND equ 0x19E6
  35:     -	19AE          	COMMAND_PROCESS_LOOP equ 0x19AE
  36:     -	19B7          	COMMAND_PROCESS_LOOP_STR1 equ 0x19B7
  37:     -	19CD          	COMMAND_PROCESS_LOOP_STR2 equ 0x19CD
  38:     -	19D2          	COMMAND_PROCESS_NEXT_ENTRY equ 0x19D2
  39:     -	19D1          	COMMAND_PROCESS_NEXT_ENTRYI equ 0x19D1
  40:     -	19DD          	COMMAND_PROCESS_NOT_FOUND equ 0x19DD
  41:     -	1956          	COMMAND_READ equ 0x1956
  42:     -	00DC          	CONSOLE_INIT equ 0xDC
  43:     -	00DC          	CONSOLE_INIT_CTC equ 0xDC
  44:     -	00E4          	CONSOLE_INIT_SIO equ 0xE4
  45:     -	00F9          	CS_APU_CTRL equ 0xF9
  46:     -	00F8          	CS_APU_DATA equ 0xF8
  47:     -	0000          	CS_BANK equ 0x00
  48:     -	0004          	CS_CTC_0 equ 0x04
  49:     -	0005          	CS_CTC_1 equ 0x05
  50:     -	0006          	CS_CTC_2 equ 0x06
  51:     -	0007          	CS_CTC_3 equ 0x07
  52:     -	0001          	CS_DIP equ 0x01
  53:     -	0033          	CS_PIA_CR equ 0x33
  54:     -	0030          	CS_PIA_PA equ 0x30
  55:     -	0031          	CS_PIA_PB equ 0x31
  56:     -	0032          	CS_PIA_PC equ 0x32
  57:     -	00F6          	CS_PIO_AC equ 0xF6
  58:     -	00F4          	CS_PIO_AD equ 0xF4
  59:     -	00F7          	CS_PIO_BC equ 0xF7
  60:     -	00F5          	CS_PIO_BD equ 0xF5
  61:     -	0009          	CS_SIO_A_C equ 0x09
  62:     -	0008          	CS_SIO_A_D equ 0x08
  63:     -	000B          	CS_SIO_B_C equ 0x0B
  64:     -	000A          	CS_SIO_B_D equ 0x0A
  65:     -	0235          	DHEX_TO_BYTE equ 0x235
  66:     -	0251          	DHEX_TO_BYTE_FAILED equ 0x251
  67:     -	19FC          	ERR_SYNTAX equ 0x19FC
  68:     -	0DD5          	EXEC_RST_08 equ 0xDD5
  69:     -	0DD9          	EXEC_RST_10 equ 0xDD9
  70:     -	0DE5          	EXEC_RST_18 equ 0xDE5
  71:     -	0255          	HEX_TO_BIN equ 0x255
  72:     -	0263          	HEX_TO_BIN_2 equ 0x263
  73:     -	026A          	HEX_TO_INVALID_2 equ 0x26A
  74:     -	00EC          	IDE_CMD_IDENT equ 0xEC
  75:     -	0020          	IDE_CMD_READSEC equ 0x20
  76:     -	1307          	IDE_DEV_TABLE equ 0x1307
  77:     -	0040          	IDE_RD equ 0x40
  78:     -	0016          	IDE_REG_ALTSTS equ 0x16
  79:     -	000F          	IDE_REG_CMDSTS equ 0x0F
  80:     -	0008          	IDE_REG_DATA equ 0x08
  81:     -	0017          	IDE_REG_DRVADDR equ 0x17
  82:     -	0009          	IDE_REG_ERROR equ 0x09
  83:     -	000D          	IDE_REG_HCYL equ 0x0D
  84:     -	000E          	IDE_REG_HEAD equ 0x0E
  85:     -	000B          	IDE_REG_LBA0 equ 0x0B
  86:     -	000C          	IDE_REG_LBA1 equ 0x0C
  87:     -	000D          	IDE_REG_LBA2 equ 0x0D
  88:     -	000E          	IDE_REG_LBA3 equ 0x0E
  89:     -	000C          	IDE_REG_LCYL equ 0x0C
  90:     -	000A          	IDE_REG_SECTOR equ 0x0A
  91:     -	000B          	IDE_REG_SSECTOR equ 0x0B
  92:     -	0080          	IDE_RST equ 0x80
  93:     -	0020          	IDE_WR equ 0x20
  94:     -	0001          	IIC_CLK equ 0x01
  95:     -	0002          	IIC_DATA equ 0x02
  96:     -	001B          	INT_VEC equ 0x1B
  97:     -	0040          	IO_AY0_ADDR equ 0x40
  98:     -	0041          	IO_AY0_DATA equ 0x41
  99:     -	0042          	IO_AY1_ADDR equ 0x42
 100:     -	0043          	IO_AY1_DATA equ 0x43
 101:     -	0020          	IO_REG0 equ 0x20
 102:     -	0025          	IO_RTC_AMPM equ 0x25
 103:     -	002D          	IO_RTC_CTR_D equ 0x2D
 104:     -	002E          	IO_RTC_CTR_E equ 0x2E
 105:     -	002F          	IO_RTC_CTR_F equ 0x2F
 106:     -	0026          	IO_RTC_DAY0 equ 0x26
 107:     -	0027          	IO_RTC_DAY1 equ 0x27
 108:     -	0024          	IO_RTC_HOUR equ 0x24
 109:     -	0022          	IO_RTC_MIN0 equ 0x22
 110:     -	0023          	IO_RTC_MIN1 equ 0x23
 111:     -	0028          	IO_RTC_MON0 equ 0x28
 112:     -	0029          	IO_RTC_MON1 equ 0x29
 113:     -	0020          	IO_RTC_SEC0 equ 0x20
 114:     -	0021          	IO_RTC_SEC1 equ 0x21
 115:     -	002C          	IO_RTC_WEEK equ 0x2C
 116:     -	002B          	IO_RTC_YEAR1 equ 0x2B
 117:     -	002A          	IO_RTC_YERR0 equ 0x2A
 118:     -	44B8          	MEM_FAT_AMOUNT equ 0x44B8
 119:     -	44BB          	MEM_FAT_CLUSTERLEN equ 0x44BB
 120:     -	44BC          	MEM_FAT_COUNT1 equ 0x44BC
 121:     -	44DF          	MEM_FAT_CURDIR equ 0x44DF
 122:     -	453F          	MEM_FAT_CURRDIR equ 0x453F
 123:     -	44C1          	MEM_FAT_DATASTART equ 0x44C1
 124:     -	44CD          	MEM_FAT_DIRSEC equ 0x44CD
 125:     -	4545          	MEM_FAT_EXEC_COUNT equ 0x4545
 126:     -	4543          	MEM_FAT_EXEC_CURR equ 0x4543
 127:     -	4547          	MEM_FAT_EXEC_START equ 0x4547
 128:     -	44C9          	MEM_FAT_FILEREMAIN equ 0x44C9
 129:     -	452F          	MEM_FAT_OF0_ATTRIBUTE equ 0x452F
 130:     -	4531          	MEM_FAT_OF0_CCLUST equ 0x4531
 131:     -	453B          	MEM_FAT_OF0_DATREM equ 0x453B
 132:     -	4537          	MEM_FAT_OF0_DATSEC equ 0x4537
 133:     -	4533          	MEM_FAT_OF0_FATSEC equ 0x4533
 134:     -	44B6          	MEM_FAT_RESERVED equ 0x44B6
 135:     -	44C5          	MEM_FAT_ROOTSTART equ 0x44C5
 136:     -	44B9          	MEM_FAT_SECTORS equ 0x44B9
 137:     -	44CF          	MEM_FAT_TMPFNAME equ 0x44CF
 138:     -	44BD          	MEM_FAT_TMPPOINTER equ 0x44BD
 139:     -	42B6          	MEM_IDE_BUFFER equ 0x42B6
 140:     -	41CB          	MEM_IDE_DEVICE equ 0x41CB
 141:     -	41D5          	MEM_IDE_DEV_TABLE equ 0x41D5
 142:     -	44B6          	MEM_IDE_FSBUFFER equ 0x44B6
 143:     -	41CD          	MEM_IDE_PARTITION equ 0x41CD
 144:     -	41D1          	MEM_IDE_POINTER equ 0x41D1
 145:     -	4215          	MEM_IDE_SELECTED equ 0x4215
 146:     -	41CC          	MEM_IDE_STATUS equ 0x41CC
 147:     -	4216          	MEM_IDE_STRING_0 equ 0x4216
 148:     -	423E          	MEM_IDE_STRING_1 equ 0x423E
 149:     -	4266          	MEM_IDE_STRING_2 equ 0x4266
 150:     -	428E          	MEM_IDE_STRING_3 equ 0x428E
 151:     -	01B6          	MSG_CLEAR equ 0x1B6
 152:     -	19F5          	NOT_IMPLEMENTED equ 0x19F5
 153:     -	1A57          	OP_CALL equ 0x1A57
 154:     -	1E27          	OP_CD equ 0x1E27
 155:     -	1BEB          	OP_CLR equ 0x1BEB
 156:     -	1AD8          	OP_DASM equ 0x1AD8
 157:     -	1E23          	OP_DIR equ 0x1E23
 158:     -	1A77          	OP_DUMP equ 0x1A77
 159:     -	1A3E          	OP_EXEC equ 0x1A3E
 160:     -	1E44          	OP_FSEXEC equ 0x1E44
 161:     -	1B9F          	OP_IIC_IN equ 0x1B9F
 162:     -	1B3F          	OP_IIC_OUT equ 0x1B3F
 163:     -	1B08          	OP_IO_IN equ 0x1B08
 164:     -	1B1E          	OP_IO_OUT equ 0x1B1E
 165:     -	1E00          	OP_LSDSK equ 0x1E00
 166:     -	1BEF          	OP_RTIME equ 0x1BEF
 167:     -	1E04          	OP_SELDSK equ 0x1E04
 168:     -	1AA7          	OP_SET equ 0x1AA7
 169:     -	1D87          	OP_STIME equ 0x1D87
 170:     -	1E7D          	POST_CHECK_APU equ 0x1E7D
 171:     -	1EA8          	POST_CHECK_IDE_30 equ 0x1EA8
 172:     -	1EBB          	POST_CHECK_IDE_40 equ 0x1EBB
 173:     -	1E58          	POST_CHECK_PIO equ 0x1E58
 174:     -	1E48          	POST_START equ 0x1E48
 175:     -	1ED5          	POST_TEST_RTC equ 0x1ED5
 176:     -	4110          	PRG_RAM_START equ 0x4110
 177:     -	FF00          	PRG_RAM_TOP equ 0xFF00
 178:     -	01D0          	PRINTINLINE equ 0x1D0
 179:     -	4000          	PROG_MEM_START equ 0x4000
 180:     -	0100          	PROG_ROM_START equ 0x100
 181:     -	0000          	RST_00 equ 0x00
 182:     -	0008          	RST_08 equ 0x08
 183:     -	0010          	RST_10 equ 0x10
 184:     -	0018          	RST_18 equ 0x18
 185:     -	FFFF          	STACK_RAM_TOP equ 0xFFFF
 186:     -	0000          	START_ROM equ 0x00
 187:     -	026C          	STRCONV_BYTES_TO_HEX equ 0x26C
 188:     -	027B          	STRCONV_BYTES_TO_HEX_1 equ 0x27B
 189:     -	0285          	STRCONV_BYTES_TO_HEX_2 equ 0x285
 190:     -	2689          	STR_Banner_Start equ 0x2689
 191:     -	186B          	STR_PD_HEADER equ 0x186B
 192:     -	4010          	SYS_BUF_START equ 0x4010
 193:     -	4000          	SYS_RAM_START equ 0x4000
 194:     -	0018          	VAR_CONSOLE_BAUD equ 0x18
 195:     -	000F          	VAR_CONSOLE_CONF equ 0x0F
 196:     -	0080          	VDP_MEM equ 0x80
 197:     -	0081          	VDP_REG equ 0x81
 198:     -	19F4          	_COMMAND_PROCESS_FOUND equ 0x19F4
 199:     -	1A76          	_OP_CALL equ 0x1A76
 200:     -	1B84          	_OP_IIC_ACK_ERR equ 0x1B84
 201:     -	1B8B          	_OP_IIC_ACK_ERR_str equ 0x1B8B
 202:     -	1BD1          	_OP_IIC_IN_LOOP equ 0x1BD1
 203:     -	1BDE          	_OP_IIC_IN_LOOP_TEXT equ 0x1BDE
 204:     -	1B55          	_OP_IIC_OUT_LOOP equ 0x1B55
 205:     -	1B71          	_OP_IIC_OUT_SEND equ 0x1B71
 206:     -	1BF2          	_OP_RTIME_NN equ 0x1BF2
 207:     -	1CAA          	_OP_RTIME_RD_CMD equ 0x1CAA
 208:     -	1E13          	_OP_SELDSK_INVALID equ 0x1E13
 209:     -	1E2B          	_OP_SELDSK_INVALID_STR equ 0x1E2B
 210:     -	1ABF          	_OP_SET_LOOP equ 0x1ABF
 211:     -	1D4D          	_OP_STIME_INVALID equ 0x1D4D
 212:     -	1D64          	_OP_STIME_PROMPT equ 0x1D64
 213:     -	1D7C          	_OP_STIME_PROMPT_ERR equ 0x1D7C
 214:     -	1CAB          	_OP_STIME_STR_DAY equ 0x1CAB
 215:     -	1CFC          	_OP_STIME_STR_HOUR equ 0x1CFC
 216:     -	1D17          	_OP_STIME_STR_MIN equ 0x1D17
 217:     -	1CC6          	_OP_STIME_STR_MON equ 0x1CC6
 218:     -	1D32          	_OP_STIME_STR_SEC equ 0x1D32
 219:     -	1CE1          	_OP_STIME_STR_YEAR equ 0x1CE1
 220:     -	1E9C          	_POST_CHECK_APU_FAILED equ 0x1E9C
 221:     -	1ECE          	_POST_CHECK_IDE_FAILED equ 0x1ECE
 222:     -	1E71          	_POST_CHECK_PIO_FAILED equ 0x1E71
 223:     -	1F0F          	_POST_TEST_RTC_INVALID equ 0x1F0F
 224:     -	1F08          	_POST_TEST_RTC_NOTFOUND equ 0x1F08
 225:     -	1A17          	_STR_NOT_FOUND equ 0x1A17
 226:     -	1A03          	_STR_NOT_IMPLEMENTED equ 0x1A03
 227:     -	1A2B          	_STR_SYNTAX equ 0x1A2B
 228:     -	0E01          	_beep_pause_l1 equ 0xE01
 229:     -	234A          	_compare_filename_loop equ 0x234A
 230:     -	2358          	_compare_filename_nomatch equ 0x2358
 231:     -	24FF          	_fat_cd_navigate equ 0x24FF
 232:     -	2545          	_fat_cd_navigate_end equ 0x2545
 233:     -	256D          	_fat_cd_navigate_errfile equ 0x256D
 234:     -	259F          	_fat_cd_navigate_errfile_str equ 0x259F
 235:     -	2557          	_fat_cd_navigate_error equ 0x2557
 236:     -	2575          	_fat_cd_navigate_error_str equ 0x2575
 237:     -	2504          	_fat_cd_navigate_findsec equ 0x2504
 238:     -	2530          	_fat_cd_navigate_findsec_skipslash equ 0x2530
 239:     -	24BB          	_fat_cd_navigate_goback_fl equ 0x24BB
 240:     -	2565          	_fat_cd_navigate_inerror equ 0x2565
 241:     -	255F          	_fat_cd_navigate_inerrorS equ 0x255F
 242:     -	2566          	_fat_cd_navigate_inerrore equ 0x2566
 243:     -	258C          	_fat_cd_navigate_inputerr_str equ 0x258C
 244:     -	2536          	_fat_cd_navigate_l2 equ 0x2536
 245:     -	2665          	_fat_exec_notexec equ 0x2665
 246:     -	264C          	_fat_exec_notfound equ 0x264C
 247:     -	2634          	_fat_exec_read_done equ 0x2634
 248:     -	2616          	_fat_exec_readloop1 equ 0x2616
 249:     -	213A          	_fat_get_root_table_invalid equ 0x213A
 250:     -	2179          	_fat_getfatsec_notroot equ 0x2179
 251:     -	22D0          	_fat_increment_32 equ 0x22D0
 252:     -	2246          	_fat_lfs_loop equ 0x2246
 253:     -	2282          	_fat_lfs_loop_compare_end equ 0x2282
 254:     -	2286          	_fat_lfs_loop_compare_match equ 0x2286
 255:     -	2258          	_fat_lfs_loop_compare_next_sector equ 0x2258
 256:     -	22E4          	_fat_math_add32 equ 0x22E4
 257:     -	2315          	_fat_math_mul32 equ 0x2315
 258:     -	231C          	_fat_math_mul32_l equ 0x231C
 259:     -	2329          	_fat_math_mul32_noadd equ 0x2329
 260:     -	22BC          	_fat_math_sector_add_16 equ 0x22BC
 261:     -	243A          	_fat_print_directory_dir equ 0x243A
 262:     -	23CD          	_fat_print_directory_loop equ 0x23CD
 263:     -	2499          	_fat_print_directory_loop_break equ 0x2499
 264:     -	23E9          	_fat_print_directory_loop_file equ 0x23E9
 265:     -	2465          	_fat_print_directory_loop_next equ 0x2465
 266:     -	2470          	_fat_print_directory_loop_next_sector equ 0x2470
 267:     -	2361          	_format_filename_fat16_clean equ 0x2361
 268:     -	2368          	_format_filename_fat16_loop equ 0x2368
 269:     -	237B          	_format_filename_fat16_loop_copy equ 0x237B
 270:     -	2372          	_format_filename_fat16_loop_skip_8 equ 0x2372
 271:     -	0E5D          	_ide_readsector_512_floop equ 0xE5D
 272:     -	15D2          	_ideif_drv_sel_fail equ 0x15D2
 273:     -	168F          	_ideif_drv_sel_fstr0 equ 0x168F
 274:     -	1686          	_ideif_drv_sel_pstr equ 0x1686
 275:     -	169D          	_ideif_drv_sel_sstr0 equ 0x169D
 276:     -	16AA          	_ideif_drv_sel_syn equ 0x16AA
 277:     -	1499          	_ideif_init_drive_charloop equ 0x1499
 278:     -	147B          	_ideif_init_drive_found equ 0x147B
 279:     -	1463          	_ideif_init_drive_loop equ 0x1463
 280:     -	1476          	_ideif_init_drive_nodrv equ 0x1476
 281:     -	14F7          	_ideif_init_drive_prt_fnd equ 0x14F7
 282:     -	14E5          	_ideif_init_drive_prt_l1 equ 0x14E5
 283:     -	14EF          	_ideif_init_drive_prt_ln equ 0x14EF
 284:     -	1612          	_ideif_prnt_devtable_hdr equ 0x1612
 285:     -	1373          	_ideif_prnt_devtable_l1 equ 0x1373
 286:     -	1439          	_ideif_prnt_devtable_l1_e2 equ 0x1439
 287:     -	13B8          	_ideif_prnt_devtable_l1_es equ 0x13B8
 288:     -	1436          	_ideif_prnt_devtable_l1_ms equ 0x1436
 289:     -	1380          	_ideif_prnt_devtable_l1_nxt equ 0x1380
 290:     -	13A6          	_ideif_prnt_devtable_l1_s00 equ 0x13A6
 291:     -	13AB          	_ideif_prnt_devtable_l1_s01 equ 0x13AB
 292:     -	13B0          	_ideif_prnt_devtable_l1_s02 equ 0x13B0
 293:     -	13B5          	_ideif_prnt_devtable_l1_sFF equ 0x13B5
 294:     -	137E          	_ideif_prnt_devtable_l1_sel equ 0x137E
 295:     -	1676          	_ideif_prnt_devtable_master equ 0x1676
 296:     -	164A          	_ideif_prnt_devtable_s00 equ 0x164A
 297:     -	1655          	_ideif_prnt_devtable_s01 equ 0x1655
 298:     -	1660          	_ideif_prnt_devtable_s02 equ 0x1660
 299:     -	166B          	_ideif_prnt_devtable_sFF equ 0x166B
 300:     -	167E          	_ideif_prnt_devtable_slave equ 0x167E
 301:     -	018D          	_read_bcd_invalid equ 0x18D
 302:     -	1DFB          	_shift4 equ 0x1DFB
 303:     -	0DE8          	beep equ 0xDE8
 304:     -	0DEA          	beep_loop equ 0xDEA
 305:     -	0E00          	beep_pause equ 0xE00
 306:     -	2346          	compare_filename equ 0x2346
 307:     -	09ED          	dasm_00 equ 0x9ED
 308:     -	0CD9          	dasm_01 equ 0xCD9
 309:     -	0A73          	dasm_02 equ 0xA73
 310:     -	0CAB          	dasm_03 equ 0xCAB
 311:     -	0AF0          	dasm_08 equ 0xAF0
 312:     -	0C7E          	dasm_09 equ 0xC7E
 313:     -	0A55          	dasm_0A equ 0xA55
 314:     -	0CC2          	dasm_0B equ 0xCC2
 315:     -	0A35          	dasm_10 equ 0xA35
 316:     -	0A7E          	dasm_12 equ 0xA7E
 317:     -	09F8          	dasm_18 equ 0x9F8
 318:     -	0A5F          	dasm_1A equ 0xA5F
 319:     -	0A12          	dasm_20 equ 0xA12
 320:     -	0D1F          	dasm_22 equ 0xD1F
 321:     -	0AB8          	dasm_27 equ 0xAB8
 322:     -	0A0B          	dasm_28 equ 0xA0B
 323:     -	0CF0          	dasm_2A equ 0xCF0
 324:     -	0ABC          	dasm_2F equ 0xABC
 325:     -	0A03          	dasm_30 equ 0xA03
 326:     -	0A89          	dasm_32 equ 0xA89
 327:     -	0AC8          	dasm_37 equ 0xAC8
 328:     -	09FC          	dasm_38 equ 0x9FC
 329:     -	0A69          	dasm_3A equ 0xA69
 330:     -	0AC4          	dasm_3F equ 0xAC4
 331:     -	0ACC          	dasm_76 equ 0xACC
 332:     -	0B49          	dasm_80C6 equ 0xB49
 333:     -	0AE6          	dasm_BE equ 0xAE6
 334:     -	09F1          	dasm_C3 equ 0x9F1
 335:     -	0B6F          	dasm_C88E equ 0xB6F
 336:     -	0A41          	dasm_C9 equ 0xA41
 337:     -	0A3B          	dasm_CD equ 0xA3B
 338:     -	0AFD          	dasm_D9 equ 0xAFD
 339:     -	0A23          	dasm_DD equ 0xA23
 340:     -	0CE0          	dasm_DD_01 equ 0xCE0
 341:     -	0C99          	dasm_DD_09 equ 0xC99
 342:     -	0D35          	dasm_DD_22 equ 0xD35
 343:     -	0CB0          	dasm_DD_23 equ 0xCB0
 344:     -	0D07          	dasm_DD_2A equ 0xD07
 345:     -	0CC7          	dasm_DD_2B equ 0xCC7
 346:     -	0C49          	dasm_DD_34 equ 0xC49
 347:     -	0C66          	dasm_DD_35 equ 0xC66
 348:     -	0B51          	dasm_DD_86 equ 0xB51
 349:     -	0B77          	dasm_DD_8E equ 0xB77
 350:     -	0B9A          	dasm_DD_96 equ 0xB9A
 351:     -	0BBA          	dasm_DD_9E equ 0xBBA
 352:     -	0BDB          	dasm_DD_A6 equ 0xBDB
 353:     -	0C12          	dasm_DD_AE equ 0xC12
 354:     -	0BF7          	dasm_DD_B6 equ 0xBF7
 355:     -	0C2E          	dasm_DD_BE equ 0xC2E
 356:     -	0D87          	dasm_DD_E1 equ 0xD87
 357:     -	0B0D          	dasm_DD_E3 equ 0xB0D
 358:     -	0D71          	dasm_DD_E5 equ 0xD71
 359:     -	0D57          	dasm_DD_F9 equ 0xD57
 360:     -	0D81          	dasm_E1 equ 0xD81
 361:     -	0B01          	dasm_E3 equ 0xB01
 362:     -	0D6B          	dasm_E5 equ 0xD6B
 363:     -	0A1A          	dasm_E9 equ 0xA1A
 364:     -	0C90          	dasm_ED_42 equ 0xC90
 365:     -	0D2B          	dasm_ED_43 equ 0xD2B
 366:     -	0AC0          	dasm_ED_44 equ 0xAC0
 367:     -	0A4B          	dasm_ED_45 equ 0xA4B
 368:     -	0AD7          	dasm_ED_46 equ 0xAD7
 369:     -	0C87          	dasm_ED_4A equ 0xC87
 370:     -	0CFC          	dasm_ED_4B equ 0xCFC
 371:     -	0A46          	dasm_ED_4D equ 0xA46
 372:     -	0ADC          	dasm_ED_56 equ 0xADC
 373:     -	0AE1          	dasm_ED_5E equ 0xAE1
 374:     -	0B25          	dasm_ED_A0 equ 0xB25
 375:     -	0B37          	dasm_ED_A1 equ 0xB37
 376:     -	0B2E          	dasm_ED_A8 equ 0xB2E
 377:     -	0B40          	dasm_ED_A9 equ 0xB40
 378:     -	0B29          	dasm_ED_B0 equ 0xB29
 379:     -	0B3B          	dasm_ED_B1 equ 0xB3B
 380:     -	0B32          	dasm_ED_B8 equ 0xB32
 381:     -	0B44          	dasm_ED_B9 equ 0xB44
 382:     -	0AD1          	dasm_F3 equ 0xAD1
 383:     -	0D4D          	dasm_F9 equ 0xD4D
 384:     -	0AD4          	dasm_FB equ 0xAD4
 385:     -	0A2C          	dasm_FD equ 0xA2C
 386:     -	0CE8          	dasm_FD_01 equ 0xCE8
 387:     -	0CA2          	dasm_FD_09 equ 0xCA2
 388:     -	0D41          	dasm_FD_22 equ 0xD41
 389:     -	0CB9          	dasm_FD_23 equ 0xCB9
 390:     -	0D13          	dasm_FD_2A equ 0xD13
 391:     -	0CD0          	dasm_FD_2B equ 0xCD0
 392:     -	0C55          	dasm_FD_34 equ 0xC55
 393:     -	0C72          	dasm_FD_35 equ 0xC72
 394:     -	0B60          	dasm_FD_86 equ 0xB60
 395:     -	0B86          	dasm_FD_8E equ 0xB86
 396:     -	0BA6          	dasm_FD_96 equ 0xBA6
 397:     -	0BC8          	dasm_FD_9E equ 0xBC8
 398:     -	0BE7          	dasm_FD_A6 equ 0xBE7
 399:     -	0C1E          	dasm_FD_AE equ 0xC1E
 400:     -	0C02          	dasm_FD_B6 equ 0xC02
 401:     -	0C39          	dasm_FD_BE equ 0xC39
 402:     -	0D8F          	dasm_FD_E1 equ 0xD8F
 403:     -	0B19          	dasm_FD_E3 equ 0xB19
 404:     -	0D79          	dasm_FD_E5 equ 0xD79
 405:     -	0D61          	dasm_FD_F9 equ 0xD61
 406:     -	0A50          	dasm_FF equ 0xA50
 407:     -	0D97          	dasm_UU equ 0xD97
 408:     -	0D9B          	dasm_UW equ 0xD9B
 409:     -	0BD6          	dasm__AND equ 0xBD6
 410:     -	0C2A          	dasm__CP equ 0xC2A
 411:     -	0C61          	dasm__DEC equ 0xC61
 412:     -	0AA8          	dasm__ED_47 equ 0xAA8
 413:     -	0AB0          	dasm__ED_4F equ 0xAB0
 414:     -	0A98          	dasm__ED_57 equ 0xA98
 415:     -	0AA0          	dasm__ED_5F equ 0xAA0
 416:     -	0C44          	dasm__INC equ 0xC44
 417:     -	0A94          	dasm__LD equ 0xA94
 418:     -	0BF3          	dasm__OR equ 0xBF3
 419:     -	0BB2          	dasm__SBC equ 0xBB2
 420:     -	0B95          	dasm__SUB equ 0xB95
 421:     -	0C0D          	dasm__XOR equ 0xC0D
 422:     -	0595          	dasm_opcode_table equ 0x595
 423:     -	03C2          	dasm_print16hex_addr equ 0x3C2
 424:     -	03DA          	dasm_print8hex equ 0x3DA
 425:     -	0DA0          	dasm_printFlags_table equ 0xDA0
 426:     -	0DB0          	dasm_printRegister8_table equ 0xDB0
 427:     -	0DD0          	dasm_printRegister8_table_HL equ 0xDD0
 428:     -	0DB8          	dasm_printRegisterIX_table equ 0xDB8
 429:     -	0DC0          	dasm_printRegisterIY_table equ 0xDC0
 430:     -	0DC8          	dasm_printRegisterSP_table equ 0xDC8
 431:     -	0286          	disassemble equ 0x286
 432:     -	036C          	disassemble_continue equ 0x36C
 433:     -	035C          	disassemble_err equ 0x35C
 434:     -	028A          	disassemble_next equ 0x28A
 435:     -	0359          	disassemble_print_opcode_params_end equ 0x359
 436:     -	0305          	disassemble_print_opcode_params_loop equ 0x305
 437:     -	02C7          	disassemble_print_opcode_raw equ 0x2C7
 438:     -	02DB          	disassemble_print_opcode_raw_fill equ 0x2DB
 439:     -	039E          	disassemble_table_first_match equ 0x39E
 440:     -	03B8          	disassemble_table_found equ 0x3B8
 441:     -	03BC          	disassemble_table_notfound equ 0x3BC
 442:     -	037A          	disassemble_table_seek equ 0x37A
 443:     -	037E          	disassemble_table_seek_loop equ 0x37E
 444:     -	1810          	dump_pretty equ 0x1810
 445:     -	183A          	dump_pretty_ascii equ 0x183A
 446:     -	1858          	dump_pretty_ascii_cont equ 0x1858
 447:     -	1842          	dump_pretty_ascii_loop equ 0x1842
 448:     -	1853          	dump_pretty_ascii_none equ 0x1853
 449:     -	182D          	dump_pretty_col equ 0x182D
 450:     -	186A          	dump_pretty_end equ 0x186A
 451:     -	185E          	dump_pretty_nextrow equ 0x185E
 452:     -	1818          	dump_pretty_row equ 0x1818
 453:     -	01DE          	endPrint equ 0x1DE
 454:     -	249B          	fat_cd_single equ 0x249B
 455:     -	233D          	fat_copy_lba_pointer equ 0x233D
 456:     -	25B6          	fat_exec equ 0x25B6
 457:     -	206D          	fat_get_root_table equ 0x206D
 458:     -	2162          	fat_getfatsec equ 0x2162
 459:     -	2217          	fat_openfile equ 0x2217
 460:     -	221F          	fat_openfile_noprepare equ 0x221F
 461:     -	2382          	fat_print_directory equ 0x2382
 462:     -	21EA          	fat_readfilesec equ 0x21EA
 463:     -	232E          	fat_reset_pointer equ 0x232E
 464:     -	235C          	format_filename_fat16 equ 0x235C
 465:     -	0E94          	ide_printerror equ 0xE94
 466:     -	0E49          	ide_readsector_512_fast equ 0xE49
 467:     -	0E7E          	ide_readsector_timeout equ 0xE7E
 468:     -	0E33          	ide_regread_8 equ 0xE33
 469:     -	0E19          	ide_regwrite_8 equ 0xE19
 470:     -	0E0D          	ide_reset equ 0xE0D
 471:     -	0E93          	ide_writesector_256 equ 0xE93
 472:     -	159A          	ideif_drv_sel equ 0x159A
 473:     -	153A          	ideif_get_drv_pointer equ 0x153A
 474:     -	154E          	ideif_init_all equ 0x154E
 475:     -	1347          	ideif_init_devtable equ 0x1347
 476:     -	145A          	ideif_init_drive equ 0x145A
 477:     -	1365          	ideif_prnt_devtable equ 0x1365
 478:     -	171C          	iic_init equ 0x171C
 479:     -	1763          	iic_read_ack equ 0x1763
 480:     -	16ED          	iic_receive_buffer equ 0x16ED
 481:     -	1710          	iic_receive_buffer_done equ 0x1710
 482:     -	1716          	iic_receive_buffer_err equ 0x1716
 483:     -	16FE          	iic_receive_buffer_loop equ 0x16FE
 484:     -	17E9          	iic_receive_byte equ 0x17E9
 485:     -	17F6          	iic_receive_byte_loop equ 0x17F6
 486:     -	1789          	iic_send_ack equ 0x1789
 487:     -	16C3          	iic_send_buffer equ 0x16C3
 488:     -	16E1          	iic_send_buffer_done equ 0x16E1
 489:     -	16E7          	iic_send_buffer_err equ 0x16E7
 490:     -	16D3          	iic_send_buffer_loop equ 0x16D3
 491:     -	17C3          	iic_send_byte equ 0x17C3
 492:     -	17CF          	iic_send_byte_loop equ 0x17CF
 493:     -	1742          	iic_send_ebit equ 0x1742
 494:     -	17A6          	iic_send_nack equ 0x17A6
 495:     -	1729          	iic_send_sbit equ 0x1729
 496:     -	4000          	interrupt_vectors equ 0x4000
 497:     -	0044          	mon_var_template equ 0x44
 498:     -	050F          	mon_var_template_end equ 0x50F
 499:     -	01D3          	nxtILC equ 0x1D3
 500:     -	03E8          	param_01 equ 0x3E8
 501:     -	040F          	param_02 equ 0x40F
 502:     -	042C          	param_03 equ 0x42C
 503:     -	0464          	param_03_done equ 0x464
 504:     -	044D          	param_03_neg equ 0x44D
 505:     -	0468          	param_04 equ 0x468
 506:     -	0478          	param_04_i equ 0x478
 507:     -	047E          	param_05 equ 0x47E
 508:     -	048B          	param_06 equ 0x48B
 509:     -	04A5          	param_07 equ 0x4A5
 510:     -	04B2          	param_08 equ 0x4B2
 511:     -	04C7          	param_09 equ 0x4C7
 512:     -	04CD          	param_09_0A equ 0x4CD
 513:     -	04BE          	param_0A equ 0x4BE
 514:     -	04DC          	param_10 equ 0x4DC
 515:     -	04EC          	param_11 equ 0x4EC
 516:     -	04FB          	param_11_12 equ 0x4FB
 517:     -	051B          	param_11_12_all equ 0x51B
 518:     -	050E          	param_11_12_def equ 0x50E
 519:     -	0513          	param_11_12_ix equ 0x513
 520:     -	0518          	param_11_12_iy equ 0x518
 521:     -	04F4          	param_12 equ 0x4F4
 522:     -	052C          	param_13 equ 0x52C
 523:     -	054B          	param_80 equ 0x54B
 524:     -	0552          	param_80_seek equ 0x552
 525:     -	0542          	param_81 equ 0x542
 526:     -	0586          	param_comma equ 0x586
 527:     -	0561          	param_printRegister equ 0x561
 528:     -	057F          	param_printRegisterA equ 0x57F
 529:     -	0577          	param_printRegisterHL equ 0x577
 530:     -	01A9          	print_16_hex equ 0x1A9
 531:     -	0190          	print_32_hex equ 0x190
 532:     -	0143          	print_a_hex equ 0x143
 533:     -	0155          	print_bcd equ 0x155
 534:     -	0115          	print_char equ 0x115
 535:     -	0126          	print_clear equ 0x126
 536:     -	012D          	print_newLine equ 0x12D
 537:     -	01E3          	print_reg equ 0x1E3
 538:     -	011D          	print_str equ 0x11D
 539:     -	18AA          	print_str_fixed equ 0x18AA
 540:     -	0138          	print_wait_out equ 0x138
 541:     -	0177          	read_bcd equ 0x177
 542:     -	015B          	read_char equ 0x15B
 543:     -	016D          	read_in_sts equ 0x16D
 544:     -	1561          	read_lba_sector equ 0x1561
 545:     -	160A          	str_dev_done equ 0x160A
 546:     -	15F2          	str_dev_waitready equ 0x15F2
 547:     -	0EC9          	str_error_start equ 0xEC9
 548:     -	0EE6          	str_error_start1 equ 0xEE6
 549:     -	0EEF          	str_error_start2 equ 0xEEF
 550:     -	0EF8          	str_error_time equ 0xEF8
 551:     -	1F67          	str_post_apu equ 0x1F67
 552:     -	1F16          	str_post_ide_30 equ 0x1F16
 553:     -	1F31          	str_post_ide_40 equ 0x1F31
 554:     -	1F9D          	str_post_nd equ 0x1F9D
 555:     -	1FD5          	str_post_ok equ 0x1FD5
 556:     -	1F4C          	str_post_pio equ 0x1F4C
 557:     -	1F82          	str_post_rtc equ 0x1F82
 558:     -	1FAB          	str_post_rtc_iv equ 0x1FAB
 559:     -	410A          	var_apu_present equ 0x410A
 560:     -	4100          	var_buffer_len equ 0x4100
 561:     -	411A          	var_bytes_count equ 0x411A
 562:     -	4106          	var_curserchar equ 0x4106
 563:     -	4107          	var_curserlastaddr equ 0x4107
 564:     -	4105          	var_curseron equ 0x4105
 565:     -	4104          	var_curserstate equ 0x4104
 566:     -	4102          	var_curserx equ 0x4102
 567:     -	4103          	var_cursery equ 0x4103
 568:     -	412B          	var_dir equ 0x412B
 569:     -	41CB          	var_idebuffer equ 0x41CB
 570:     -	417B          	var_input equ 0x417B
 571:     -	4101          	var_last_char equ 0x4101
 572:     -	4114          	var_opcode equ 0x4114
 573:     -	4116          	var_opcode_length equ 0x4116
 574:     -	4119          	var_opcode_pcount equ 0x4119
 575:     -	4110          	var_opcode_start equ 0x4110
 576:     -	4117          	var_opcode_string equ 0x4117
 577:     -	4112          	var_opcode_table equ 0x4112
 578:     -	4115          	var_opcode_x equ 0x4115
 579:     -	4109          	var_pio_present equ 0x4109
 580:     -	411B          	var_ps2mem equ 0x411B
 581:     -	410B          	var_scratch equ 0x410B
**** test.asm ****
   2:     -	8000          	    START_ADDR   .EQU 0x8000
   3:				    
   4:				
   5:     -	8000          	    org START_ADDR  
   6:     -	8000          	com_header:
   7:    0+10	8000  C34080  	    jp com_prg
   8:     -	8003  00      	    db 0x00
   9:     -	8004  00000000	    dw 0x00, 0x00, 0x00   ;always 0
	              0000
  10:     -	800A  0080    	    dw [START_ADDR]     ;start addr
  11:     -	800C  5E9E    	    dw [_eof]           ;end of file
  12:     -	800E  5E1E    	    dw [_eof - START_ADDR]  ;length
  13:     -	8010 ..803F 00	    dc 48,0x00
  14:				    
  15:     -	8040          	com_prg:
  16:				    ;shadow rom
  17:   10+17	8040  CDD001  	    call PRINTINLINE
  18:     -	8043  0A0D5368	    db 10,13,"Shadowing ROM @ 0x0000-0x3FFF ...",10,13,0 
	              61646F77
	              696E6720
	              524F4D20
	              40203078
	              30303030
	              2D307833
	              46464620
	              2E2E2E0A
	              0D00
  19:   27+7	8069  3E01    	    ld a,0x01       ;set bit1 to switch to ram
  20:   34+11	806B  D300    	    out (0x00),a    ;store to bank select register
  21:   45+10	806D  217B80  	    ld hl,[prg_start]
  22:   55+10	8070  110000  	    ld de,0
  23:   65+10	8073  01E31D  	    ld bc,[prg_end-prg_start]
  24:   75+16+5	8076  EDB0    	    ldir
  25:   91+10	8078  C30000  	    jp 0x0000
  26:				
  27:				
  28:     -	807B          	prg_start:
  29:     -	0000          	    phase 0x0000
  30:				
  31:     -	0000          	BASRST_00: ;Hardware Restart
  32:  101+10	0000  C35A00  	    jp CSTART    
  33:     -	0003 ..0007 00	    defs 5
  34:				    ;org 0x0008
  35:     -	0008          	BASRST_08  ;Print Char
  36:  111+10	0008  C32000  	    jp _BASRST_08
  37:     -	000B ..000F 00	    defs 5
  38:				    ;org 0x0010
  39:     -	0010          	BASRST_10  ;receive char
  40:  121+10	0010  C32D00  	    jp _BASRST_10
  41:     -	0013 ..0017 00	    defs 5
  42:				    ;org 0x0018
  43:     -	0018          	BASRST_18  ;Buffer length
  44:  131+10	0018  C34B00  	    jp _BASRST_18
  45:     -	001B ..001F 00	    defs 5
  46:				    ;org 0x0044
  47:				
  48:     -	0020          	_BASRST_08:
  49:  141+11	0020  D308    	    out (CS_SIO_A_D),a
  50:     -	0022          	_wait:
  51:  152+7	0022  3E01    	    ld a,1
  52:  159+11	0024  D309    	    out (CS_SIO_A_C),A
  53:  170+11	0026  DB09    	    in A,(CS_SIO_A_C) ;read RRx
  54:  181+8	0028  CB47    	    bit 0,A
  55:  189+7+5	002A  28F6    	    jr z,_wait
  56:  196+10	002C  C9      	    ret
  57:				
  58:     -	002D          	_BASRST_10:
  59:				    ;RTS ON
  60:  206+7	002D  3E05    	    ld a,005h ;write into WR0: select WR5
  61:  213+11	002F  D309    	    out (CS_SIO_A_C),A
  62:  224+7	0031  3EEA    	    ld a,0EAh ;DTR active, TX 8bit, BREAK off, TX on, RTS active
  63:  231+11	0033  D309    	    out (CS_SIO_A_C),A
  64:  242+4	0035  00      	    nop
  65:				    ;read if avail
  66:  246+4	0036  AF      	    xor a               ; a = 0
  67:  250+11	0037  D309    	    out (CS_SIO_A_C), a ; select reg 0
  68:  261+11	0039  DB09    	    in a, (CS_SIO_A_C)  ; read reg 0
  69:  272+7	003B  E601    	    and	1               ; mask D0 (recieve char available)
  70:				    ;RTS OFF
  71:  279+11	003D  F5      	    push af
  72:  290+7	003E  3E05    	    ld a,005h ;write into WR0: select WR5
  73:  297+11	0040  D309    	    out (CS_SIO_A_C),A
  74:  308+7	0042  3E68    	    ld a,068h ;DTR inactive, TX 8bit, BREAK off, TX on, RTS inactive
  75:  315+11	0044  D309    	    out (CS_SIO_A_C),A
  76:  326+10	0046  F1      	    pop af
  77:  336+5+6	0047  C8      	    ret	Z               ; return 0 if no char
  78:				    ;read data
  79:  341+11	0048  DB08    	    in a, (CS_SIO_A_D)  ; read char if avail
  80:  352+10	004A  C9      	    ret                 ; return
  81:				
  82:     -	004B          	_BASRST_18:
  83:  362+7	004B  3E00    	    ld a,0
  84:  369+10	004D  C9      	    ret
  85:				
  86:     -	004E          	BASSTART:
  87:				.include "basic.s"
**** include/basic.s ****
   1:				;==============================================================================
   2:				;
   3:				; The rework to support MS Basic HLOAD and the Z80 instruction tuning are
   4:				; copyright (C) 2020 Phillip Stevens
   5:				;
   6:				; This Source Code Form is subject to the terms of the Mozilla Public
   7:				; License, v. 2.0. If a copy of the MPL was not distributed with this
   8:				; file, You can obtain one at http://mozilla.org/MPL/2.0/.
   9:				;
  10:				; The HLOAD function supports Intel HEX encoded program upload.
  11:				; Updates LSTRAM and STRSPC, adds program origin address to USR+1.
  12:				; It resets and clears runtime variables.
  13:				;
  14:				; The RESET function returns to cold start status.
  15:				;
  16:				; feilipu, August 2020
  17:				;
  18:				;==============================================================================
  19:				;
  20:				; The updates to the original BASIC within this file are copyright Grant Searle
  21:				;
  22:				; You have permission to use this for NON COMMERCIAL USE ONLY
  23:				; If you wish to use it elsewhere, please include an acknowledgement to myself.
  24:				;
  25:				; http://searle.wales/
  26:				;
  27:				;==============================================================================
  28:				;
  29:				; NASCOM ROM BASIC Ver 4.7, (C) 1978 Microsoft
  30:				; Scanned from source published in 80-BUS NEWS from Vol 2, Issue 3
  31:				; (May-June 1983) to Vol 3, Issue 3 (May-June 1984)
  32:				; Adapted for the freeware Zilog Macro Assembler 2.10 to produce
  33:				; the original ROM code (checksum A934H). PA
  34:				;
  35:				;==============================================================================
  36:				
  37:				
  38:				; GENERAL EQUATES
  39:				
  40:     -	0003          	CTRLC   .EQU    03H             ; Control "C"
  41:     -	0007          	CTRLG   .EQU    07H             ; Control "G"
  42:     -	0008          	BKSP    .EQU    08H             ; Back space
  43:     -	000A          	LF      .EQU    0AH             ; Line feed
  44:     -	000C          	CS      .EQU    0CH             ; Clear screen
  45:     -	000D          	CR      .EQU    0DH             ; Carriage return
  46:     -	000F          	CTRLO   .EQU    0FH             ; Control "O"
  47:     -	0011          	CTRLQ   .EQU    11H             ; Control "Q"
  48:     -	0012          	CTRLR   .EQU    12H             ; Control "R"
  49:     -	0013          	CTRLS   .EQU    13H             ; Control "S"
  50:     -	0015          	CTRLU   .EQU    15H             ; Control "U"
  51:     -	001B          	ESC     .EQU    1BH             ; Escape
  52:     -	007F          	DEL     .EQU    7FH             ; Delete
  53:				
  54:				; BASIC WORK SPACE LOCATIONS
  55:				
  56:     -	1DE3          	WRKSPC  .EQU    _WORKSPACE          ; <<<< BASIC Work space ** Rx buffer & Tx buffer located from 8080H **
  57:     -	1DE6          	USR     .EQU    WRKSPC+003H     ; "USR (x)" jump
  58:     -	1DE9          	OUTSUB  .EQU    WRKSPC+006H     ; "OUT p,n"
  59:     -	1DEA          	OTPORT  .EQU    WRKSPC+007H     ; Port (p)
  60:     -	1DEC          	DIVSUP  .EQU    WRKSPC+009H     ; Division support routine
  61:     -	1DED          	DIV1    .EQU    WRKSPC+00AH     ; <- Values
  62:     -	1DF1          	DIV2    .EQU    WRKSPC+00EH     ; <-   to
  63:     -	1DF5          	DIV3    .EQU    WRKSPC+012H     ; <-   be
  64:     -	1DF8          	DIV4    .EQU    WRKSPC+015H     ; <-inserted
  65:     -	1DFA          	SEED    .EQU    WRKSPC+017H     ; Random number seed
  66:     -	1E1D          	LSTRND  .EQU    WRKSPC+03AH     ; Last random number
  67:     -	1E21          	INPSUB  .EQU    WRKSPC+03EH     ; #INP (x)" Routine
  68:     -	1E22          	INPORT  .EQU    WRKSPC+03FH     ; PORT (x)
  69:     -	1E24          	NULLS   .EQU    WRKSPC+041H     ; Number of nulls
  70:     -	1E25          	LWIDTH  .EQU    WRKSPC+042H     ; Terminal width
  71:     -	1E26          	COMMAN  .EQU    WRKSPC+043H     ; Width for commas
  72:     -	1E27          	NULFLG  .EQU    WRKSPC+044H     ; Null after input byte flag
  73:     -	1E28          	CTLOFG  .EQU    WRKSPC+045H     ; Control "O" flag
  74:     -	1E29          	LINESC  .EQU    WRKSPC+046H     ; Lines counter
  75:     -	1E2B          	LINESN  .EQU    WRKSPC+048H     ; Lines number
  76:     -	1E2D          	CHKSUM  .EQU    WRKSPC+04AH     ; Array load/save check sum
  77:     -	1E2F          	NMIFLG  .EQU    WRKSPC+04CH     ; Flag for NMI break routine
  78:     -	1E30          	BRKFLG  .EQU    WRKSPC+04DH     ; Break flag
  79:     -	1E31          	RINPUT  .EQU    WRKSPC+04EH     ; Input reflection
  80:     -	1E34          	STRSPC  .EQU    WRKSPC+051H     ; Bottom of string space
  81:     -	1E36          	LINEAT  .EQU    WRKSPC+053H     ; Current line number
  82:     -	1E38          	BASTXT  .EQU    WRKSPC+055H     ; Pointer to start of program
  83:     -	1E3B          	BUFFER  .EQU    WRKSPC+058H     ; Input buffer
  84:     -	1E40          	STACK   .EQU    WRKSPC+05DH     ; Initial stack
  85:     -	1E85          	CURPOS  .EQU    WRKSPC+0A2H     ; <<<< Character position on line ** Top of Loader TEMPSTACK **
  86:     -	1E86          	LCRFLG  .EQU    WRKSPC+0A3H     ; Locate/Create flag
  87:     -	1E87          	TYPE    .EQU    WRKSPC+0A4H     ; Data type flag
  88:     -	1E88          	DATFLG  .EQU    WRKSPC+0A5H     ; Literal statement flag
  89:     -	1E89          	LSTRAM  .EQU    WRKSPC+0A6H     ; Last available RAM
  90:     -	1E8B          	TMSTPT  .EQU    WRKSPC+0A8H     ; Temporary string pointer
  91:     -	1E8D          	TMSTPL  .EQU    WRKSPC+0AAH     ; Temporary string pool
  92:     -	1E99          	TMPSTR  .EQU    WRKSPC+0B6H     ; Temporary string
  93:     -	1E9D          	STRBOT  .EQU    WRKSPC+0BAH     ; Bottom of string space
  94:     -	1E9F          	CUROPR  .EQU    WRKSPC+0BCH     ; Current operator in EVAL
  95:     -	1EA1          	LOOPST  .EQU    WRKSPC+0BEH     ; First statement of loop
  96:     -	1EA3          	DATLIN  .EQU    WRKSPC+0C0H     ; Line of current DATA item
  97:     -	1EA5          	FORFLG  .EQU    WRKSPC+0C2H     ; "FOR" loop flag
  98:     -	1EA6          	LSTBIN  .EQU    WRKSPC+0C3H     ; Last byte entered
  99:     -	1EA7          	READFG  .EQU    WRKSPC+0C4H     ; Read/Input flag
 100:     -	1EA8          	BRKLIN  .EQU    WRKSPC+0C5H     ; Line of break
 101:     -	1EAA          	NXTOPR  .EQU    WRKSPC+0C7H     ; Next operator in EVAL
 102:     -	1EAC          	ERRLIN  .EQU    WRKSPC+0C9H     ; Line of error
 103:     -	1EAE          	CONTAD  .EQU    WRKSPC+0CBH     ; Where to CONTinue
 104:     -	1EB0          	PROGND  .EQU    WRKSPC+0CDH     ; End of program
 105:     -	1EB2          	VAREND  .EQU    WRKSPC+0CFH     ; End of variables
 106:     -	1EB4          	ARREND  .EQU    WRKSPC+0D1H     ; End of arrays
 107:     -	1EB6          	NXTDAT  .EQU    WRKSPC+0D3H     ; Next data item
 108:     -	1EB8          	FNRGNM  .EQU    WRKSPC+0D5H     ; Name of FN argument
 109:     -	1EBA          	FNARG   .EQU    WRKSPC+0D7H     ; FN argument value
 110:     -	1EBE          	FPREG   .EQU    WRKSPC+0DBH     ; Floating point register
 111:     -	1EC1          	FPEXP   .EQU    FPREG+3         ; Floating point exponent
 112:     -	1EC2          	SGNRES  .EQU    WRKSPC+0DFH     ; Sign of result
 113:     -	1EC3          	PBUFF   .EQU    WRKSPC+0E0H     ; Number print buffer
 114:     -	1ED0          	MULVAL  .EQU    WRKSPC+0EDH     ; Multiplier
 115:     -	1ED3          	PROGST  .EQU    WRKSPC+0F0H     ; Start of program text area
 116:     -	1F37          	STLOOK  .EQU    WRKSPC+154H     ; Start of memory test
 117:				
 118:				; BASIC ERROR CODE VALUES
 119:				
 120:     -	0000          	NF      .EQU    00H             ; NEXT without FOR
 121:     -	0002          	SN      .EQU    02H             ; Syntax error
 122:     -	0004          	RG      .EQU    04H             ; RETURN without GOSUB
 123:     -	0006          	OD      .EQU    06H             ; Out of DATA
 124:     -	0008          	FC      .EQU    08H             ; Function call error
 125:     -	000A          	OV      .EQU    0AH             ; Overflow
 126:     -	000C          	OM      .EQU    0CH             ; Out of memory
 127:     -	000E          	UL      .EQU    0EH             ; Undefined line number
 128:     -	0010          	BS      .EQU    10H             ; Bad subscript
 129:     -	0012          	DD      .EQU    12H             ; Re-DIMensioned array
 130:     -	0014          	DZ      .EQU    14H             ; Division by zero (/0)
 131:     -	0016          	ID      .EQU    16H             ; Illegal direct
 132:     -	0018          	TM      .EQU    18H             ; Type miss-match
 133:     -	001A          	OS      .EQU    1AH             ; Out of string space
 134:     -	001C          	LS      .EQU    1CH             ; String too long
 135:     -	001E          	ST      .EQU    1EH             ; String formula too complex
 136:     -	0020          	CN      .EQU    20H             ; Can't CONTinue
 137:     -	0022          	UF      .EQU    22H             ; UnDEFined FN function
 138:     -	0024          	MO      .EQU    24H             ; Missing operand
 139:     -	0026          	HX      .EQU    26H             ; HEX error
 140:     -	0028          	BN      .EQU    28H             ; BIN error
 141:				
 142:				;        .ORG    0250H           ; <<<< Modified to allow for ACIA Tx/Rx IM1
 143:				
 144:  379+10	004E  C35A00  	COLD:   JP      CSTART          ; Jump in for cold start (0x0250)
 145:  389+10	0051  C3DD00  	WARM:   JP      WARMST          ; Jump in for warm start (0x0253)
 146:				
 147:     -	0054  05      	        .defb   5               ; pad so DEINT is 0x025B, ABPASS is 0x025D
 148:				
 149:     -	0055  0109    	        .WORD   DEINT           ; 0x025B Get integer -32768 to 32767
 150:     -	0057  D210    	        .WORD   ABPASS          ; 0x025D Return integer in AB
 151:				
 152:  399+5+6	0059  C0      	RESET:  RET     NZ              ; Return if any more on line
 153:  404+10	005A  21E31D  	CSTART: LD      HL,WRKSPC       ; Start of workspace RAM
 154:  414+6	005D  F9      	        LD      SP,HL           ; Set up a temporary stack
 155:  420+4	005E  AF      	        XOR     A               ; Clear break flag
 156:  424+13	005F  32301E  	        LD      (BRKFLG),A
 157:				
 158:  437+10	0062  211E03  	INIT:   LD      HL,INITAB       ; Initialise workspace
 159:  447+10	0065  015A00  	        LD      BC,INITBE-INITAB+3  ; Bytes to copy
 160:  457+10	0068  11E31D  	        LD      DE,WRKSPC       ; Into workspace RAM
 161:  467+16+5	006B  EDB0    	        LDIR                    ; Copy
 162:  483+4	006D  EB      	        EX      DE,HL           ; End of copy destination to HL
 163:  487+6	006E  F9      	        LD      SP,HL           ; Temporary stack
 164:  493+17	006F  CD2605  	        CALL    CLREG           ; Clear registers and stack
 165:  510+17	0072  CD190B  	        CALL    PRNTCRLF        ; Output CRLF
 166:  527+13	0075  32841E  	        LD      (BUFFER+72+1),A ; Mark end of buffer
 167:  540+13	0078  32D31E  	        LD      (PROGST),A      ; Initialise program area
 168:     -	007B          	MSIZE:  ;LD      HL,MEMMSG       ; Point to message
 169:				        ;CALL    PRS             ; Output "Memory size"
 170:				        ;CALL    PROMPT          ; Get input with '?'
 171:				        ;CALL    GETCHR          ; Get next character
 172:				        ;OR      A               ; Set flags
 173:				        ;JP      NZ,TSTMEM       ; If number - Test if RAM there
 174:  553+10	007B  21371F  	        LD      HL,STLOOK       ; Point to start of RAM
 175:  563+6	007E  23      	MLOOP:  INC     HL              ; Next byte
 176:  569+4	007F  7C      	        LD      A,H             ; Above address FFFF ?
 177:  573+4	0080  B5      	        OR      L
 178:  577+10	0081  CAA200  	        JP      Z,SETTOP        ; Yes - 64K RAM
 179:  587+7	0084  7E      	        LD      A,(HL)          ; Get contents
 180:  594+4	0085  47      	        LD      B,A             ; Save it
 181:  598+4	0086  2F      	        CPL                     ; Flip all bits
 182:  602+7	0087  77      	        LD      (HL),A          ; Put it back
 183:  609+7	0088  BE      	        CP      (HL)            ; RAM there if same
 184:  616+7	0089  70      	        LD      (HL),B          ; Restore old contents
 185:  623+10	008A  CA7E00  	        JP      Z,MLOOP         ; If RAM - test next byte
 186:  633+10	008D  C3A200  	        JP      SETTOP          ; Top of RAM found
 187:				
 188:  643+17	0090  CD1B09  	TSTMEM: CALL    ATOH            ; Get high memory into DE
 189:  660+4	0093  B7      	        OR      A               ; Set flags on last byte
 190:  664+10	0094  C2EB03  	        JP      NZ,SNERR        ; ?SN Error if bad character
 191:  674+4	0097  EB      	        EX      DE,HL           ; Address into HL
 192:  678+6	0098  2B      	        DEC     HL              ; Back one byte
 193:  684+7	0099  3ED9    	        LD      A,11011001B     ; Test byte
 194:  691+7	009B  46      	        LD      B,(HL)          ; Get old contents
 195:  698+7	009C  77      	        LD      (HL),A          ; Load test byte
 196:  705+7	009D  BE      	        CP      (HL)            ; RAM there if same
 197:  712+7	009E  70      	        LD      (HL),B          ; Restore old contents
 198:  719+10	009F  C27B00  	        JP      NZ,MSIZE        ; Ask again if no RAM
 199:				
 200:  729+6	00A2  2B      	SETTOP: DEC     HL              ; Back one byte
 201:  735+10	00A3  11361F  	        LD      DE,STLOOK-1     ; See if enough RAM
 202:  745+4	00A6  7C      	        LD      A,H             ; Compare DE with HL
 203:  749+4	00A7  92      	        SUB     D               ; Compare with D
 204:  753+7+5	00A8  2002    	        JR      NZ,$+4          ; Different - Exit
 205:  760+4	00AA  7D      	        LD      A,L             ; Get L
 206:  764+4	00AB  93      	        SUB     E               ; Compare with E
 207:  768+10	00AC  DA7B00  	        JP      C,MSIZE         ; Ask again if not enough RAM
 208:  778+10	00AF  11CEFF  	        LD      DE,0-50         ; 50 Bytes string space
 209:  788+16	00B2  22891E  	        LD      (LSTRAM),HL     ; Save last available RAM
 210:  804+11	00B5  19      	        ADD     HL,DE           ; Allocate string space
 211:  815+16	00B6  22341E  	        LD      (STRSPC),HL     ; Save string space
 212:  831+17	00B9  CD0105  	        CALL    CLRPTR          ; Clear program area
 213:  848+16	00BC  2A341E  	        LD      HL,(STRSPC)     ; Get end of memory
 214:  864+10	00BF  11EFFF  	        LD      DE,0-17         ; Offset for free bytes
 215:  874+11	00C2  19      	        ADD     HL,DE           ; Adjust HL
 216:  885+10	00C3  11D31E  	        LD      DE,PROGST       ; Start of program text
 217:  895+4	00C6  7D      	        LD      A,L             ; Get LSB
 218:  899+4	00C7  93      	        SUB     E               ; Adjust it
 219:  903+4	00C8  6F      	        LD      L,A             ; Re-save
 220:  907+4	00C9  7C      	        LD      A,H             ; Get MSB
 221:  911+4	00CA  9A      	        SBC     A,D             ; Adjust it
 222:  915+4	00CB  67      	        LD      H,A             ; Re-save
 223:  919+11	00CC  E5      	        PUSH    HL              ; Save bytes free
 224:  930+10	00CD  21F500  	        LD      HL,SIGNON       ; Sign-on message
 225:  940+17	00D0  CD0212  	        CALL    PRS             ; Output string
 226:  957+10	00D3  E1      	        POP     HL              ; Get bytes free back
 227:  967+17	00D4  CDCF18  	        CALL    PRNTHL          ; Output amount of free memory
 228:  984+10	00D7  21E600  	        LD      HL,BFREE        ; " Bytes free" message
 229:  994+17	00DA  CD0212  	        CALL    PRS             ; Output string
 230:				
 231: 1011+10	00DD  31401E  	WARMST: LD      SP,STACK        ; Temporary stack
 232: 1021+17	00E0  CD2605  	BRKRET: CALL    CLREG           ; Clear registers and stack
 233: 1038+10	00E3  C33904  	        JP      PRNTOK          ; Go to get command line
 234:				
 235:     -	00E6  20427974	BFREE:  .BYTE   " Bytes free",CR,LF,0,0
	              65732066
	              7265650D
	              0A0000
 236:				
 237:     -	00F5  5A383020	SIGNON: .BYTE   "Z80 BASIC Ver 4.7c",CR,LF
	              42415349
	              43205665
	              7220342E
	              37630D0A
 238:     -	0109  436F7079	        .BYTE   "Copyright ",40,"C",41
	              72696768
	              74202843
	              29
 239:     -	0116  20313937	        .BYTE   " 1978 by Microsoft",CR,LF
	              38206279
	              204D6963
	              726F736F
	              66740D0A
 240:     -	012A  4D6F6469	        .BYTE   "Modified for Z8C by Dennis Gunia",CR,LF,0,0
	              66696564
	              20666F72
	              205A3843
	              20627920
	              44656E6E
	              69732047
	              756E6961
	              0D0A0000
 241:				
 242:     -	014E  4D656D6F	MEMMSG: .BYTE   "Memory top",0
	              72792074
	              6F7000
 243:				
 244:				; FUNCTION ADDRESS TABLE
 245:				
 246:     -	0159  4E17    	FNCTAB: .WORD   SGN
 247:     -	015B  0418    	        .WORD   INT
 248:     -	015D  6417    	        .WORD   ABS
 249:     -	015F  E61D    	        .WORD   USR
 250:     -	0161  B010    	        .WORD   FRE
 251:     -	0163  5E14    	        .WORD   INP
 252:     -	0165  DE10    	        .WORD   POS
 253:     -	0167  DC19    	        .WORD   SQR
 254:     -	0169  D51A    	        .WORD   RND
 255:     -	016B  E415    	        .WORD   LOG
 256:     -	016D  371A    	        .WORD   EXP
 257:     -	016F  631B    	        .WORD   COS
 258:     -	0171  691B    	        .WORD   SIN
 259:     -	0173  CF1B    	        .WORD   TAN
 260:     -	0175  E91B    	        .WORD   ATN
 261:     -	0177  B214    	        .WORD   PEEK
 262:     -	0179  551C    	        .WORD   DEEK
 263:     -	017B  8B13    	        .WORD   LEN
 264:     -	017D  8211    	        .WORD   STR
 265:     -	017F  2514    	        .WORD   VAL
 266:     -	0181  9A13    	        .WORD   ASC
 267:     -	0183  AB13    	        .WORD   CHR
 268:     -	0185  EE1C    	        .WORD   HEX
 269:     -	0187  811D    	        .WORD   BIN
 270:     -	0189  BB13    	        .WORD   LEFT
 271:     -	018B  EB13    	        .WORD   RIGHT
 272:     -	018D  F513    	        .WORD   MID
 273:				
 274:				; RESERVED WORD LIST
 275:				
 276:     -	018F  C54E44  	WORDS:  .BYTE   'E'+80H,"ND"    ; 80h
 277:     -	0192  C64F52  	        .BYTE   'F'+80H,"OR"
 278:     -	0195  CE455854	        .BYTE   'N'+80H,"EXT"
 279:     -	0199  C4415441	        .BYTE   'D'+80H,"ATA"
 280:     -	019D  C94E5055	        .BYTE   'I'+80H,"NPUT"
	              54
 281:     -	01A2  C4494D  	        .BYTE   'D'+80H,"IM"
 282:     -	01A5  D2454144	        .BYTE   'R'+80H,"EAD"
 283:     -	01A9  CC4554  	        .BYTE   'L'+80H,"ET"
 284:     -	01AC  C74F544F	        .BYTE   'G'+80H,"OTO"
 285:     -	01B0  D2554E  	        .BYTE   'R'+80H,"UN"
 286:     -	01B3  C946    	        .BYTE   'I'+80H,"F"
 287:     -	01B5  D2455354	        .BYTE   'R'+80H,"ESTORE"
	              4F5245
 288:     -	01BC  C74F5355	        .BYTE   'G'+80H,"OSUB"
	              42
 289:     -	01C1  D2455455	        .BYTE   'R'+80H,"ETURN"
	              524E
 290:     -	01C7  D2454D  	        .BYTE   'R'+80H,"EM"
 291:     -	01CA  D3544F50	        .BYTE   'S'+80H,"TOP"
 292:     -	01CE  CF5554  	        .BYTE   'O'+80H,"UT"    ; 90h
 293:     -	01D1  CF4E    	        .BYTE   'O'+80H,"N"
 294:     -	01D3  CE554C4C	        .BYTE   'N'+80H,"ULL"
 295:     -	01D7  D7414954	        .BYTE   'W'+80H,"AIT"
 296:     -	01DB  C44546  	        .BYTE   'D'+80H,"EF"
 297:     -	01DE  D04F4B45	        .BYTE   'P'+80H,"OKE"
 298:     -	01E2  C44F4B45	        .BYTE   'D'+80H,"OKE"
 299:     -	01E6  CC494E45	        .BYTE   'L'+80H,"INES"
	              53
 300:     -	01EB  C34C53  	        .BYTE   'C'+80H,"LS"
 301:     -	01EE  D7494454	        .BYTE   'W'+80H,"IDTH"
	              48
 302:     -	01F3  CD4F4E49	        .BYTE   'M'+80H,"ONITOR"
	              544F52
 303:     -	01FA  D2455345	        .BYTE   'R'+80H,"ESET"
	              54
 304:     -	01FF  D052494E	        .BYTE   'P'+80H,"RINT"
	              54
 305:     -	0204  C34F4E54	        .BYTE   'C'+80H,"ONT"
 306:     -	0208  CC495354	        .BYTE   'L'+80H,"IST"
 307:     -	020C  C34C4541	        .BYTE   'C'+80H,"LEAR"
	              52
 308:     -	0211  C84C4F41	        .BYTE   'H'+80H,"LOAD"  ; A0h
	              44
 309:     -	0216  CE4557  	        .BYTE   'N'+80H,"EW"
 310:				
 311:     -	0219  D4414228	        .BYTE   'T'+80H,"AB("
 312:     -	021D  D44F    	        .BYTE   'T'+80H,"O"
 313:     -	021F  C64E    	        .BYTE   'F'+80H,"N"
 314:     -	0221  D3504328	        .BYTE   'S'+80H,"PC("
 315:     -	0225  D448454E	        .BYTE   'T'+80H,"HEN"
 316:     -	0229  CE4F54  	        .BYTE   'N'+80H,"OT"
 317:     -	022C  D3544550	        .BYTE   'S'+80H,"TEP"
 318:				
 319:     -	0230  AB      	        .BYTE   '+'+80H
 320:     -	0231  AD      	        .BYTE   '-'+80H
 321:     -	0232  AA      	        .BYTE   '*'+80H
 322:     -	0233  AF      	        .BYTE   '/'+80H
 323:     -	0234  DE      	        .BYTE   '^'+80H
 324:     -	0235  C14E44  	        .BYTE   'A'+80H,"ND"
 325:     -	0238  CF52    	        .BYTE   'O'+80H,"R"
 326:     -	023A  BE      	        .BYTE   '>'+80H         ; B0h
 327:     -	023B  BD      	        .BYTE   '='+80H
 328:     -	023C  BC      	        .BYTE   '<'+80H
 329:				
 330:     -	023D  D3474E  	        .BYTE   'S'+80H,"GN"
 331:     -	0240  C94E54  	        .BYTE   'I'+80H,"NT"
 332:     -	0243  C14253  	        .BYTE   'A'+80H,"BS"
 333:     -	0246  D55352  	        .BYTE   'U'+80H,"SR"
 334:     -	0249  C65245  	        .BYTE   'F'+80H,"RE"
 335:     -	024C  C94E50  	        .BYTE   'I'+80H,"NP"
 336:     -	024F  D04F53  	        .BYTE   'P'+80H,"OS"
 337:     -	0252  D35152  	        .BYTE   'S'+80H,"QR"
 338:     -	0255  D24E44  	        .BYTE   'R'+80H,"ND"
 339:     -	0258  CC4F47  	        .BYTE   'L'+80H,"OG"
 340:     -	025B  C55850  	        .BYTE   'E'+80H,"XP"
 341:     -	025E  C34F53  	        .BYTE   'C'+80H,"OS"
 342:     -	0261  D3494E  	        .BYTE   'S'+80H,"IN"
 343:     -	0264  D4414E  	        .BYTE   'T'+80H,"AN"    ; C0h
 344:     -	0267  C1544E  	        .BYTE   'A'+80H,"TN"
 345:     -	026A  D045454B	        .BYTE   'P'+80H,"EEK"
 346:     -	026E  C445454B	        .BYTE   'D'+80H,"EEK"
 347:     -	0272  CC454E  	        .BYTE   'L'+80H,"EN"
 348:     -	0275  D3545224	        .BYTE   'S'+80H,"TR$"
 349:     -	0279  D6414C  	        .BYTE   'V'+80H,"AL"
 350:     -	027C  C15343  	        .BYTE   'A'+80H,"SC"
 351:     -	027F  C3485224	        .BYTE   'C'+80H,"HR$"
 352:     -	0283  C8455824	        .BYTE   'H'+80H,"EX$"
 353:     -	0287  C2494E24	        .BYTE   'B'+80H,"IN$"
 354:     -	028B  CC454654	        .BYTE   'L'+80H,"EFT$"
	              24
 355:     -	0290  D2494748	        .BYTE   'R'+80H,"IGHT$"
	              5424
 356:     -	0296  CD494424	        .BYTE   'M'+80H,"ID$"
 357:     -	029A  80      	        .BYTE   80H             ; End of list marker
 358:				
 359:				; KEYWORD ADDRESS TABLE
 360:				
 361:     -	029B  9908    	WORDTB: .WORD   PEND
 362:     -	029D  8D07    	        .WORD   FOR
 363:     -	029F  9B0C    	        .WORD   NEXT
 364:     -	02A1  F009    	        .WORD   DATA
 365:     -	02A3  9A0B    	        .WORD   INPUT
 366:     -	02A5  F00E    	        .WORD   DIM
 367:     -	02A7  C90B    	        .WORD   READ
 368:     -	02A9  070A    	        .WORD   LET
 369:     -	02AB  AA09    	        .WORD   GOTO
 370:     -	02AD  8D09    	        .WORD   RUN
 371:     -	02AF  970A    	        .WORD   IF
 372:     -	02B1  5E08    	        .WORD   RESTOR
 373:     -	02B3  9909    	        .WORD   GOSUB
 374:     -	02B5  CB09    	        .WORD   RETURN
 375:     -	02B7  F209    	        .WORD   REM
 376:     -	02B9  9708    	        .WORD   STOP
 377:     -	02BB  6A14    	        .WORD   POUT
 378:     -	02BD  790A    	        .WORD   ON
 379:     -	02BF  D808    	        .WORD   NULL
 380:     -	02C1  7014    	        .WORD   WAIT
 381:     -	02C3  E610    	        .WORD   DEF
 382:     -	02C5  B914    	        .WORD   POKE
 383:     -	02C7  601C    	        .WORD   DOKE
 384:     -	02C9  461C    	        .WORD   LINES
 385:     -	02CB  381C    	        .WORD   CLS
 386:     -	02CD  3E1C    	        .WORD   WIDTH
 387:     -	02CF  351C    	        .WORD   MONITR
 388:     -	02D1  5900    	        .WORD   RESET
 389:     -	02D3  BB0A    	        .WORD   PRINT
 390:     -	02D5  C508    	        .WORD   CONT
 391:     -	02D7  0407    	        .WORD   LIST
 392:     -	02D9  4409    	        .WORD   CLEAR
 393:     -	02DB  771C    	        .WORD   HLOAD
 394:     -	02DD  0005    	        .WORD   NEW
 395:				
 396:				; RESERVED WORD TOKEN VALUES
 397:				
 398:     -	0080          	ZEND    .EQU    080H            ; END
 399:     -	0081          	ZFOR    .EQU    081H            ; FOR
 400:     -	0083          	ZDATA   .EQU    083H            ; DATA
 401:     -	0088          	ZGOTO   .EQU    088H            ; GOTO
 402:     -	008C          	ZGOSUB  .EQU    08CH            ; GOSUB
 403:     -	008E          	ZREM    .EQU    08EH            ; REM
 404:     -	009C          	ZPRINT  .EQU    09CH            ; PRINT
 405:     -	00A1          	ZNEW    .EQU    0A1H            ; NEW
 406:				
 407:     -	00A2          	ZTAB    .EQU    0A2H            ; TAB
 408:     -	00A3          	ZTO     .EQU    0A3H            ; TO
 409:     -	00A4          	ZFN     .EQU    0A4H            ; FN
 410:     -	00A5          	ZSPC    .EQU    0A5H            ; SPC
 411:     -	00A6          	ZTHEN   .EQU    0A6H            ; THEN
 412:     -	00A7          	ZNOT    .EQU    0A7H            ; NOT
 413:     -	00A8          	ZSTEP   .EQU    0A8H            ; STEP
 414:				
 415:     -	00A9          	ZPLUS   .EQU    0A9H            ; +
 416:     -	00AA          	ZMINUS  .EQU    0AAH            ; -
 417:     -	00AB          	ZTIMES  .EQU    0ABH            ; *
 418:     -	00AC          	ZDIV    .EQU    0ACH            ; /
 419:     -	00AF          	ZOR     .EQU    0AFH            ; OR
 420:     -	00B0          	ZGTR    .EQU    0B0H            ; >
 421:     -	00B1          	ZEQUAL  .EQU    0B1H            ; =
 422:     -	00B2          	ZLTH    .EQU    0B2H            ; <
 423:     -	00B3          	ZSGN    .EQU    0B3H            ; SGN
 424:     -	00CB          	ZLEFT   .EQU    0CBH            ; LEFT$
 425:				
 426:				; ARITHMETIC PRECEDENCE TABLE
 427:				
 428:     -	02DF  79      	PRITAB: .BYTE   79H             ; Precedence value
 429:     -	02E0  B618    	        .WORD   PADD            ; FPREG = <last> + FPREG
 430:				
 431:     -	02E2  79      	        .BYTE   79H             ; Precedence value
 432:     -	02E3  D714    	        .WORD   PSUB            ; FPREG = <last> - FPREG
 433:				
 434:     -	02E5  7C      	        .BYTE   7CH             ; Precedence value
 435:     -	02E6  2316    	        .WORD   MULT            ; FPREG = <last> * FPREG
 436:				
 437:     -	02E8  7C      	        .BYTE   7CH             ; Precedence value
 438:     -	02E9  8E16    	        .WORD   DIV             ; FPREG = <last> / FPREG
 439:				
 440:     -	02EB  7F      	        .BYTE   7FH             ; Precedence value
 441:     -	02EC  ED19    	        .WORD   POWER           ; FPREG = <last> ^ FPREG
 442:				
 443:     -	02EE  50      	        .BYTE   50H             ; Precedence value
 444:     -	02EF  440E    	        .WORD   PAND            ; FPREG = <last> AND FPREG
 445:				
 446:     -	02F1  46      	        .BYTE   46H             ; Precedence value
 447:     -	02F2  430E    	        .WORD   POR             ; FPREG = <last> OR FPREG
 448:				
 449:				; BASIC ERROR CODE LIST
 450:				
 451:     -	02F4  4E46    	ERRORS: .BYTE   "NF"            ; NEXT without FOR
 452:     -	02F6  534E    	        .BYTE   "SN"            ; Syntax error
 453:     -	02F8  5247    	        .BYTE   "RG"            ; RETURN without GOSUB
 454:     -	02FA  4F44    	        .BYTE   "OD"            ; Out of DATA
 455:     -	02FC  4643    	        .BYTE   "FC"            ; Illegal function call
 456:     -	02FE  4F56    	        .BYTE   "OV"            ; Overflow error
 457:     -	0300  4F4D    	        .BYTE   "OM"            ; Out of memory
 458:     -	0302  554C    	        .BYTE   "UL"            ; Undefined line
 459:     -	0304  4253    	        .BYTE   "BS"            ; Bad subscript
 460:     -	0306  4444    	        .BYTE   "DD"            ; Re-DIMensioned array
 461:     -	0308  2F30    	        .BYTE   "/0"            ; Division by zero
 462:     -	030A  4944    	        .BYTE   "ID"            ; Illegal direct
 463:     -	030C  544D    	        .BYTE   "TM"            ; Type mis-match
 464:     -	030E  4F53    	        .BYTE   "OS"            ; Out of string space
 465:     -	0310  4C53    	        .BYTE   "LS"            ; String too long
 466:     -	0312  5354    	        .BYTE   "ST"            ; String formula too complex
 467:     -	0314  434E    	        .BYTE   "CN"            ; Can't CONTinue
 468:     -	0316  5546    	        .BYTE   "UF"            ; Undefined FN function
 469:     -	0318  4D4F    	        .BYTE   "MO"            ; Missing operand
 470:     -	031A  4858    	        .BYTE   "HX"            ; HEX error
 471:     -	031C  424E    	        .BYTE   "BN"            ; BIN error
 472:				
 473:				; INITIALISATION TABLE -------------------------------------------------------
 474:				
 475: 1048+10	031E  C3DD00  	INITAB: JP      WARMST          ; Warm start jump
 476: 1058+10	0321  C31609  	        JP      FCERR           ; "USR (X)" jump (Set to Error)
 477:				
 478: 1068+11	0324  D300    	        OUT     (0),A           ; "OUT p,n" skeleton
 479: 1079+10	0326  C9      	        RET
 480:				
 481: 1089+7	0327  D600    	        SUB     0               ; Division support routine
 482: 1096+4	0329  6F      	        LD      L,A
 483: 1100+4	032A  7C      	        LD      A,H
 484: 1104+7	032B  DE00    	        SBC     A,0
 485: 1111+4	032D  67      	        LD      H,A
 486: 1115+4	032E  78      	        LD      A,B
 487: 1119+7	032F  DE00    	        SBC     A,0
 488: 1126+4	0331  47      	        LD      B,A
 489: 1130+7	0332  3E00    	        LD      A,0
 490: 1137+10	0334  C9      	        RET
 491:				
 492:     -	0335  000000  	        .BYTE   0,0,0                   ; Random number seed
 493:				                                        ; table used by RND
 494:     -	0338  354ACA99	        .BYTE   035H,04AH,0CAH,099H     ;-2.65145E+07
 495:     -	033C  391C7698	        .BYTE   039H,01CH,076H,098H     ; 1.61291E+07
 496:     -	0340  2295B398	        .BYTE   022H,095H,0B3H,098H     ;-1.17691E+07
 497:     -	0344  0ADD4798	        .BYTE   00AH,0DDH,047H,098H     ; 1.30983E+07
 498:     -	0348  53D19999	        .BYTE   053H,0D1H,099H,099H     ;-2-01612E+07
 499:     -	034C  0A1A9F98	        .BYTE   00AH,01AH,09FH,098H     ;-1.04269E+07
 500:     -	0350  65BCCD98	        .BYTE   065H,0BCH,0CDH,098H     ;-1.34831E+07
 501:     -	0354  D6773E98	        .BYTE   0D6H,077H,03EH,098H     ; 1.24825E+07
 502:     -	0358  52C74F80	        .BYTE   052H,0C7H,04FH,080H     ; Last random number
 503:				
 504: 1147+11	035C  DB00    	        IN      A,(0)           ; INP (x) skeleton
 505: 1158+10	035E  C9      	        RET
 506:				
 507:     -	035F  01      	        .BYTE   1               ; POS (x) number (1)
 508:     -	0360  FF      	        .BYTE   255             ; Terminal width (255 = no auto CRLF)
 509:     -	0361  1C      	        .BYTE   28              ; Width for commas (3 columns)
 510:     -	0362  00      	        .BYTE   0               ; No nulls after input bytes
 511:     -	0363  00      	        .BYTE   0               ; Output enabled (^O off)
 512:				
 513:     -	0364  1400    	        .WORD   20              ; Initial lines counter
 514:     -	0366  1400    	        .WORD   20              ; Initial lines number
 515:     -	0368  0000    	        .WORD   0               ; Array load/save check sum
 516:				
 517:     -	036A  00      	        .BYTE   0               ; Break not by NMI
 518:     -	036B  00      	        .BYTE   0               ; Break flag
 519:				
 520: 1168+10	036C  C33906  	        JP      TTYLIN          ; Input reflection (set to TTY)
 521:				
 522:     -	036F  371F    	        .WORD   STLOOK          ; Temp string space
 523:     -	0371  FEFF    	        .WORD   -2              ; Current line number (cold)
 524:     -	0373  D41E    	        .WORD   PROGST+1        ; Start of program text
 525:     -	0375          	INITBE:
 526:     -	0375  03      	        .defb   3               ; Fill 3 Bytes for copy
 527:				
 528:				; END OF INITIALISATION TABLE ---------------------------------------------------
 529:				
 530:     -	0376  20457272	ERRMSG: .BYTE   " Error",0
	              6F7200
 531:     -	037D  20696E20	INMSG:  .BYTE   " in ",0
	              00
 532:     -	0381          	ZERBYT  .EQU    $-1             ; A zero byte
 533:     -	0382  4F6B0D0A	OKMSG:  .BYTE   "Ok",CR,LF,0,0
	              0000
 534:     -	0388  42726561	BRKMSG: .BYTE   "Break",0
	              6B00
 535:				
 536: 1178+10	038E  210400  	BAKSTK: LD      HL,4            ; Look for "FOR" block with
 537: 1188+11	0391  39      	        ADD     HL,SP           ; same index as specified
 538: 1199+7	0392  7E      	LOKFOR: LD      A,(HL)          ; Get block ID
 539: 1206+6	0393  23      	        INC     HL              ; Point to index address
 540: 1212+7	0394  FE81    	        CP      ZFOR            ; Is it a "FOR" token
 541: 1219+5+6	0396  C0      	        RET     NZ              ; No - exit
 542: 1224+7	0397  4E      	        LD      C,(HL)          ; BC = Address of "FOR" index
 543: 1231+6	0398  23      	        INC     HL
 544: 1237+7	0399  46      	        LD      B,(HL)
 545: 1244+6	039A  23      	        INC     HL              ; Point to sign of STEP
 546: 1250+11	039B  E5      	        PUSH    HL              ; Save pointer to sign
 547: 1261+4	039C  69      	        LD      L,C             ; HL = address of "FOR" index
 548: 1265+4	039D  60      	        LD      H,B
 549: 1269+4	039E  7A      	        LD      A,D             ; See if an index was specified
 550: 1273+4	039F  B3      	        OR      E               ; DE = 0 if no index specified
 551: 1277+4	03A0  EB      	        EX      DE,HL           ; Specified index into HL
 552: 1281+10	03A1  CAAB03  	        JP      Z,INDFND        ; Skip if no index given
 553: 1291+4	03A4  EB      	        EX      DE,HL           ; Index back into DE
 554: 1295+4	03A5  7C      	        LD      A,H             ; Compare index with one given
 555: 1299+4	03A6  92      	        SUB     D               ; Compare with D
 556: 1303+7+5	03A7  2002    	        JR      NZ,$+4          ; Different - Exit
 557: 1310+4	03A9  7D      	        LD      A,L             ; Get L
 558: 1314+4	03AA  93      	        SUB     E               ; Compare with E
 559: 1318+10	03AB  010D00  	INDFND: LD      BC,16-3         ; Offset to next block
 560: 1328+10	03AE  E1      	        POP     HL              ; Restore pointer to sign
 561: 1338+5+6	03AF  C8      	        RET     Z               ; Return if block found
 562: 1343+11	03B0  09      	        ADD     HL,BC           ; Point to next block
 563: 1354+10	03B1  C39203  	        JP      LOKFOR          ; Keep on looking
 564:				
 565: 1364+17	03B4  CDD103  	MOVUP:  CALL    ENFMEM          ; See if enough memory
 566: 1381+11	03B7  C5      	MOVSTR: PUSH    BC              ; Save end of source
 567: 1392+19	03B8  E3      	        EX      (SP),HL         ; Swap source and dest" end
 568: 1411+10	03B9  C1      	        POP     BC              ; Get end of destination
 569: 1421+4	03BA  7C      	MOVLP:  LD      A,H             ; See if list moved
 570: 1425+4	03BB  92      	        SUB     D               ; Compare with D
 571: 1429+7+5	03BC  2002    	        JR      NZ,$+4          ; Different - Exit
 572: 1436+4	03BE  7D      	        LD      A,L             ; Get L
 573: 1440+4	03BF  93      	        SUB     E               ; Compare with E
 574: 1444+7	03C0  7E      	        LD      A,(HL)          ; Get byte
 575: 1451+7	03C1  02      	        LD      (BC),A          ; Move it
 576: 1458+5+6	03C2  C8      	        RET     Z               ; Exit if all done
 577: 1463+6	03C3  0B      	        DEC     BC              ; Next byte to move to
 578: 1469+6	03C4  2B      	        DEC     HL              ; Next byte to move
 579: 1475+10	03C5  C3BA03  	        JP      MOVLP           ; Loop until all bytes moved
 580:				
 581: 1485+11	03C8  E5      	CHKSTK: PUSH    HL              ; Save code string address
 582: 1496+16	03C9  2AB41E  	        LD      HL,(ARREND)     ; Lowest free memory
 583: 1512+7	03CC  0600    	        LD      B,0             ; BC = Number of levels to test
 584: 1519+11	03CE  09      	        ADD     HL,BC           ; 2 Bytes for each level
 585: 1530+11	03CF  09      	        ADD     HL,BC
 586:     -	03D0  3E      	        .BYTE   3EH             ; Skip "PUSH HL"
 587: 1541+11	03D1  E5      	ENFMEM: PUSH    HL              ; Save code string address
 588: 1552+7	03D2  3ED0    	        LD      A,0D0H          ; 48 Bytes minimum RAM
 589: 1559+4	03D4  95      	        SUB     L
 590: 1563+4	03D5  6F      	        LD      L,A
 591: 1567+7	03D6  3EFF    	        LD      A,0FFH          ; 48 Bytes minimum RAM
 592: 1574+4	03D8  9C      	        SBC     A,H
 593: 1578+10	03D9  DAE003  	        JP      C,OMERR         ; Not enough - ?OM Error
 594: 1588+4	03DC  67      	        LD      H,A
 595: 1592+11	03DD  39      	        ADD     HL,SP           ; Test if stack is overflowed
 596: 1603+10	03DE  E1      	        POP     HL              ; Restore code string address
 597: 1613+5+6	03DF  D8      	        RET     C               ; Return if enough mmory
 598: 1618+7	03E0  1E0C    	OMERR:  LD      E,OM            ; ?OM Error
 599: 1625+10	03E2  C3FF03  	        JP      ERROR
 600:				
 601: 1635+16	03E5  2AA31E  	DATSNR: LD      HL,(DATLIN)     ; Get line of current DATA item
 602: 1651+16	03E8  22361E  	        LD      (LINEAT),HL     ; Save as current line
 603: 1667+7	03EB  1E02    	SNERR:  LD      E,SN            ; ?SN Error
 604:     -	03ED  01      	        .BYTE   01H             ; Skip "LD E,DZ"
 605: 1674+7	03EE  1E14    	DZERR:  LD      E,DZ            ; ?/0 Error
 606:     -	03F0  01      	        .BYTE   01H             ; Skip "LD E,NF"
 607: 1681+7	03F1  1E00    	NFERR:  LD      E,NF            ; ?NF Error
 608:     -	03F3  01      	        .BYTE   01H             ; Skip "LD E,DD"
 609: 1688+7	03F4  1E12    	DDERR:  LD      E,DD            ; ?DD Error
 610:     -	03F6  01      	        .BYTE   01H             ; Skip "LD E,UF"
 611: 1695+7	03F7  1E22    	UFERR:  LD      E,UF            ; ?UF Error
 612:     -	03F9  01      	        .BYTE   01H             ; Skip "LD E,OV
 613: 1702+7	03FA  1E0A    	OVERR:  LD      E,OV            ; ?OV Error
 614:     -	03FC  01      	        .BYTE   01H             ; Skip "LD E,TM"
 615: 1709+7	03FD  1E18    	TMERR:  LD      E,TM            ; ?TM Error
 616:				
 617: 1716+17	03FF  CD2605  	ERROR:  CALL    CLREG           ; Clear registers and stack
 618: 1733+13	0402  32281E  	        LD      (CTLOFG),A      ; Enable output (A is 0)
 619: 1746+17	0405  CD0C0B  	        CALL    STTLIN          ; Start new line
 620: 1763+10	0408  21F402  	        LD      HL,ERRORS       ; Point to error codes
 621: 1773+4	040B  57      	        LD      D,A             ; D = 0 (A is 0)
 622: 1777+7	040C  3E3F    	        LD      A,'?'
 623: 1784+17	040E  CDC706  	        CALL    OUTC            ; Output '?'
 624: 1801+11	0411  19      	        ADD     HL,DE           ; Offset to correct error code
 625: 1812+7	0412  7E      	        LD      A,(HL)          ; First character
 626: 1819+17	0413  CDC706  	        CALL    OUTC            ; Output it
 627: 1836+17	0416  CD4F08  	        CALL    GETCHR          ; Get next character
 628: 1853+17	0419  CDC706  	        CALL    OUTC            ; Output it
 629: 1870+10	041C  217603  	        LD      HL,ERRMSG       ; "Error" message
 630: 1880+17	041F  CD0212  	ERRIN:  CALL    PRS             ; Output message
 631: 1897+16	0422  2A361E  	        LD      HL,(LINEAT)     ; Get line of error
 632: 1913+10	0425  11FEFF  	        LD      DE,-2           ; Cold start error if -2
 633: 1923+4	0428  7C      	        LD      A,H             ; See if cold start error
 634: 1927+4	0429  92      	        SUB     D               ; Compare with D
 635: 1931+7+5	042A  2002    	        JR      NZ,$+4          ; Different - Exit
 636: 1938+4	042C  7D      	        LD      A,L             ; Get L
 637: 1942+4	042D  93      	        SUB     E               ; Compare with E
 638: 1946+10	042E  CA5A00  	        JP      Z,CSTART        ; Cold start error - Restart
 639: 1956+4	0431  7C      	        LD      A,H             ; Was it a direct error?
 640: 1960+4	0432  A5      	        AND     L               ; Line = -1 if direct error
 641: 1964+4	0433  3C      	        INC     A
 642: 1968+10+7	0434  C4C718  	        CALL    NZ,LINEIN       ; No - output line of error
 643:     -	0437  3E      	        .BYTE   3EH             ; Skip "POP BC"
 644: 1978+10	0438  C1      	POPNOK: POP     BC              ; Drop address in input buffer
 645:				
 646: 1988+4	0439  AF      	PRNTOK: XOR     A               ; Output "Ok" and get command
 647: 1992+13	043A  32281E  	        LD      (CTLOFG),A      ; Enable output
 648: 2005+17	043D  CD0C0B  	        CALL    STTLIN          ; Start new line
 649: 2022+10	0440  218203  	        LD      HL,OKMSG        ; "Ok" message
 650: 2032+17	0443  CD0212  	        CALL    PRS             ; Output "Ok"
 651: 2049+10	0446  21FFFF  	GETCMD: LD      HL,-1           ; Flag direct mode
 652: 2059+16	0449  22361E  	        LD      (LINEAT),HL     ; Save as current line
 653: 2075+17	044C  CD311E  	        CALL    RINPUT          ; Get an input line
 654: 2092+10	044F  DA4604  	        JP      C,GETCMD        ; Get line again if break
 655: 2102+17	0452  CD4F08  	        CALL    GETCHR          ; Get first character
 656: 2119+4	0455  3C      	        INC     A               ; Test if end of line
 657: 2123+4	0456  3D      	        DEC     A               ; Without affecting Carry
 658: 2127+10	0457  CA4604  	        JP      Z,GETCMD        ; Nothing entered - Get another
 659: 2137+11	045A  F5      	        PUSH    AF              ; Save Carry status
 660: 2148+17	045B  CD1B09  	        CALL    ATOH            ; Get line number into DE
 661: 2165+11	045E  D5      	        PUSH    DE              ; Save line number
 662: 2176+17	045F  CD5005  	        CALL    CRUNCH          ; Tokenise rest of line
 663: 2193+4	0462  47      	        LD      B,A             ; Length of tokenised line
 664: 2197+10	0463  D1      	        POP     DE              ; Restore line number
 665: 2207+10	0464  F1      	        POP     AF              ; Restore Carry
 666: 2217+10	0465  D22F08  	        JP      NC,EXCUTE       ; No line number - Direct mode
 667: 2227+11	0468  D5      	        PUSH    DE              ; Save line number
 668: 2238+11	0469  C5      	        PUSH    BC              ; Save length of tokenised line
 669: 2249+4	046A  AF      	        XOR     A
 670: 2253+13	046B  32A61E  	        LD      (LSTBIN),A      ; Clear last byte input
 671: 2266+17	046E  CD4F08  	        CALL    GETCHR          ; Get next character
 672: 2283+4	0471  B7      	        OR      A               ; Set flags
 673: 2287+11	0472  F5      	        PUSH    AF              ; And save them
 674: 2298+17	0473  CDDD04  	        CALL    SRCHLN          ; Search for line number in DE
 675: 2315+10	0476  DA7F04  	        JP      C,LINFND        ; Jump if line found
 676: 2325+10	0479  F1      	        POP     AF              ; Get status
 677: 2335+11	047A  F5      	        PUSH    AF              ; And re-save
 678: 2346+10	047B  CAC609  	        JP      Z,ULERR         ; Nothing after number - Error
 679: 2356+4	047E  B7      	        OR      A               ; Clear Carry
 680: 2360+11	047F  C5      	LINFND: PUSH    BC              ; Save address of line in prog
 681: 2371+10	0480  D29904  	        JP      NC,INEWLN       ; Line not found - Insert new
 682: 2381+4	0483  EB      	        EX      DE,HL           ; Next line address in DE
 683: 2385+16	0484  2AB01E  	        LD      HL,(PROGND)     ; End of program
 684: 2401+7	0487  1A      	SFTPRG: LD      A,(DE)          ; Shift rest of program down
 685: 2408+7	0488  02      	        LD      (BC),A
 686: 2415+6	0489  03      	        INC     BC              ; Next destination
 687: 2421+6	048A  13      	        INC     DE              ; Next source
 688: 2427+4	048B  7C      	        LD      A,H             ; All done?
 689: 2431+4	048C  92      	        SUB     D               ; Compare with D
 690: 2435+7+5	048D  2002    	        JR      NZ,$+4          ; Different - Exit
 691: 2442+4	048F  7D      	        LD      A,L             ; Get L
 692: 2446+4	0490  93      	        SUB     E               ; Compare with E
 693: 2450+10	0491  C28704  	        JP      NZ,SFTPRG       ; More to do
 694: 2460+4	0494  60      	        LD      H,B             ; HL - New end of program
 695: 2464+4	0495  69      	        LD      L,C
 696: 2468+16	0496  22B01E  	        LD      (PROGND),HL     ; Update end of program
 697:				
 698: 2484+10	0499  D1      	INEWLN: POP     DE              ; Get address of line,
 699: 2494+10	049A  F1      	        POP     AF              ; Get status
 700: 2504+10	049B  CAC004  	        JP      Z,SETPTR        ; No text - Set up pointers
 701: 2514+16	049E  2AB01E  	        LD      HL,(PROGND)     ; Get end of program
 702: 2530+19	04A1  E3      	        EX      (SP),HL         ; Get length of input line
 703: 2549+10	04A2  C1      	        POP     BC              ; End of program to BC
 704: 2559+11	04A3  09      	        ADD     HL,BC           ; Find new end
 705: 2570+11	04A4  E5      	        PUSH    HL              ; Save new end
 706: 2581+17	04A5  CDB403  	        CALL    MOVUP           ; Make space for line
 707: 2598+10	04A8  E1      	        POP     HL              ; Restore new end
 708: 2608+16	04A9  22B01E  	        LD      (PROGND),HL     ; Update end of program pointer
 709: 2624+4	04AC  EB      	        EX      DE,HL           ; Get line to move up in HL
 710: 2628+7	04AD  74      	        LD      (HL),H          ; Save MSB
 711: 2635+10	04AE  D1      	        POP     DE              ; Get new line number
 712: 2645+6	04AF  23      	        INC     HL              ; Skip pointer
 713: 2651+6	04B0  23      	        INC     HL
 714: 2657+7	04B1  73      	        LD      (HL),E          ; Save LSB of line number
 715: 2664+6	04B2  23      	        INC     HL
 716: 2670+7	04B3  72      	        LD      (HL),D          ; Save MSB of line number
 717: 2677+6	04B4  23      	        INC     HL              ; To first byte in line
 718: 2683+10	04B5  113B1E  	        LD      DE,BUFFER       ; Copy buffer to program
 719: 2693+7	04B8  1A      	MOVBUF: LD      A,(DE)          ; Get source
 720: 2700+7	04B9  77      	        LD      (HL),A          ; Save destinations
 721: 2707+6	04BA  23      	        INC     HL              ; Next source
 722: 2713+6	04BB  13      	        INC     DE              ; Next destination
 723: 2719+4	04BC  B7      	        OR      A               ; Done?
 724: 2723+10	04BD  C2B804  	        JP      NZ,MOVBUF       ; No - Repeat
 725: 2733+17	04C0  CD0C05  	SETPTR: CALL    RUNFST          ; Set line pointers
 726: 2750+6	04C3  23      	        INC     HL              ; To LSB of pointer
 727: 2756+4	04C4  EB      	        EX      DE,HL           ; Address to DE
 728: 2760+4	04C5  62      	PTRLP:  LD      H,D             ; Address to HL
 729: 2764+4	04C6  6B      	        LD      L,E
 730: 2768+7	04C7  7E      	        LD      A,(HL)          ; Get LSB of pointer
 731: 2775+6	04C8  23      	        INC     HL              ; To MSB of pointer
 732: 2781+7	04C9  B6      	        OR      (HL)            ; Compare with MSB pointer
 733: 2788+10	04CA  CA4604  	        JP      Z,GETCMD        ; Get command line if end
 734: 2798+6	04CD  23      	        INC     HL              ; To LSB of line number
 735: 2804+6	04CE  23      	        INC     HL              ; Skip line number
 736: 2810+6	04CF  23      	        INC     HL              ; Point to first byte in line
 737: 2816+4	04D0  AF      	        XOR     A               ; Looking for 00 byte
 738: 2820+7	04D1  BE      	FNDEND: CP      (HL)            ; Found end of line?
 739: 2827+6	04D2  23      	        INC     HL              ; Move to next byte
 740: 2833+10	04D3  C2D104  	        JP      NZ,FNDEND       ; No - Keep looking
 741: 2843+4	04D6  EB      	        EX      DE,HL           ; Next line address to HL
 742: 2847+7	04D7  73      	        LD      (HL),E          ; Save LSB of pointer
 743: 2854+6	04D8  23      	        INC     HL
 744: 2860+7	04D9  72      	        LD      (HL),D          ; Save MSB of pointer
 745: 2867+10	04DA  C3C504  	        JP      PTRLP           ; Do next line
 746:				
 747: 2877+16	04DD  2A381E  	SRCHLN: LD      HL,(BASTXT)     ; Start of program text
 748: 2893+4	04E0  44      	SRCHLP: LD      B,H             ; BC = Address to look at
 749: 2897+4	04E1  4D      	        LD      C,L
 750: 2901+7	04E2  7E      	        LD      A,(HL)          ; Get address of next line
 751: 2908+6	04E3  23      	        INC     HL
 752: 2914+7	04E4  B6      	        OR      (HL)            ; End of program found?
 753: 2921+6	04E5  2B      	        DEC     HL
 754: 2927+5+6	04E6  C8      	        RET     Z               ; Yes - Line not found
 755: 2932+6	04E7  23      	        INC     HL
 756: 2938+6	04E8  23      	        INC     HL
 757: 2944+7	04E9  7E      	        LD      A,(HL)          ; Get LSB of line number
 758: 2951+6	04EA  23      	        INC     HL
 759: 2957+7	04EB  66      	        LD      H,(HL)          ; Get MSB of line number
 760: 2964+4	04EC  6F      	        LD      L,A
 761: 2968+4	04ED  7C      	        LD      A,H             ; Compare with line in DE
 762: 2972+4	04EE  92      	        SUB     D               ; Compare with D
 763: 2976+7+5	04EF  2002    	        JR      NZ,$+4          ; Different - Exit
 764: 2983+4	04F1  7D      	        LD      A,L             ; Get L
 765: 2987+4	04F2  93      	        SUB     E               ; Compare with E
 766: 2991+4	04F3  60      	        LD      H,B             ; HL = Start of this line
 767: 2995+4	04F4  69      	        LD      L,C
 768: 2999+7	04F5  7E      	        LD      A,(HL)          ; Get LSB of next line address
 769: 3006+6	04F6  23      	        INC     HL
 770: 3012+7	04F7  66      	        LD      H,(HL)          ; Get MSB of next line address
 771: 3019+4	04F8  6F      	        LD      L,A             ; Next line to HL
 772: 3023+4	04F9  3F      	        CCF
 773: 3027+5+6	04FA  C8      	        RET     Z               ; Lines found - Exit
 774: 3032+4	04FB  3F      	        CCF
 775: 3036+5+6	04FC  D0      	        RET     NC              ; Line not found,at line after
 776: 3041+10	04FD  C3E004  	        JP      SRCHLP          ; Keep looking
 777:				
 778: 3051+5+6	0500  C0      	NEW:    RET     NZ              ; Return if any more on line
 779: 3056+16	0501  2A381E  	CLRPTR: LD      HL,(BASTXT)     ; Point to start of program
 780: 3072+4	0504  AF      	        XOR     A               ; Set program area to empty
 781: 3076+7	0505  77      	        LD      (HL),A          ; Save LSB = 00
 782: 3083+6	0506  23      	        INC     HL
 783: 3089+7	0507  77      	        LD      (HL),A          ; Save MSB = 00
 784: 3096+6	0508  23      	        INC     HL
 785: 3102+16	0509  22B01E  	        LD      (PROGND),HL     ; Set program end
 786:				
 787: 3118+16	050C  2A381E  	RUNFST: LD      HL,(BASTXT)     ; Clear all variables
 788: 3134+6	050F  2B      	        DEC     HL
 789:				
 790: 3140+16	0510  22A81E  	INTVAR: LD      (BRKLIN),HL     ; Initialise RUN variables
 791: 3156+16	0513  2A891E  	        LD      HL,(LSTRAM)     ; Get end of RAM
 792: 3172+16	0516  229D1E  	        LD      (STRBOT),HL     ; Clear string space
 793: 3188+4	0519  AF      	        XOR     A
 794: 3192+17	051A  CD5E08  	        CALL    RESTOR          ; Reset DATA pointers
 795: 3209+16	051D  2AB01E  	        LD      HL,(PROGND)     ; Get end of program
 796: 3225+16	0520  22B21E  	        LD      (VAREND),HL     ; Clear variables
 797: 3241+16	0523  22B41E  	        LD      (ARREND),HL     ; Clear arrays
 798:				
 799: 3257+10	0526  C1      	CLREG:  POP     BC              ; Save return address
 800: 3267+16	0527  2A341E  	        LD      HL,(STRSPC)     ; Get end of working RAM
 801: 3283+6	052A  F9      	        LD      SP,HL           ; Set stack
 802: 3289+10	052B  218D1E  	        LD      HL,TMSTPL       ; Temporary string pool
 803: 3299+16	052E  228B1E  	        LD      (TMSTPT),HL     ; Reset temporary string ptr
 804: 3315+4	0531  AF      	        XOR     A               ; A = 00
 805: 3319+4	0532  6F      	        LD      L,A             ; HL = 0000
 806: 3323+4	0533  67      	        LD      H,A
 807: 3327+16	0534  22AE1E  	        LD      (CONTAD),HL     ; No CONTinue
 808: 3343+13	0537  32A51E  	        LD      (FORFLG),A      ; Clear FOR flag
 809: 3356+16	053A  22B81E  	        LD      (FNRGNM),HL     ; Clear FN argument
 810: 3372+11	053D  E5      	        PUSH    HL              ; HL = 0000
 811: 3383+11	053E  C5      	        PUSH    BC              ; Put back return
 812: 3394+16	053F  2AA81E  	DOAGN:  LD      HL,(BRKLIN)     ; Get address of code to RUN
 813: 3410+10	0542  C9      	        RET                     ; Return to execution driver
 814:				
 815: 3420+7	0543  3E3F    	PROMPT: LD      A,'?'           ; '?'
 816: 3427+17	0545  CDC706  	        CALL    OUTC            ; Output character
 817: 3444+7	0548  3E20    	        LD      A,' '           ; Space
 818: 3451+17	054A  CDC706  	        CALL    OUTC            ; Output character
 819: 3468+10	054D  C3311E  	        JP      RINPUT          ; Get input line
 820:				
 821: 3478+4	0550  AF      	CRUNCH: XOR     A               ; Tokenise line @ HL to BUFFER
 822: 3482+13	0551  32881E  	        LD      (DATFLG),A      ; Reset literal flag
 823: 3495+7	0554  0E05    	        LD      C,2+3           ; 2 byte number and 3 nulls
 824: 3502+10	0556  113B1E  	        LD      DE,BUFFER       ; Start of input buffer
 825: 3512+7	0559  7E      	CRNCLP: LD      A,(HL)          ; Get byte
 826: 3519+7	055A  FE20    	        CP      ' '             ; Is it a space?
 827: 3526+10	055C  CAD805  	        JP      Z,MOVDIR        ; Yes - Copy direct
 828: 3536+4	055F  47      	        LD      B,A             ; Save character
 829: 3540+7	0560  FE22    	        CP      '"'             ; Is it a quote?
 830: 3547+10	0562  CAF805  	        JP      Z,CPYLIT        ; Yes - Copy literal string
 831: 3557+4	0565  B7      	        OR      A               ; Is it end of buffer?
 832: 3561+10	0566  CAFF05  	        JP      Z,ENDBUF        ; Yes - End buffer
 833: 3571+13	0569  3A881E  	        LD      A,(DATFLG)      ; Get data type
 834: 3584+4	056C  B7      	        OR      A               ; Literal?
 835: 3588+7	056D  7E      	        LD      A,(HL)          ; Get byte to copy
 836: 3595+10	056E  C2D805  	        JP      NZ,MOVDIR       ; Literal - Copy direct
 837: 3605+7	0571  FE3F    	        CP      '?'             ; Is it '?' short for PRINT
 838: 3612+7	0573  3E9C    	        LD      A,ZPRINT        ; "PRINT" token
 839: 3619+10	0575  CAD805  	        JP      Z,MOVDIR        ; Yes - replace it
 840: 3629+7	0578  7E      	        LD      A,(HL)          ; Get byte again
 841: 3636+7	0579  FE30    	        CP      '0'             ; Is it less than '0'
 842: 3643+10	057B  DA8305  	        JP      C,FNDWRD        ; Yes - Look for reserved words
 843: 3653+7	057E  FE3C    	        CP      60              ; ';'+1 Is it "0123456789:;" ?
 844: 3660+10	0580  DAD805  	        JP      C,MOVDIR        ; Yes - copy it direct
 845: 3670+11	0583  D5      	FNDWRD: PUSH    DE              ; Look for reserved words
 846: 3681+10	0584  118E01  	        LD      DE,WORDS-1      ; Point to table
 847: 3691+11	0587  C5      	        PUSH    BC              ; Save count
 848: 3702+10	0588  01D405  	        LD      BC,RETNAD       ; Where to return to
 849: 3712+11	058B  C5      	        PUSH    BC              ; Save return address
 850: 3723+7	058C  067F    	        LD      B,ZEND-1        ; First token value -1
 851: 3730+7	058E  7E      	        LD      A,(HL)          ; Get byte
 852: 3737+7	058F  FE61    	        CP      'a'             ; Less than 'a' ?
 853: 3744+10	0591  DA9C05  	        JP      C,SEARCH        ; Yes - search for words
 854: 3754+7	0594  FE7B    	        CP      'z'+1           ; Greater than 'z' ?
 855: 3761+10	0596  D29C05  	        JP      NC,SEARCH       ; Yes - search for words
 856: 3771+7	0599  E65F    	        AND     01011111B       ; Force upper case
 857: 3778+7	059B  77      	        LD      (HL),A          ; Replace byte
 858: 3785+7	059C  4E      	SEARCH: LD      C,(HL)          ; Search for a word
 859: 3792+4	059D  EB      	        EX      DE,HL
 860: 3796+6	059E  23      	GETNXT: INC     HL              ; Get next reserved word
 861: 3802+7	059F  B6      	        OR      (HL)            ; Start of word?
 862: 3809+10	05A0  F29E05  	        JP      P,GETNXT        ; No - move on
 863: 3819+4	05A3  04      	        INC     B               ; Increment token value
 864: 3823+7	05A4  7E      	        LD      A,(HL)          ; Get byte from table
 865: 3830+7	05A5  E67F    	        AND     01111111B       ; Strip bit 7
 866: 3837+5+6	05A7  C8      	        RET     Z               ; Return if end of list
 867: 3842+4	05A8  B9      	        CP      C               ; Same character as in buffer?
 868: 3846+10	05A9  C29E05  	        JP      NZ,GETNXT       ; No - get next word
 869: 3856+4	05AC  EB      	        EX      DE,HL
 870: 3860+11	05AD  E5      	        PUSH    HL              ; Save start of word
 871:				
 872: 3871+6	05AE  13      	NXTBYT: INC     DE              ; Look through rest of word
 873: 3877+7	05AF  1A      	        LD      A,(DE)          ; Get byte from table
 874: 3884+4	05B0  B7      	        OR      A               ; End of word ?
 875: 3888+10	05B1  FAD005  	        JP      M,MATCH         ; Yes - Match found
 876: 3898+4	05B4  4F      	        LD      C,A             ; Save it
 877: 3902+4	05B5  78      	        LD      A,B             ; Get token value
 878: 3906+7	05B6  FE88    	        CP      ZGOTO           ; Is it "GOTO" token ?
 879: 3913+10	05B8  C2BF05  	        JP      NZ,NOSPC        ; No - Don't allow spaces
 880: 3923+17	05BB  CD4F08  	        CALL    GETCHR          ; Get next character
 881: 3940+6	05BE  2B      	        DEC     HL              ; Cancel increment from GETCHR
 882: 3946+6	05BF  23      	NOSPC:  INC     HL              ; Next byte
 883: 3952+7	05C0  7E      	        LD      A,(HL)          ; Get byte
 884: 3959+7	05C1  FE61    	        CP      'a'             ; Less than 'a' ?
 885: 3966+10	05C3  DAC805  	        JP      C,NOCHNG        ; Yes - don't change
 886: 3976+7	05C6  E65F    	        AND     01011111B       ; Make upper case
 887: 3983+4	05C8  B9      	NOCHNG: CP      C               ; Same as in buffer ?
 888: 3987+10	05C9  CAAE05  	        JP      Z,NXTBYT        ; Yes - keep testing
 889: 3997+10	05CC  E1      	        POP     HL              ; Get back start of word
 890: 4007+10	05CD  C39C05  	        JP      SEARCH          ; Look at next word
 891:				
 892: 4017+4	05D0  48      	MATCH:  LD      C,B             ; Word found - Save token value
 893: 4021+10	05D1  F1      	        POP     AF              ; Throw away return
 894: 4031+4	05D2  EB      	        EX      DE,HL
 895: 4035+10	05D3  C9      	        RET                     ; Return to "RETNAD"
 896: 4045+4	05D4  EB      	RETNAD: EX      DE,HL           ; Get address in string
 897: 4049+4	05D5  79      	        LD      A,C             ; Get token value
 898: 4053+10	05D6  C1      	        POP     BC              ; Restore buffer length
 899: 4063+10	05D7  D1      	        POP     DE              ; Get destination address
 900: 4073+6	05D8  23      	MOVDIR: INC     HL              ; Next source in buffer
 901: 4079+7	05D9  12      	        LD      (DE),A          ; Put byte in buffer
 902: 4086+6	05DA  13      	        INC     DE              ; Move up buffer
 903: 4092+4	05DB  0C      	        INC     C               ; Increment length of buffer
 904: 4096+7	05DC  D63A    	        SUB     ':'             ; End of statement?
 905: 4103+10	05DE  CAE605  	        JP      Z,SETLIT        ; Jump if multi-statement line
 906: 4113+7	05E1  FE49    	        CP      ZDATA-3AH       ; Is it DATA statement ?
 907: 4120+10	05E3  C2E905  	        JP      NZ,TSTREM       ; No - see if REM
 908: 4130+13	05E6  32881E  	SETLIT: LD      (DATFLG),A      ; Set literal flag
 909: 4143+7	05E9  D654    	TSTREM: SUB     ZREM-3AH        ; Is it REM?
 910: 4150+10	05EB  C25905  	        JP      NZ,CRNCLP       ; No - Leave flag
 911: 4160+4	05EE  47      	        LD      B,A             ; Copy rest of buffer
 912: 4164+7	05EF  7E      	NXTCHR: LD      A,(HL)          ; Get byte
 913: 4171+4	05F0  B7      	        OR      A               ; End of line ?
 914: 4175+10	05F1  CAFF05  	        JP      Z,ENDBUF        ; Yes - Terminate buffer
 915: 4185+4	05F4  B8      	        CP      B               ; End of statement ?
 916: 4189+10	05F5  CAD805  	        JP      Z,MOVDIR        ; Yes - Get next one
 917: 4199+6	05F8  23      	CPYLIT: INC     HL              ; Move up source string
 918: 4205+7	05F9  12      	        LD      (DE),A          ; Save in destination
 919: 4212+4	05FA  0C      	        INC     C               ; Increment length
 920: 4216+6	05FB  13      	        INC     DE              ; Move up destination
 921: 4222+10	05FC  C3EF05  	        JP      NXTCHR          ; Repeat
 922:				
 923: 4232+10	05FF  213A1E  	ENDBUF: LD      HL,BUFFER-1     ; Point to start of buffer
 924: 4242+7	0602  12      	        LD      (DE),A          ; Mark end of buffer (A = 00)
 925: 4249+6	0603  13      	        INC     DE
 926: 4255+7	0604  12      	        LD      (DE),A          ; A = 00
 927: 4262+6	0605  13      	        INC     DE
 928: 4268+7	0606  12      	        LD      (DE),A          ; A = 00
 929: 4275+10	0607  C9      	        RET
 930:				
 931: 4285+13	0608  3A271E  	DODEL:  LD      A,(NULFLG)      ; Get null flag status
 932: 4298+4	060B  B7      	        OR      A               ; Is it zero?
 933: 4302+7	060C  3E00    	        LD      A,0             ; Zero A - Leave flags
 934: 4309+13	060E  32271E  	        LD      (NULFLG),A      ; Zero null flag
 935: 4322+10	0611  C21C06  	        JP      NZ,ECHDEL       ; Set - Echo it
 936: 4332+4	0614  05      	        DEC     B               ; Decrement length
 937: 4336+10	0615  CA311E  	        JP      Z,RINPUT        ; Get line again if empty
 938: 4346+17	0618  CDC706  	        CALL    OUTC            ; Output null character
 939:     -	061B  3E      	        .BYTE   3EH             ; Skip "DEC B"
 940: 4363+4	061C  05      	ECHDEL: DEC     B               ; Count bytes in buffer
 941: 4367+6	061D  2B      	        DEC     HL              ; Back space buffer
 942: 4373+10	061E  CA3006  	        JP      Z,OTKLN         ; No buffer - Try again
 943: 4383+7	0621  7E      	        LD      A,(HL)          ; Get deleted byte
 944: 4390+17	0622  CDC706  	        CALL    OUTC            ; Echo it
 945: 4407+10	0625  C34206  	        JP      MORINP          ; Get more input
 946:				
 947: 4417+4	0628  05      	DELCHR: DEC     B               ; Count bytes in buffer
 948: 4421+6	0629  2B      	        DEC     HL              ; Back space buffer
 949: 4427+17	062A  CDC706  	        CALL    OUTC            ; Output character in A
 950: 4444+10	062D  C24206  	        JP      NZ,MORINP       ; Not end - Get more
 951: 4454+17	0630  CDC706  	OTKLN:  CALL    OUTC            ; Output character in A
 952: 4471+17	0633  CD190B  	KILIN:  CALL    PRNTCRLF        ; Output CRLF
 953: 4488+10	0636  C3311E  	        JP      RINPUT          ; Get line again
 954:				
 955: 4498+10	0639  213B1E  	TTYLIN: LD      HL,BUFFER       ; Get a line by character
 956: 4508+7	063C  0601    	        LD      B,1             ; Set buffer as empty
 957: 4515+4	063E  AF      	        XOR     A
 958: 4519+13	063F  32271E  	        LD      (NULFLG),A      ; Clear null flag
 959: 4532+17	0642  CDF506  	MORINP: CALL    CLOTST          ; Get character and test ^O
 960: 4549+4	0645  4F      	        LD      C,A             ; Save character in C
 961: 4553+7	0646  FE7F    	        CP      DEL             ; Delete character?
 962: 4560+10	0648  CA0806  	        JP      Z,DODEL         ; Yes - Process it
 963: 4570+13	064B  3A271E  	        LD      A,(NULFLG)      ; Get null flag
 964: 4583+4	064E  B7      	        OR      A               ; Test null flag status
 965: 4587+10	064F  CA5B06  	        JP      Z,PROCES        ; Reset - Process character
 966: 4597+7	0652  3E00    	        LD      A,0             ; Set a null
 967: 4604+17	0654  CDC706  	        CALL    OUTC            ; Output null
 968: 4621+4	0657  AF      	        XOR     A               ; Clear A
 969: 4625+13	0658  32271E  	        LD      (NULFLG),A      ; Reset null flag
 970: 4638+4	065B  79      	PROCES: LD      A,C             ; Get character
 971: 4642+7	065C  FE07    	        CP      CTRLG           ; Bell?
 972: 4649+10	065E  CA9F06  	        JP      Z,PUTCTL        ; Yes - Save it
 973: 4659+7	0661  FE03    	        CP      CTRLC           ; Is it control "C"?
 974: 4666+10+7	0663  CC190B  	        CALL    Z,PRNTCRLF      ; Yes - Output CRLF
 975: 4676+4	0666  37      	        SCF                     ; Flag break
 976: 4680+5+6	0667  C8      	        RET     Z               ; Return if control "C"
 977: 4685+7	0668  FE0D    	        CP      CR              ; Is it enter?
 978: 4692+10	066A  CA140B  	        JP      Z,ENDINP        ; Yes - Terminate input
 979: 4702+7	066D  FE15    	        CP      CTRLU           ; Is it control "U"?
 980: 4709+10	066F  CA3306  	        JP      Z,KILIN         ; Yes - Get another line
 981: 4719+7	0672  FE40    	        CP      '@'             ; Is it "kill line"?
 982: 4726+10	0674  CA3006  	        JP      Z,OTKLN         ; Yes - Kill line
 983: 4736+7	0677  FE5F    	        CP      '_'             ; Is it delete?
 984: 4743+10	0679  CA2806  	        JP      Z,DELCHR        ; Yes - Delete character
 985: 4753+7	067C  FE08    	        CP      BKSP            ; Is it backspace?
 986: 4760+10	067E  CA2806  	        JP      Z,DELCHR        ; Yes - Delete character
 987: 4770+7	0681  FE12    	        CP      CTRLR           ; Is it control "R"?
 988: 4777+10	0683  C29A06  	        JP      NZ,PUTBUF       ; No - Put in buffer
 989: 4787+11	0686  C5      	        PUSH    BC              ; Save buffer length
 990: 4798+11	0687  D5      	        PUSH    DE              ; Save DE
 991: 4809+11	0688  E5      	        PUSH    HL              ; Save buffer address
 992: 4820+10	0689  3600    	        LD      (HL),0          ; Mark end of buffer
 993: 4830+17	068B  CDEF06  	        CALL    OUTNCR          ; Output and do CRLF
 994: 4847+10	068E  213B1E  	        LD      HL,BUFFER       ; Point to buffer start
 995: 4857+17	0691  CD0212  	        CALL    PRS             ; Output buffer
 996: 4874+10	0694  E1      	        POP     HL              ; Restore buffer address
 997: 4884+10	0695  D1      	        POP     DE              ; Restore DE
 998: 4894+10	0696  C1      	        POP     BC              ; Restore buffer length
 999: 4904+10	0697  C34206  	        JP      MORINP          ; Get another character
1000:				
1001: 4914+7	069A  FE20    	PUTBUF: CP      ' '             ; Is it a control code?
1002: 4921+10	069C  DA4206  	        JP      C,MORINP        ; Yes - Ignore
1003: 4931+4	069F  78      	PUTCTL: LD      A,B             ; Get number of bytes in buffer
1004: 4935+7	06A0  FE49    	        CP      72+1            ; Test for line overflow
1005: 4942+7	06A2  3E07    	        LD      A,CTRLG         ; Set a bell
1006: 4949+10	06A4  D2B406  	        JP      NC,OUTNBS       ; Ring bell if buffer full
1007: 4959+4	06A7  79      	        LD      A,C             ; Get character
1008: 4963+7	06A8  71      	        LD      (HL),C          ; Save in buffer
1009: 4970+13	06A9  32A61E  	        LD      (LSTBIN),A      ; Save last input byte
1010: 4983+6	06AC  23      	        INC     HL              ; Move up buffer
1011: 4989+4	06AD  04      	        INC     B               ; Increment length
1012: 4993+17	06AE  CDC706  	OUTIT:  CALL    OUTC            ; Output the character entered
1013: 5010+10	06B1  C34206  	        JP      MORINP          ; Get another character
1014:				
1015: 5020+17	06B4  CDC706  	OUTNBS: CALL    OUTC            ; Output bell and back over it
1016: 5037+7	06B7  3E08    	        LD      A,BKSP          ; Set back space
1017: 5044+10	06B9  C3AE06  	        JP      OUTIT           ; Output it and get more
1018:				
1019: 5054+7	06BC  7E      	CHKSYN: LD      A,(HL)          ; Check syntax of character
1020: 5061+19	06BD  E3      	        EX      (SP),HL         ; Address of test byte
1021: 5080+7	06BE  BE      	        CP      (HL)            ; Same as in code string?
1022: 5087+6	06BF  23      	        INC     HL              ; Return address
1023: 5093+19	06C0  E3      	        EX      (SP),HL         ; Put it back
1024: 5112+10	06C1  CA4F08  	        JP      Z,GETCHR        ; Yes - Get next character
1025: 5122+10	06C4  C3EB03  	        JP      SNERR           ; Different - ?SN Error
1026:				
1027: 5132+11	06C7  F5      	OUTC:   PUSH    AF              ; Save character
1028: 5143+13	06C8  3A281E  	        LD      A,(CTLOFG)      ; Get control "O" flag
1029: 5156+4	06CB  B7      	        OR      A               ; Is it set?
1030: 5160+10	06CC  C23A12  	        JP      NZ,POPAF        ; Yes - don't output
1031: 5170+10	06CF  F1      	        POP     AF              ; Restore character
1032: 5180+11	06D0  C5      	        PUSH    BC              ; Save buffer length
1033: 5191+11	06D1  F5      	        PUSH    AF              ; Save character
1034: 5202+7	06D2  FE20    	        CP      ' '             ; Is it a control code?
1035: 5209+10	06D4  DAEB06  	        JP      C,DINPOS        ; Yes - Don't INC POS(X)
1036: 5219+13	06D7  3A251E  	        LD      A,(LWIDTH)      ; Get line width
1037: 5232+4	06DA  47      	        LD      B,A             ; To B
1038: 5236+13	06DB  3A851E  	        LD      A,(CURPOS)      ; Get cursor position
1039: 5249+4	06DE  04      	        INC     B               ; Width 255?
1040: 5253+10	06DF  CAE706  	        JP      Z,INCLEN        ; Yes - No width limit
1041: 5263+4	06E2  05      	        DEC     B               ; Restore width
1042: 5267+4	06E3  B8      	        CP      B               ; At end of line?
1043: 5271+10+7	06E4  CC190B  	        CALL    Z,PRNTCRLF      ; Yes - output CRLF
1044: 5281+4	06E7  3C      	INCLEN: INC     A               ; Move on one character
1045: 5285+13	06E8  32851E  	        LD      (CURPOS),A      ; Save new position
1046: 5298+10	06EB  F1      	DINPOS: POP     AF              ; Restore character
1047: 5308+10	06EC  C1      	        POP     BC              ; Restore buffer length
1048: 5318+11	06ED  CF      	        RST     08H             ; Send it
1049: 5329+10	06EE  C9      	        RET
1050:				
1051: 5339+17	06EF  CDC706  	OUTNCR: CALL    OUTC            ; Output character in A
1052: 5356+10	06F2  C3190B  	        JP      PRNTCRLF        ; Output CRLF
1053:				
1054: 5366+11	06F5  D7      	CLOTST: RST     10H             ; Get input character
1055: 5377+7	06F6  E67F    	        AND     01111111B       ; Strip bit 7
1056: 5384+7	06F8  FE0F    	        CP      CTRLO           ; Is it control "O"?
1057: 5391+5+6	06FA  C0      	        RET     NZ              ; No don't flip flag
1058: 5396+13	06FB  3A281E  	        LD      A,(CTLOFG)      ; Get flag
1059: 5409+4	06FE  2F      	        CPL                     ; Flip it
1060: 5413+13	06FF  32281E  	        LD      (CTLOFG),A      ; Put it back
1061: 5426+4	0702  AF      	        XOR     A               ; Null character
1062: 5430+10	0703  C9      	        RET
1063:				
1064: 5440+17	0704  CD1B09  	LIST:   CALL    ATOH            ; ASCII number to DE
1065: 5457+5+6	0707  C0      	        RET     NZ              ; Return if anything extra
1066: 5462+10	0708  C1      	        POP     BC              ; Rubbish - Not needed
1067: 5472+17	0709  CDDD04  	        CALL    SRCHLN          ; Search for line number in DE
1068: 5489+11	070C  C5      	        PUSH    BC              ; Save address of line
1069: 5500+17	070D  CD5A07  	        CALL    SETLIN          ; Set up lines counter
1070: 5517+10	0710  E1      	LISTLP: POP     HL              ; Restore address of line
1071: 5527+7	0711  4E      	        LD      C,(HL)          ; Get LSB of next line
1072: 5534+6	0712  23      	        INC     HL
1073: 5540+7	0713  46      	        LD      B,(HL)          ; Get MSB of next line
1074: 5547+6	0714  23      	        INC     HL
1075: 5553+4	0715  78      	        LD      A,B             ; BC = 0 (End of program)?
1076: 5557+4	0716  B1      	        OR      C
1077: 5561+10	0717  CA3904  	        JP      Z,PRNTOK        ; Yes - Go to command mode
1078: 5571+17	071A  CD6307  	        CALL    COUNT           ; Count lines
1079: 5588+17	071D  CD7908  	        CALL    TSTBRK          ; Test for break key
1080: 5605+11	0720  C5      	        PUSH    BC              ; Save address of next line
1081: 5616+17	0721  CD190B  	        CALL    PRNTCRLF        ; Output CRLF
1082: 5633+7	0724  5E      	        LD      E,(HL)          ; Get LSB of line number
1083: 5640+6	0725  23      	        INC     HL
1084: 5646+7	0726  56      	        LD      D,(HL)          ; Get MSB of line number
1085: 5653+6	0727  23      	        INC     HL
1086: 5659+11	0728  E5      	        PUSH    HL              ; Save address of line start
1087: 5670+4	0729  EB      	        EX      DE,HL           ; Line number to HL
1088: 5674+17	072A  CDCF18  	        CALL    PRNTHL          ; Output line number in decimal
1089: 5691+7	072D  3E20    	        LD      A,' '           ; Space after line number
1090: 5698+10	072F  E1      	        POP     HL              ; Restore start of line address
1091: 5708+17	0730  CDC706  	LSTLP2: CALL    OUTC            ; Output character in A
1092: 5725+7	0733  7E      	LSTLP3: LD      A,(HL)          ; Get next byte in line
1093: 5732+4	0734  B7      	        OR      A               ; End of line?
1094: 5736+6	0735  23      	        INC     HL              ; To next byte in line
1095: 5742+10	0736  CA1007  	        JP      Z,LISTLP        ; Yes - get next line
1096: 5752+10	0739  F23007  	        JP      P,LSTLP2        ; No token - output it
1097: 5762+7	073C  D67F    	        SUB     ZEND-1          ; Find and output word
1098: 5769+4	073E  4F      	        LD      C,A             ; Token offset+1 to C
1099: 5773+10	073F  118F01  	        LD      DE,WORDS        ; Reserved word list
1100: 5783+7	0742  1A      	FNDTOK: LD      A,(DE)          ; Get character in list
1101: 5790+6	0743  13      	        INC     DE              ; Move on to next
1102: 5796+4	0744  B7      	        OR      A               ; Is it start of word?
1103: 5800+10	0745  F24207  	        JP      P,FNDTOK        ; No - Keep looking for word
1104: 5810+4	0748  0D      	        DEC     C               ; Count words
1105: 5814+10	0749  C24207  	        JP      NZ,FNDTOK       ; Not there - keep looking
1106: 5824+7	074C  E67F    	OUTWRD: AND     01111111B       ; Strip bit 7
1107: 5831+17	074E  CDC706  	        CALL    OUTC            ; Output first character
1108: 5848+7	0751  1A      	        LD      A,(DE)          ; Get next character
1109: 5855+6	0752  13      	        INC     DE              ; Move on to next
1110: 5861+4	0753  B7      	        OR      A               ; Is it end of word?
1111: 5865+10	0754  F24C07  	        JP      P,OUTWRD        ; No - output the rest
1112: 5875+10	0757  C33307  	        JP      LSTLP3          ; Next byte in line
1113:				
1114: 5885+11	075A  E5      	SETLIN: PUSH    HL              ; Set up LINES counter
1115: 5896+16	075B  2A2B1E  	        LD      HL,(LINESN)     ; Get LINES number
1116: 5912+16	075E  22291E  	        LD      (LINESC),HL     ; Save in LINES counter
1117: 5928+10	0761  E1      	        POP     HL
1118: 5938+10	0762  C9      	        RET
1119:				
1120: 5948+11	0763  E5      	COUNT:  PUSH    HL              ; Save code string address
1121: 5959+11	0764  D5      	        PUSH    DE
1122: 5970+16	0765  2A291E  	        LD      HL,(LINESC)     ; Get LINES counter
1123: 5986+10	0768  11FFFF  	        LD      DE,-1
1124: 5996+15	076B  ED5A    	        ADC     HL,DE           ; Decrement
1125: 6011+16	076D  22291E  	        LD      (LINESC),HL     ; Put it back
1126: 6027+10	0770  D1      	        POP     DE
1127: 6037+10	0771  E1      	        POP     HL              ; Restore code string address
1128: 6047+5+6	0772  F0      	        RET     P               ; Return if more lines to go
1129: 6052+11	0773  E5      	        PUSH    HL              ; Save code string address
1130: 6063+16	0774  2A2B1E  	        LD      HL,(LINESN)     ; Get LINES number
1131: 6079+16	0777  22291E  	        LD      (LINESC),HL     ; Reset LINES counter
1132: 6095+11	077A  D7      	        RST     10H             ; Get input character
1133: 6106+7	077B  FE03    	        CP      CTRLC           ; Is it control "C"?
1134: 6113+10	077D  CA8407  	        JP      Z,RSLNBK        ; Yes - Reset LINES and break
1135: 6123+10	0780  E1      	        POP     HL              ; Restore code string address
1136: 6133+10	0781  C36307  	        JP      COUNT           ; Keep on counting
1137:				
1138: 6143+16	0784  2A2B1E  	RSLNBK: LD      HL,(LINESN)     ; Get LINES number
1139: 6159+16	0787  22291E  	        LD      (LINESC),HL     ; Reset LINES counter
1140: 6175+10	078A  C3E000  	        JP      BRKRET          ; Go and output "Break"
1141:				
1142: 6185+7	078D  3E64    	FOR:    LD      A,64H           ; Flag "FOR" assignment
1143: 6192+13	078F  32A51E  	        LD      (FORFLG),A      ; Save "FOR" flag
1144: 6205+17	0792  CD070A  	        CALL    LET             ; Set up initial index
1145: 6222+10	0795  C1      	        POP     BC              ; Drop RETurn address
1146: 6232+11	0796  E5      	        PUSH    HL              ; Save code string address
1147: 6243+17	0797  CDF009  	        CALL    DATA            ; Get next statement address
1148: 6260+16	079A  22A11E  	        LD      (LOOPST),HL     ; Save it for start of loop
1149: 6276+10	079D  210200  	        LD      HL,2            ; Offset for "FOR" block
1150: 6286+11	07A0  39      	        ADD     HL,SP           ; Point to it
1151: 6297+17	07A1  CD9203  	FORSLP: CALL    LOKFOR          ; Look for existing "FOR" block
1152: 6314+10	07A4  D1      	        POP     DE              ; Get code string address
1153: 6324+10	07A5  C2C107  	        JP      NZ,FORFND       ; No nesting found
1154: 6334+11	07A8  09      	        ADD     HL,BC           ; Move into "FOR" block
1155: 6345+11	07A9  D5      	        PUSH    DE              ; Save code string address
1156: 6356+6	07AA  2B      	        DEC     HL
1157: 6362+7	07AB  56      	        LD      D,(HL)          ; Get MSB of loop statement
1158: 6369+6	07AC  2B      	        DEC     HL
1159: 6375+7	07AD  5E      	        LD      E,(HL)          ; Get LSB of loop statement
1160: 6382+6	07AE  23      	        INC     HL
1161: 6388+6	07AF  23      	        INC     HL
1162: 6394+11	07B0  E5      	        PUSH    HL              ; Save block address
1163: 6405+16	07B1  2AA11E  	        LD      HL,(LOOPST)     ; Get address of loop statement
1164: 6421+4	07B4  7C      	        LD      A,H             ; Compare the FOR loops
1165: 6425+4	07B5  92      	        SUB     D               ; Compare with D
1166: 6429+10	07B6  C2BB07  	        JP      NZ,$+5          ; Different - Exit
1167: 6439+4	07B9  7D      	        LD      A,L             ; Get L
1168: 6443+4	07BA  93      	        SUB     E               ; Compare with E
1169: 6447+10	07BB  E1      	        POP     HL              ; Restore block address
1170: 6457+10	07BC  C2A107  	        JP      NZ,FORSLP       ; Different FORs - Find another
1171: 6467+10	07BF  D1      	        POP     DE              ; Restore code string address
1172: 6477+6	07C0  F9      	        LD      SP,HL           ; Remove all nested loops
1173:				
1174: 6483+4	07C1  EB      	FORFND: EX      DE,HL           ; Code string address to HL
1175: 6487+7	07C2  0E08    	        LD      C,8
1176: 6494+17	07C4  CDC803  	        CALL    CHKSTK          ; Check for 8 levels of stack
1177: 6511+11	07C7  E5      	        PUSH    HL              ; Save code string address
1178: 6522+16	07C8  2AA11E  	        LD      HL,(LOOPST)     ; Get first statement of loop
1179: 6538+19	07CB  E3      	        EX      (SP),HL         ; Save and restore code string
1180: 6557+11	07CC  E5      	        PUSH    HL              ; Re-save code string address
1181: 6568+16	07CD  2A361E  	        LD      HL,(LINEAT)     ; Get current line number
1182: 6584+19	07D0  E3      	        EX      (SP),HL         ; Save and restore code string
1183: 6603+17	07D1  CDF90C  	        CALL    TSTNUM          ; Make sure it's a number
1184: 6620+17	07D4  CDBC06  	        CALL    CHKSYN          ; Make sure "TO" is next
1185:     -	07D7  A3      	        .BYTE   ZTO             ; "TO" token
1186: 6637+17	07D8  CDF60C  	        CALL    GETNUM          ; Get "TO" expression value
1187: 6654+20	07DB  ED5BBE1E	        LD      DE,(FPREG)      ; Move "TO" value to BCDE
1188: 6674+20	07DF  ED4BC01E	        LD      BC,(FPREG+2)
1189: 6694+11	07E3  C5      	        PUSH    BC              ; Save "TO" value in block
1190: 6705+11	07E4  D5      	        PUSH    DE
1191: 6716+10	07E5  010081  	        LD      BC,8100H        ; BCDE - 1 (default STEP)
1192: 6726+4	07E8  51      	        LD      D,C             ; C=0
1193: 6730+4	07E9  5A      	        LD      E,D             ; D=0
1194: 6734+7	07EA  7E      	        LD      A,(HL)          ; Get next byte in code string
1195: 6741+7	07EB  FEA8    	        CP      ZSTEP           ; See if "STEP" is stated
1196: 6748+7	07ED  3E01    	        LD      A,1             ; Sign of step = 1
1197: 6755+10	07EF  C20308  	        JP      NZ,SAVSTP       ; No STEP given - Default to 1
1198: 6765+17	07F2  CD4F08  	        CALL    GETCHR          ; Jump over "STEP" token
1199: 6782+17	07F5  CDF60C  	        CALL    GETNUM          ; Get step value
1200: 6799+20	07F8  ED5BBE1E	        LD      DE,(FPREG)      ; Move STEP to BCDE
1201: 6819+20	07FC  ED4BC01E	        LD      BC,(FPREG+2)
1202: 6839+17	0800  CD3F17  	        CALL    TSTSGN          ; Test sign of FPREG
1203: 6856+11	0803  C5      	SAVSTP: PUSH    BC              ; Save the STEP value in block
1204: 6867+11	0804  D5      	        PUSH    DE
1205: 6878+11	0805  F5      	        PUSH    AF              ; Save sign of STEP
1206: 6889+6	0806  33      	        INC     SP              ; Don't save flags
1207: 6895+11	0807  E5      	        PUSH    HL              ; Save code string address
1208: 6906+16	0808  2AA81E  	        LD      HL,(BRKLIN)     ; Get address of index variable
1209: 6922+19	080B  E3      	        EX      (SP),HL         ; Save and restore code string
1210: 6941+7	080C  0681    	PUTFID: LD      B,ZFOR          ; "FOR" block marker
1211: 6948+11	080E  C5      	        PUSH    BC              ; Save it
1212: 6959+6	080F  33      	        INC     SP              ; Don't save C
1213:				
1214: 6965+17	0810  CD7908  	RUNCNT: CALL    TSTBRK          ; Execution driver - Test break
1215: 6982+16	0813  22A81E  	        LD      (BRKLIN),HL     ; Save code address for break
1216: 6998+7	0816  7E      	        LD      A,(HL)          ; Get next byte in code string
1217: 7005+7	0817  FE3A    	        CP      ':'             ; Multi statement line?
1218: 7012+10	0819  CA2F08  	        JP      Z,EXCUTE        ; Yes - Execute it
1219: 7022+4	081C  B7      	        OR      A               ; End of line?
1220: 7026+10	081D  C2EB03  	        JP      NZ,SNERR        ; No - Syntax error
1221: 7036+6	0820  23      	        INC     HL              ; Point to address of next line
1222: 7042+7	0821  7E      	        LD      A,(HL)          ; Get LSB of line pointer
1223: 7049+6	0822  23      	        INC     HL
1224: 7055+7	0823  B6      	        OR      (HL)            ; Is it zero (End of prog)?
1225: 7062+10	0824  CAA108  	        JP      Z,ENDPRG        ; Yes - Terminate execution
1226: 7072+6	0827  23      	        INC     HL              ; Point to line number
1227: 7078+7	0828  5E      	        LD      E,(HL)          ; Get LSB of line number
1228: 7085+6	0829  23      	        INC     HL
1229: 7091+7	082A  56      	        LD      D,(HL)          ; Get MSB of line number
1230: 7098+20	082B  ED53361E	        LD      (LINEAT),DE     ; Save as current line number
1231: 7118+17	082F  CD4F08  	EXCUTE: CALL    GETCHR          ; Get key word
1232: 7135+10	0832  111008  	        LD      DE,RUNCNT       ; Where to RETurn to
1233: 7145+11	0835  D5      	        PUSH    DE              ; Save for RETurn
1234: 7156+5+6	0836  C8      	IFJMP:  RET     Z               ; Go to RUNCNT if end of STMT
1235: 7161+7	0837  D680    	ONJMP:  SUB     ZEND            ; Is it a token?
1236: 7168+10	0839  DA070A  	        JP      C,LET           ; No - try to assign it
1237: 7178+7	083C  FE22    	        CP      ZNEW+1-ZEND     ; END to NEW ?
1238: 7185+10	083E  D2EB03  	        JP      NC,SNERR        ; Not a key word - ?SN Error
1239: 7195+4	0841  07      	        RLCA                    ; Double it
1240: 7199+4	0842  4F      	        LD      C,A             ; BC = Offset into table
1241: 7203+7	0843  0600    	        LD      B,0
1242: 7210+4	0845  EB      	        EX      DE,HL           ; Save code string address
1243: 7214+10	0846  219B02  	        LD      HL,WORDTB       ; Keyword address table
1244: 7224+11	0849  09      	        ADD     HL,BC           ; Point to routine address
1245: 7235+7	084A  4E      	        LD      C,(HL)          ; Get LSB of routine address
1246: 7242+6	084B  23      	        INC     HL
1247: 7248+7	084C  46      	        LD      B,(HL)          ; Get MSB of routine address
1248: 7255+11	084D  C5      	        PUSH    BC              ; Save routine address
1249: 7266+4	084E  EB      	        EX      DE,HL           ; Restore code string address
1250:				
1251: 7270+6	084F  23      	GETCHR: INC     HL              ; Point to next character
1252: 7276+7	0850  7E      	        LD      A,(HL)          ; Get next code string byte
1253: 7283+7	0851  FE3A    	        CP      ':'             ; Z if ':'
1254: 7290+5+6	0853  D0      	        RET     NC              ; NC if > "9"
1255: 7295+7	0854  FE20    	        CP      ' '
1256: 7302+7+5	0856  28F7    	        JR      Z,GETCHR        ; Skip over spaces
1257: 7309+7	0858  FE30    	        CP      '0'
1258: 7316+4	085A  3F      	        CCF                     ; NC if < '0'
1259: 7320+4	085B  3C      	        INC     A               ; Test for zero - Leave carry
1260: 7324+4	085C  3D      	        DEC     A               ; Z if Null
1261: 7328+10	085D  C9      	        RET
1262:				
1263: 7338+4	085E  EB      	RESTOR: EX      DE,HL           ; Save code string address
1264: 7342+16	085F  2A381E  	        LD      HL,(BASTXT)     ; Point to start of program
1265: 7358+10	0862  CA7308  	        JP      Z,RESTNL        ; Just RESTORE - reset pointer
1266: 7368+4	0865  EB      	        EX      DE,HL           ; Restore code string address
1267: 7372+17	0866  CD1B09  	        CALL    ATOH            ; Get line number to DE
1268: 7389+11	0869  E5      	        PUSH    HL              ; Save code string address
1269: 7400+17	086A  CDDD04  	        CALL    SRCHLN          ; Search for line number in DE
1270: 7417+4	086D  60      	        LD      H,B             ; HL = Address of line
1271: 7421+4	086E  69      	        LD      L,C
1272: 7425+10	086F  D1      	        POP     DE              ; Restore code string address
1273: 7435+10	0870  D2C609  	        JP      NC,ULERR        ; ?UL Error if not found
1274: 7445+6	0873  2B      	RESTNL: DEC     HL              ; Byte before DATA statement
1275: 7451+16	0874  22B61E  	UPDATA: LD      (NXTDAT),HL     ; Update DATA pointer
1276: 7467+4	0877  EB      	        EX      DE,HL           ; Restore code string address
1277: 7471+10	0878  C9      	        RET
1278:				
1279:				
1280: 7481+11	0879  DF      	TSTBRK: RST     18H             ; Check input status
1281: 7492+4	087A  B7      	        OR      A               ; Check count Zero
1282: 7496+5+6	087B  C8      	        RET     Z               ; No key, go back
1283: 7501+11	087C  D7      	        RST     10H             ; Get the key into A
1284: 7512+7	087D  FE1B    	        CP      ESC             ; Escape key?
1285: 7519+7+5	087F  2811    	        JR      Z,BRK           ; Yes, break
1286: 7526+7	0881  FE03    	        CP      CTRLC           ; <Ctrl-C>
1287: 7533+7+5	0883  280D    	        JR      Z,BRK           ; Yes, break
1288: 7540+7	0885  FE13    	        CP      CTRLS           ; Stop scrolling?
1289: 7547+5+6	0887  C0      	        RET     NZ              ; Other key, ignore
1290:				
1291:				
1292: 7552+11	0888  D7      	STALL:  RST     10H             ; Wait for key
1293: 7563+7	0889  FE11    	        CP      CTRLQ           ; Resume scrolling?
1294: 7570+5+6	088B  C8      	        RET      Z              ; Release the chokehold
1295: 7575+7	088C  FE03    	        CP      CTRLC           ; Second break?
1296: 7582+7+5	088E  2807    	        JR      Z,STOP          ; Break during hold exits prog
1297: 7589+12	0890  18F6    	        JR      STALL           ; Loop until <Ctrl-Q> or <brk>
1298:				
1299: 7601+7	0892  3EFF    	BRK:    LD      A,$FF           ; Set BRKFLG
1300: 7608+13	0894  32301E  	        LD      (BRKFLG),A      ; Store it
1301:				
1302:				
1303: 7621+5+6	0897  C0      	STOP:   RET     NZ              ; Exit if anything else
1304:     -	0898  F6      	        .BYTE   0F6H            ; Flag "STOP"
1305: 7626+5+6	0899  C0      	PEND:   RET     NZ              ; Exit if anything else
1306: 7631+16	089A  22A81E  	        LD      (BRKLIN),HL     ; Save point of break
1307:     -	089D  21      	        .BYTE   21H             ; Skip "OR 11111111B"
1308: 7647+7	089E  F6FF    	INPBRK: OR      11111111B       ; Flag "Break" wanted
1309: 7654+10	08A0  C1      	        POP     BC              ; Return not needed and more
1310: 7664+16	08A1  2A361E  	ENDPRG: LD      HL,(LINEAT)     ; Get current line number
1311: 7680+11	08A4  F5      	        PUSH    AF              ; Save STOP / END status
1312: 7691+4	08A5  7D      	        LD      A,L             ; Is it direct break?
1313: 7695+4	08A6  A4      	        AND     H
1314: 7699+4	08A7  3C      	        INC     A               ; Line is -1 if direct break
1315: 7703+10	08A8  CAB408  	        JP      Z,NOLIN         ; Yes - No line number
1316: 7713+16	08AB  22AC1E  	        LD      (ERRLIN),HL     ; Save line of break
1317: 7729+16	08AE  2AA81E  	        LD      HL,(BRKLIN)     ; Get point of break
1318: 7745+16	08B1  22AE1E  	        LD      (CONTAD),HL     ; Save point to CONTinue
1319: 7761+4	08B4  AF      	NOLIN:  XOR     A
1320: 7765+13	08B5  32281E  	        LD      (CTLOFG),A      ; Enable output
1321: 7778+17	08B8  CD0C0B  	        CALL    STTLIN          ; Start a new line
1322: 7795+10	08BB  F1      	        POP     AF              ; Restore STOP / END status
1323: 7805+10	08BC  218803  	        LD      HL,BRKMSG       ; "Break" message
1324: 7815+10	08BF  C21F04  	        JP      NZ,ERRIN        ; "in line" wanted?
1325: 7825+10	08C2  C33904  	        JP      PRNTOK          ; Go to command mode
1326:				
1327: 7835+16	08C5  2AAE1E  	CONT:   LD      HL,(CONTAD)     ; Get CONTinue address
1328: 7851+4	08C8  7C      	        LD      A,H             ; Is it zero?
1329: 7855+4	08C9  B5      	        OR      L
1330: 7859+7	08CA  1E20    	        LD      E,CN            ; ?CN Error
1331: 7866+10	08CC  CAFF03  	        JP      Z,ERROR         ; Yes - output "?CN Error"
1332: 7876+4	08CF  EB      	        EX      DE,HL           ; Save code string address
1333: 7880+16	08D0  2AAC1E  	        LD      HL,(ERRLIN)     ; Get line of last break
1334: 7896+16	08D3  22361E  	        LD      (LINEAT),HL     ; Set up current line number
1335: 7912+4	08D6  EB      	        EX      DE,HL           ; Restore code string address
1336: 7916+10	08D7  C9      	        RET                     ; CONTinue where left off
1337:				
1338: 7926+17	08D8  CDA114  	NULL:   CALL    GETINT          ; Get integer 0-255
1339: 7943+5+6	08DB  C0      	        RET     NZ              ; Return if bad value
1340: 7948+13	08DC  32241E  	        LD      (NULLS),A       ; Set nulls number
1341: 7961+10	08DF  C9      	        RET
1342:				
1343: 7971+11	08E0  E5      	ACCSUM: PUSH    HL              ; Save address in array
1344: 7982+16	08E1  2A2D1E  	        LD      HL,(CHKSUM)     ; Get check sum
1345: 7998+7	08E4  0600    	        LD      B,0             ; BC - Value of byte
1346: 8005+4	08E6  4F      	        LD      C,A
1347: 8009+11	08E7  09      	        ADD     HL,BC           ; Add byte to check sum
1348: 8020+16	08E8  222D1E  	        LD      (CHKSUM),HL     ; Re-save check sum
1349: 8036+10	08EB  E1      	        POP     HL              ; Restore address in array
1350: 8046+10	08EC  C9      	        RET
1351:				
1352: 8056+7	08ED  7E      	CHKLTR: LD      A,(HL)          ; Get byte
1353: 8063+7	08EE  FE41    	        CP      'A'             ; < 'a' ?
1354: 8070+5+6	08F0  D8      	        RET     C               ; Carry set if not letter
1355: 8075+7	08F1  FE5B    	        CP      'Z'+1           ; > 'z' ?
1356: 8082+4	08F3  3F      	        CCF
1357: 8086+10	08F4  C9      	        RET                     ; Carry set if not letter
1358:				
1359: 8096+17	08F5  CD4F08  	FPSINT: CALL    GETCHR          ; Get next character
1360: 8113+17	08F8  CDF60C  	POSINT: CALL    GETNUM          ; Get integer 0 to 32767
1361: 8130+17	08FB  CD3F17  	DEPINT: CALL    TSTSGN          ; Test sign of FPREG
1362: 8147+10	08FE  FA1609  	        JP      M,FCERR         ; Negative - ?FC Error
1363: 8157+13	0901  3AC11E  	DEINT:  LD      A,(FPEXP)       ; Get integer value to DE
1364: 8170+7	0904  FE90    	        CP      80H+16          ; Exponent in range (16 bits)?
1365: 8177+10	0906  DAD417  	        JP      C,FPINT         ; Yes - convert it
1366: 8187+10	0909  018090  	        LD      BC,9080H        ; BCDE = -32768
1367: 8197+10	090C  110000  	        LD      DE,0000
1368: 8207+11	090F  E5      	        PUSH    HL              ; Save code string address
1369: 8218+17	0910  CDA717  	        CALL    CMPNUM          ; Compare FPREG with BCDE
1370: 8235+10	0913  E1      	        POP     HL              ; Restore code string address
1371: 8245+4	0914  51      	        LD      D,C             ; MSB to D
1372: 8249+5+6	0915  C8      	        RET     Z               ; Return if in range
1373: 8254+7	0916  1E08    	FCERR:  LD      E,FC            ; ?FC Error
1374: 8261+10	0918  C3FF03  	        JP      ERROR           ; Output error-
1375:				
1376: 8271+6	091B  2B      	ATOH:   DEC     HL              ; ASCII number to DE binary
1377: 8277+10	091C  110000  	GETLN:  LD      DE,0            ; Get number to DE
1378: 8287+17	091F  CD4F08  	GTLNLP: CALL    GETCHR          ; Get next character
1379: 8304+5+6	0922  D0      	        RET     NC              ; Exit if not a digit
1380: 8309+11	0923  E5      	        PUSH    HL              ; Save code string address
1381: 8320+11	0924  F5      	        PUSH    AF              ; Save digit
1382: 8331+10	0925  219819  	        LD      HL,65529/10     ; Largest number 65529
1383: 8341+4	0928  7C      	        LD      A,H             ; Number in range?
1384: 8345+4	0929  92      	        SUB     D               ; Compare with D
1385: 8349+10	092A  C22F09  	        JP      NZ,$+5          ; Different - Exit
1386: 8359+4	092D  7D      	        LD      A,L             ; Get L
1387: 8363+4	092E  93      	        SUB     E               ; Compare with E
1388: 8367+10	092F  DAEB03  	        JP      C,SNERR         ; No - ?SN Error
1389: 8377+4	0932  62      	        LD      H,D             ; HL = Number
1390: 8381+4	0933  6B      	        LD      L,E
1391: 8385+11	0934  19      	        ADD     HL,DE           ; Times 2
1392: 8396+11	0935  29      	        ADD     HL,HL           ; Times 4
1393: 8407+11	0936  19      	        ADD     HL,DE           ; Times 5
1394: 8418+11	0937  29      	        ADD     HL,HL           ; Times 10
1395: 8429+10	0938  F1      	        POP     AF              ; Restore digit
1396: 8439+7	0939  D630    	        SUB     '0'             ; Make it 0 to 9
1397: 8446+4	093B  5F      	        LD      E,A             ; DE = Value of digit
1398: 8450+7	093C  1600    	        LD      D,0
1399: 8457+11	093E  19      	        ADD     HL,DE           ; Add to number
1400: 8468+4	093F  EB      	        EX      DE,HL           ; Number to DE
1401: 8472+10	0940  E1      	        POP     HL              ; Restore code string address
1402: 8482+10	0941  C31F09  	        JP      GTLNLP          ; Go to next character
1403:				
1404: 8492+10	0944  CA1005  	CLEAR:  JP      Z,INTVAR        ; Just "CLEAR" Keep parameters
1405: 8502+17	0947  CDF808  	        CALL    POSINT          ; Get integer 0 to 32767 to DE
1406: 8519+6	094A  2B      	        DEC     HL              ; Cancel increment
1407: 8525+17	094B  CD4F08  	        CALL    GETCHR          ; Get next character
1408: 8542+11	094E  E5      	        PUSH    HL              ; Save code string address
1409: 8553+16	094F  2A891E  	        LD      HL,(LSTRAM)     ; Get end of RAM
1410: 8569+10	0952  CA6709  	        JP      Z,STORED        ; No value given - Use stored
1411: 8579+10	0955  E1      	        POP     HL              ; Restore code string address
1412: 8589+17	0956  CDBC06  	        CALL    CHKSYN          ; Check for comma
1413:     -	0959  2C      	        .BYTE   ','
1414: 8606+11	095A  D5      	        PUSH    DE              ; Save number
1415: 8617+17	095B  CDF808  	        CALL    POSINT          ; Get integer 0 to 32767
1416: 8634+6	095E  2B      	        DEC     HL              ; Cancel increment
1417: 8640+17	095F  CD4F08  	        CALL    GETCHR          ; Get next character
1418: 8657+10	0962  C2EB03  	        JP      NZ,SNERR        ; ?SN Error if more on line
1419: 8667+19	0965  E3      	        EX      (SP),HL         ; Save code string address
1420: 8686+4	0966  EB      	        EX      DE,HL           ; Number to DE
1421: 8690+4	0967  7D      	STORED: LD      A,L             ; Get LSB of new RAM top
1422: 8694+4	0968  93      	        SUB     E               ; Subtract LSB of string space
1423: 8698+4	0969  5F      	        LD      E,A             ; Save LSB
1424: 8702+4	096A  7C      	        LD      A,H             ; Get MSB of new RAM top
1425: 8706+4	096B  9A      	        SBC     A,D             ; Subtract MSB of string space
1426: 8710+4	096C  57      	        LD      D,A             ; Save MSB
1427: 8714+10	096D  DAE003  	        JP      C,OMERR         ; ?OM Error if not enough mem
1428: 8724+11	0970  E5      	        PUSH    HL              ; Save RAM top
1429: 8735+16	0971  2AB01E  	        LD      HL,(PROGND)     ; Get program end
1430: 8751+10	0974  012800  	        LD      BC,40           ; 40 Bytes minimum working RAM
1431: 8761+11	0977  09      	        ADD     HL,BC           ; Get lowest address
1432: 8772+4	0978  7C      	        LD      A,H             ; Enough memory?
1433: 8776+4	0979  92      	        SUB     D               ; Compare with D
1434: 8780+7+5	097A  2002    	        JR      NZ,$+4          ; Different - Exit
1435: 8787+4	097C  7D      	        LD      A,L             ; Get L
1436: 8791+4	097D  93      	        SUB     E               ; Compare with E
1437: 8795+10	097E  D2E003  	        JP      NC,OMERR        ; No - ?OM Error
1438: 8805+4	0981  EB      	        EX      DE,HL           ; RAM top to HL
1439: 8809+16	0982  22341E  	        LD      (STRSPC),HL     ; Set new string space
1440: 8825+10	0985  E1      	        POP     HL              ; End of memory to use
1441: 8835+16	0986  22891E  	        LD      (LSTRAM),HL     ; Set new top of RAM
1442: 8851+10	0989  E1      	        POP     HL              ; Restore code string address
1443: 8861+10	098A  C31005  	        JP      INTVAR          ; Initialise variables
1444:				
1445: 8871+10	098D  CA0C05  	RUN:    JP      Z,RUNFST        ; RUN from start if just RUN
1446: 8881+17	0990  CD1005  	        CALL    INTVAR          ; Initialise variables
1447: 8898+10	0993  011008  	        LD      BC,RUNCNT       ; Execution driver loop
1448: 8908+10	0996  C3A909  	        JP      RUNLIN          ; RUN from line number
1449:				
1450: 8918+7	0999  0E03    	GOSUB:  LD      C,3             ; 3 Levels of stack needed
1451: 8925+17	099B  CDC803  	        CALL    CHKSTK          ; Check for 3 levels of stack
1452: 8942+10	099E  C1      	        POP     BC              ; Get return address
1453: 8952+11	099F  E5      	        PUSH    HL              ; Save code string for RETURN
1454: 8963+11	09A0  E5      	        PUSH    HL              ; And for GOSUB routine
1455: 8974+16	09A1  2A361E  	        LD      HL,(LINEAT)     ; Get current line
1456: 8990+19	09A4  E3      	        EX      (SP),HL         ; Into stack - Code string out
1457: 9009+7	09A5  3E8C    	        LD      A,ZGOSUB        ; "GOSUB" token
1458: 9016+11	09A7  F5      	        PUSH    AF              ; Save token
1459: 9027+6	09A8  33      	        INC     SP              ; Don't save flags
1460:				
1461: 9033+11	09A9  C5      	RUNLIN: PUSH    BC              ; Save return address
1462: 9044+17	09AA  CD1B09  	GOTO:   CALL    ATOH            ; ASCII number to DE binary
1463: 9061+17	09AD  CDF209  	        CALL    REM             ; Get end of line
1464: 9078+11	09B0  E5      	        PUSH    HL              ; Save end of line
1465: 9089+16	09B1  2A361E  	        LD      HL,(LINEAT)     ; Get current line
1466: 9105+4	09B4  7C      	        LD      A,H             ; Line after current?
1467: 9109+4	09B5  92      	        SUB     D               ; Compare with D
1468: 9113+7+5	09B6  2002    	        JR      NZ,$+4          ; Different - Exit
1469: 9120+4	09B8  7D      	        LD      A,L             ; Get L
1470: 9124+4	09B9  93      	        SUB     E               ; Compare with E
1471: 9128+10	09BA  E1      	        POP     HL              ; Restore end of line
1472: 9138+6	09BB  23      	        INC     HL              ; Start of next line
1473: 9144+10+7	09BC  DCE004  	        CALL    C,SRCHLP        ; Line is after current line
1474: 9154+10+7	09BF  D4DD04  	        CALL    NC,SRCHLN       ; Line is before current line
1475: 9164+4	09C2  60      	        LD      H,B             ; Set up code string address
1476: 9168+4	09C3  69      	        LD      L,C
1477: 9172+6	09C4  2B      	        DEC     HL              ; Incremented after
1478: 9178+5+6	09C5  D8      	        RET     C               ; Line found
1479: 9183+7	09C6  1E0E    	ULERR:  LD      E,UL            ; ?UL Error
1480: 9190+10	09C8  C3FF03  	        JP      ERROR           ; Output error message
1481:				
1482: 9200+5+6	09CB  C0      	RETURN: RET     NZ              ; Return if not just RETURN
1483: 9205+7	09CC  16FF    	        LD      D,-1            ; Flag "GOSUB" search
1484: 9212+17	09CE  CD8E03  	        CALL    BAKSTK          ; Look "GOSUB" block
1485: 9229+6	09D1  F9      	        LD      SP,HL           ; Kill all FORs in subroutine
1486: 9235+7	09D2  FE8C    	        CP      ZGOSUB          ; Test for "GOSUB" token
1487: 9242+7	09D4  1E04    	        LD      E,RG            ; ?RG Error
1488: 9249+10	09D6  C2FF03  	        JP      NZ,ERROR        ; Error if no "GOSUB" found
1489: 9259+10	09D9  E1      	        POP     HL              ; Get RETURN line number
1490: 9269+16	09DA  22361E  	        LD      (LINEAT),HL     ; Save as current
1491: 9285+6	09DD  23      	        INC     HL              ; Was it from direct statement?
1492: 9291+4	09DE  7C      	        LD      A,H
1493: 9295+4	09DF  B5      	        OR      L               ; Return to line
1494: 9299+10	09E0  C2EA09  	        JP      NZ,RETLIN       ; No - Return to line
1495: 9309+13	09E3  3AA61E  	        LD      A,(LSTBIN)      ; Any INPUT in subroutine?
1496: 9322+4	09E6  B7      	        OR      A               ; If so buffer is corrupted
1497: 9326+10	09E7  C23804  	        JP      NZ,POPNOK       ; Yes - Go to command mode
1498: 9336+10	09EA  211008  	RETLIN: LD      HL,RUNCNT       ; Execution driver loop
1499: 9346+19	09ED  E3      	        EX      (SP),HL         ; Into stack - Code string out
1500:     -	09EE  3E      	        .BYTE   3EH             ; Skip "POP HL"
1501: 9365+10	09EF  E1      	NXTDTA: POP     HL              ; Restore code string address
1502:				
1503:     -	09F0  013A    	DATA:   .BYTE   01H,3AH         ; ':' End of statement
1504: 9375+7	09F2  0E00    	REM:    LD      C,0             ; 00  End of statement
1505: 9382+7	09F4  0600    	        LD      B,0
1506: 9389+4	09F6  79      	NXTSTL: LD      A,C             ; Statement and byte
1507: 9393+4	09F7  48      	        LD      C,B
1508: 9397+4	09F8  47      	        LD      B,A             ; Statement end byte
1509: 9401+7	09F9  7E      	NXTSTT: LD      A,(HL)          ; Get byte
1510: 9408+4	09FA  B7      	        OR      A               ; End of line?
1511: 9412+5+6	09FB  C8      	        RET     Z               ; Yes - Exit
1512: 9417+4	09FC  B8      	        CP      B               ; End of statement?
1513: 9421+5+6	09FD  C8      	        RET     Z               ; Yes - Exit
1514: 9426+6	09FE  23      	        INC     HL              ; Next byte
1515: 9432+7	09FF  FE22    	        CP      '"'             ; Literal string?
1516: 9439+10	0A01  CAF609  	        JP      Z,NXTSTL        ; Yes - Look for another '"'
1517: 9449+10	0A04  C3F909  	        JP      NXTSTT          ; Keep looking
1518:				
1519: 9459+17	0A07  CDF50E  	LET:    CALL    GETVAR          ; Get variable name
1520: 9476+17	0A0A  CDBC06  	        CALL    CHKSYN          ; Make sure "=" follows
1521:     -	0A0D  B1      	        .BYTE   ZEQUAL          ; "=" token
1522: 9493+11	0A0E  D5      	        PUSH    DE              ; Save address of variable
1523: 9504+13	0A0F  3A871E  	        LD      A,(TYPE)        ; Get data type
1524: 9517+11	0A12  F5      	        PUSH    AF              ; Save type
1525: 9528+17	0A13  CD080D  	        CALL    EVAL            ; Evaluate expression
1526: 9545+10	0A16  F1      	        POP     AF              ; Restore type
1527: 9555+19	0A17  E3      	        EX      (SP),HL         ; Save code - Get var addr
1528: 9574+16	0A18  22A81E  	        LD      (BRKLIN),HL     ; Save address of variable
1529: 9590+4	0A1B  1F      	        RRA                     ; Adjust type
1530: 9594+17	0A1C  CDFB0C  	        CALL    CHKTYP          ; Check types are the same
1531: 9611+10	0A1F  CA690A  	        JP      Z,LETNUM        ; Numeric - Move value
1532: 9621+11	0A22  E5      	LETSTR: PUSH    HL              ; Save address of string var
1533: 9632+16	0A23  2ABE1E  	        LD      HL,(FPREG)      ; Pointer to string entry
1534: 9648+11	0A26  E5      	        PUSH    HL              ; Save it on stack
1535: 9659+6	0A27  23      	        INC     HL              ; Skip over length
1536: 9665+6	0A28  23      	        INC     HL
1537: 9671+7	0A29  5E      	        LD      E,(HL)          ; LSB of string address
1538: 9678+6	0A2A  23      	        INC     HL
1539: 9684+7	0A2B  56      	        LD      D,(HL)          ; MSB of string address
1540: 9691+16	0A2C  2A381E  	        LD      HL,(BASTXT)     ; Point to start of program
1541: 9707+4	0A2F  7C      	        LD      A,H             ; Is string before program?
1542: 9711+4	0A30  92      	        SUB     D               ; Compare with D
1543: 9715+7+5	0A31  2002    	        JR      NZ,$+4          ; Different - Exit
1544: 9722+4	0A33  7D      	        LD      A,L             ; Get L
1545: 9726+4	0A34  93      	        SUB     E               ; Compare with E
1546: 9730+10	0A35  D2520A  	        JP      NC,CRESTR       ; Yes - Create string entry
1547: 9740+16	0A38  2A341E  	        LD      HL,(STRSPC)     ; Point to string space
1548: 9756+4	0A3B  7C      	        LD      A,H             ; Is string literal in program?
1549: 9760+4	0A3C  92      	        SUB     D               ; Compare with D
1550: 9764+7+5	0A3D  2002    	        JR      NZ,$+4          ; Different - Exit
1551: 9771+4	0A3F  7D      	        LD      A,L             ; Get L
1552: 9775+4	0A40  93      	        SUB     E               ; Compare with E
1553: 9779+10	0A41  D1      	        POP     DE              ; Restore address of string
1554: 9789+10	0A42  D25A0A  	        JP      NC,MVSTPT       ; Yes - Set up pointer
1555: 9799+10	0A45  21991E  	        LD      HL,TMPSTR       ; Temporary string pool
1556: 9809+4	0A48  7C      	        LD      A,H             ; Is string in temporary pool?
1557: 9813+4	0A49  92      	        SUB     D               ; Compare with D
1558: 9817+7+5	0A4A  2002    	        JR      NZ,$+4          ; Different - Exit
1559: 9824+4	0A4C  7D      	        LD      A,L             ; Get L
1560: 9828+4	0A4D  93      	        SUB     E               ; Compare with E
1561: 9832+10	0A4E  D25A0A  	        JP      NC,MVSTPT       ; No - Set up pointer
1562:     -	0A51  3E      	        .BYTE   3EH             ; Skip "POP DE"
1563: 9842+10	0A52  D1      	CRESTR: POP     DE              ; Restore address of string
1564: 9852+17	0A53  CD7713  	        CALL    BAKTMP          ; Back to last tmp-str entry
1565: 9869+4	0A56  EB      	        EX      DE,HL           ; Address of string entry
1566: 9873+17	0A57  CD9211  	        CALL    SAVSTR          ; Save string in string area
1567: 9890+17	0A5A  CD7713  	MVSTPT: CALL    BAKTMP          ; Back to last tmp-str entry
1568: 9907+10	0A5D  E1      	        POP     HL              ; Get string pointer
1569: 9917+4	0A5E  EB      	        EX      DE,HL           ; Move string pointer to var
1570: 9921+16	0A5F  EDA0    	        LDI                     ; 4 bytes to move (HL++)->(DE++)
1571: 9937+16	0A61  EDA0    	        LDI
1572: 9953+16	0A63  EDA0    	        LDI
1573: 9969+16	0A65  EDA0    	        LDI
1574: 9985+10	0A67  E1      	        POP     HL              ; Restore code string address
1575: 9995+10	0A68  C9      	        RET
1576:				
1577:10005+11	0A69  E5      	LETNUM: PUSH    HL              ; Save address of variable
1578:10016+10	0A6A  11BE1E  	        LD      DE,FPREG        ; Move FPREG to variable
1579:10026+4	0A6D  EB      	        EX      DE,HL
1580:10030+16	0A6E  EDA0    	        LDI                     ; 4 bytes to move (HL++)->(DE++)
1581:10046+16	0A70  EDA0    	        LDI
1582:10062+16	0A72  EDA0    	        LDI
1583:10078+16	0A74  EDA0    	        LDI
1584:10094+10	0A76  D1      	        POP     DE              ; Restore address of variable
1585:10104+10	0A77  E1      	        POP     HL              ; Restore code string address
1586:10114+10	0A78  C9      	        RET
1587:				
1588:10124+17	0A79  CDA114  	ON:     CALL    GETINT          ; Get integer 0-255
1589:10141+7	0A7C  7E      	        LD      A,(HL)          ; Get "GOTO" or "GOSUB" token
1590:10148+4	0A7D  47      	        LD      B,A             ; Save in B
1591:10152+7	0A7E  FE8C    	        CP      ZGOSUB          ; "GOSUB" token?
1592:10159+10	0A80  CA880A  	        JP      Z,ONGO          ; Yes - Find line number
1593:10169+17	0A83  CDBC06  	        CALL    CHKSYN          ; Make sure it's "GOTO"
1594:     -	0A86  88      	        .BYTE   ZGOTO           ; "GOTO" token
1595:10186+6	0A87  2B      	        DEC     HL              ; Cancel increment
1596:10192+4	0A88  4B      	ONGO:   LD      C,E             ; Integer of branch value
1597:10196+4	0A89  0D      	ONGOLP: DEC     C               ; Count branches
1598:10200+4	0A8A  78      	        LD      A,B             ; Get "GOTO" or "GOSUB" token
1599:10204+10	0A8B  CA3708  	        JP      Z,ONJMP         ; Go to that line if right one
1600:10214+17	0A8E  CD1C09  	        CALL    GETLN           ; Get line number to DE
1601:10231+7	0A91  FE2C    	        CP      ','             ; Another line number?
1602:10238+5+6	0A93  C0      	        RET     NZ              ; No - Drop through
1603:10243+10	0A94  C3890A  	        JP      ONGOLP          ; Yes - loop
1604:				
1605:10253+17	0A97  CD080D  	IF:     CALL    EVAL            ; Evaluate expression
1606:10270+7	0A9A  7E      	        LD      A,(HL)          ; Get token
1607:10277+7	0A9B  FE88    	        CP      ZGOTO           ; "GOTO" token?
1608:10284+10	0A9D  CAA50A  	        JP      Z,IFGO          ; Yes - Get line
1609:10294+17	0AA0  CDBC06  	        CALL    CHKSYN          ; Make sure it's "THEN"
1610:     -	0AA3  A6      	        .BYTE   ZTHEN           ; "THEN" token
1611:10311+6	0AA4  2B      	        DEC     HL              ; Cancel increment
1612:10317+17	0AA5  CDF90C  	IFGO:   CALL    TSTNUM          ; Make sure it's numeric
1613:10334+17	0AA8  CD3F17  	        CALL    TSTSGN          ; Test state of expression
1614:10351+10	0AAB  CAF209  	        JP      Z,REM           ; False - Drop through
1615:10361+17	0AAE  CD4F08  	        CALL    GETCHR          ; Get next character
1616:10378+10	0AB1  DAAA09  	        JP      C,GOTO          ; Number - GOTO that line
1617:10388+10	0AB4  C33608  	        JP      IFJMP           ; Otherwise do statement
1618:				
1619:10398+6	0AB7  2B      	MRPRNT: DEC     HL              ; DEC 'cos GETCHR INCs
1620:10404+17	0AB8  CD4F08  	        CALL    GETCHR          ; Get next character
1621:10421+10	0ABB  CA190B  	PRINT:  JP      Z,PRNTCRLF      ; CRLF if just PRINT
1622:10431+5+6	0ABE  C8      	PRNTLP: RET     Z               ; End of list - Exit
1623:10436+7	0ABF  FEA2    	        CP      ZTAB            ; "TAB(" token?
1624:10443+10	0AC1  CA4C0B  	        JP      Z,DOTAB         ; Yes - Do TAB routine
1625:10453+7	0AC4  FEA5    	        CP      ZSPC            ; "SPC(" token?
1626:10460+10	0AC6  CA4C0B  	        JP      Z,DOTAB         ; Yes - Do SPC routine
1627:10470+11	0AC9  E5      	        PUSH    HL              ; Save code string address
1628:10481+7	0ACA  FE2C    	        CP      ','             ; Comma?
1629:10488+10	0ACC  CA350B  	        JP      Z,DOCOM         ; Yes - Move to next zone
1630:10498+7	0ACF  FE3B    	        CP      59              ; ';' Semi-colon?
1631:10505+10	0AD1  CA6F0B  	        JP      Z,NEXITM        ; Do semi-colon routine
1632:10515+10	0AD4  C1      	        POP     BC              ; Code string address to BC
1633:10525+17	0AD5  CD080D  	        CALL    EVAL            ; Evaluate expression
1634:10542+11	0AD8  E5      	        PUSH    HL              ; Save code string address
1635:10553+13	0AD9  3A871E  	        LD      A,(TYPE)        ; Get variable type
1636:10566+4	0ADC  B7      	        OR      A               ; Is it a string variable?
1637:10570+10	0ADD  C2050B  	        JP      NZ,PRNTST       ; Yes - Output string contents
1638:10580+17	0AE0  CDDA18  	        CALL    NUMASC          ; Convert number to text
1639:10597+17	0AE3  CDB611  	        CALL    CRTST           ; Create temporary string
1640:10614+10	0AE6  3620    	        LD      (HL),' '        ; Followed by a space
1641:10624+16	0AE8  2ABE1E  	        LD      HL,(FPREG)      ; Get length of output
1642:10640+11	0AEB  34      	        INC     (HL)            ; Plus 1 for the space
1643:10651+16	0AEC  2ABE1E  	        LD      HL,(FPREG)      ; < Not needed >
1644:10667+13	0AEF  3A251E  	        LD      A,(LWIDTH)      ; Get width of line
1645:10680+4	0AF2  47      	        LD      B,A             ; To B
1646:10684+4	0AF3  04      	        INC     B               ; Width 255 (No limit)?
1647:10688+10	0AF4  CA010B  	        JP      Z,PRNTNB        ; Yes - Output number string
1648:10698+4	0AF7  04      	        INC     B               ; Adjust it
1649:10702+13	0AF8  3A851E  	        LD      A,(CURPOS)      ; Get cursor position
1650:10715+7	0AFB  86      	        ADD     A,(HL)          ; Add length of string
1651:10722+4	0AFC  3D      	        DEC     A               ; Adjust it
1652:10726+4	0AFD  B8      	        CP      B               ; Will output fit on this line?
1653:10730+10+7	0AFE  D4190B  	        CALL    NC,PRNTCRLF     ; No - CRLF first
1654:10740+17	0B01  CD0512  	PRNTNB: CALL    PRS1            ; Output string at (HL)
1655:10757+4	0B04  AF      	        XOR     A               ; Skip CALL by setting 'z' flag
1656:10761+10+7	0B05  C40512  	PRNTST: CALL    NZ,PRS1         ; Output string at (HL)
1657:10771+10	0B08  E1      	        POP     HL              ; Restore code string address
1658:10781+10	0B09  C3B70A  	        JP      MRPRNT          ; See if more to PRINT
1659:				
1660:10791+13	0B0C  3A851E  	STTLIN: LD      A,(CURPOS)      ; Make sure on new line
1661:10804+4	0B0F  B7      	        OR      A               ; Already at start?
1662:10808+5+6	0B10  C8      	        RET     Z               ; Yes - Do nothing
1663:10813+10	0B11  C3190B  	        JP      PRNTCRLF        ; Start a new line
1664:				
1665:10823+10	0B14  3600    	ENDINP: LD      (HL),0          ; Mark end of buffer
1666:10833+10	0B16  213A1E  	        LD      HL,BUFFER-1     ; Point to buffer
1667:10843+7	0B19  3E0D    	PRNTCRLF: LD    A,CR            ; Load a CR
1668:10850+17	0B1B  CDC706  	        CALL    OUTC            ; Output character
1669:10867+7	0B1E  3E0A    	        LD      A,LF            ; Load a LF
1670:10874+17	0B20  CDC706  	        CALL    OUTC            ; Output character
1671:10891+4	0B23  AF      	DONULL: XOR     A               ; Set to position 0
1672:10895+13	0B24  32851E  	        LD      (CURPOS),A      ; Store it
1673:10908+13	0B27  3A241E  	        LD      A,(NULLS)       ; Get number of nulls
1674:10921+4	0B2A  3D      	NULLP:  DEC     A               ; Count them
1675:10925+5+6	0B2B  C8      	        RET     Z               ; Return if done
1676:10930+11	0B2C  F5      	        PUSH    AF              ; Save count
1677:10941+4	0B2D  AF      	        XOR     A               ; Load a null
1678:10945+17	0B2E  CDC706  	        CALL    OUTC            ; Output it
1679:10962+10	0B31  F1      	        POP     AF              ; Restore count
1680:10972+10	0B32  C32A0B  	        JP      NULLP           ; Keep counting
1681:				
1682:10982+13	0B35  3A261E  	DOCOM:  LD      A,(COMMAN)      ; Get comma width
1683:10995+4	0B38  47      	        LD      B,A             ; Save in B
1684:10999+13	0B39  3A851E  	        LD      A,(CURPOS)      ; Get current position
1685:11012+4	0B3C  B8      	        CP      B               ; Within the limit?
1686:11016+10+7	0B3D  D4190B  	        CALL    NC,PRNTCRLF     ; No - output CRLF
1687:11026+10	0B40  D26F0B  	        JP      NC,NEXITM       ; Get next item
1688:11036+7	0B43  D60E    	ZONELP: SUB     14              ; Next zone of 14 characters
1689:11043+10	0B45  D2430B  	        JP      NC,ZONELP       ; Repeat if more zones
1690:11053+4	0B48  2F      	        CPL                     ; Number of spaces to output
1691:11057+10	0B49  C3640B  	        JP      ASPCS           ; Output them
1692:				
1693:11067+11	0B4C  F5      	DOTAB:  PUSH    AF              ; Save token
1694:11078+17	0B4D  CD9E14  	        CALL    FNDNUM          ; Evaluate expression
1695:11095+17	0B50  CDBC06  	        CALL    CHKSYN          ; Make sure ")" follows
1696:     -	0B53  29      	        .BYTE   ")"
1697:11112+6	0B54  2B      	        DEC     HL              ; Back space on to ")"
1698:11118+10	0B55  F1      	        POP     AF              ; Restore token
1699:11128+7	0B56  D6A5    	        SUB     ZSPC            ; Was it "SPC(" ?
1700:11135+11	0B58  E5      	        PUSH    HL              ; Save code string address
1701:11146+10	0B59  CA5F0B  	        JP      Z,DOSPC         ; Yes - Do 'E' spaces
1702:11156+13	0B5C  3A851E  	        LD      A,(CURPOS)      ; Get current position
1703:11169+4	0B5F  2F      	DOSPC:  CPL                     ; Number of spaces to print to
1704:11173+4	0B60  83      	        ADD     A,E             ; Total number to print
1705:11177+10	0B61  D26F0B  	        JP      NC,NEXITM       ; TAB < Current POS(X)
1706:11187+4	0B64  3C      	ASPCS:  INC     A               ; Output A spaces
1707:11191+4	0B65  47      	        LD      B,A             ; Save number to print
1708:11195+7	0B66  3E20    	        LD      A,' '           ; Space
1709:11202+17	0B68  CDC706  	SPCLP:  CALL    OUTC            ; Output character in A
1710:11219+4	0B6B  05      	        DEC     B               ; Count them
1711:11223+10	0B6C  C2680B  	        JP      NZ,SPCLP        ; Repeat if more
1712:11233+10	0B6F  E1      	NEXITM: POP     HL              ; Restore code string address
1713:11243+17	0B70  CD4F08  	        CALL    GETCHR          ; Get next character
1714:11260+10	0B73  C3BE0A  	        JP      PRNTLP          ; More to print
1715:				
1716:     -	0B76  3F526564	REDO:   .BYTE   "?Redo from start",CR,LF,0
	              6F206672
	              6F6D2073
	              74617274
	              0D0A00
1717:				
1718:11270+13	0B89  3AA71E  	BADINP: LD      A,(READFG)      ; READ or INPUT?
1719:11283+4	0B8C  B7      	        OR      A
1720:11287+10	0B8D  C2E503  	        JP      NZ,DATSNR       ; READ - ?SN Error
1721:11297+10	0B90  C1      	        POP     BC              ; Throw away code string addr
1722:11307+10	0B91  21760B  	        LD      HL,REDO         ; "Redo from start" message
1723:11317+17	0B94  CD0212  	        CALL    PRS             ; Output string
1724:11334+10	0B97  C33F05  	        JP      DOAGN           ; Do last INPUT again
1725:				
1726:11344+17	0B9A  CD6311  	INPUT:  CALL    IDTEST          ; Test for illegal direct
1727:11361+7	0B9D  7E      	        LD      A,(HL)          ; Get character after "INPUT"
1728:11368+7	0B9E  FE22    	        CP      '"'             ; Is there a prompt string?
1729:11375+7	0BA0  3E00    	        LD      A,0             ; Clear A and leave flags
1730:11382+13	0BA2  32281E  	        LD      (CTLOFG),A      ; Enable output
1731:11395+10	0BA5  C2B40B  	        JP      NZ,NOPMPT       ; No prompt - get input
1732:11405+17	0BA8  CDB711  	        CALL    QTSTR           ; Get string terminated by '"'
1733:11422+17	0BAB  CDBC06  	        CALL    CHKSYN          ; Check for ';' after prompt
1734:     -	0BAE  3B      	        .BYTE   ';'
1735:11439+11	0BAF  E5      	        PUSH    HL              ; Save code string address
1736:11450+17	0BB0  CD0512  	        CALL    PRS1            ; Output prompt string
1737:     -	0BB3  3E      	        .BYTE   3EH             ; Skip "PUSH HL"
1738:11467+11	0BB4  E5      	NOPMPT: PUSH    HL              ; Save code string address
1739:11478+17	0BB5  CD4305  	        CALL    PROMPT          ; Get input with "? " prompt
1740:11495+10	0BB8  C1      	        POP     BC              ; Restore code string address
1741:11505+10	0BB9  DA9E08  	        JP      C,INPBRK        ; Break pressed - Exit
1742:11515+6	0BBC  23      	        INC     HL              ; Next byte
1743:11521+7	0BBD  7E      	        LD      A,(HL)          ; Get it
1744:11528+4	0BBE  B7      	        OR      A               ; End of line?
1745:11532+6	0BBF  2B      	        DEC     HL              ; Back again
1746:11538+11	0BC0  C5      	        PUSH    BC              ; Re-save code string address
1747:11549+10	0BC1  CAEF09  	        JP      Z,NXTDTA        ; Yes - Find next DATA stmt
1748:11559+10	0BC4  362C    	        LD      (HL),','        ; Store comma as separator
1749:11569+10	0BC6  C3CE0B  	        JP      NXTITM          ; Get next item
1750:				
1751:11579+11	0BC9  E5      	READ:   PUSH    HL              ; Save code string address
1752:11590+16	0BCA  2AB61E  	        LD      HL,(NXTDAT)     ; Next DATA statement
1753:     -	0BCD  F6      	        .BYTE   0F6H            ; Flag "READ"
1754:11606+4	0BCE  AF      	NXTITM: XOR     A               ; Flag "INPUT"
1755:11610+13	0BCF  32A71E  	        LD      (READFG),A      ; Save "READ"/"INPUT" flag
1756:11623+19	0BD2  E3      	        EX      (SP),HL         ; Get code str' , Save pointer
1757:11642+10	0BD3  C3DA0B  	        JP      GTVLUS          ; Get values
1758:				
1759:11652+17	0BD6  CDBC06  	NEDMOR: CALL    CHKSYN          ; Check for comma between items
1760:     -	0BD9  2C      	        .BYTE   ','
1761:11669+17	0BDA  CDF50E  	GTVLUS: CALL    GETVAR          ; Get variable name
1762:11686+19	0BDD  E3      	        EX      (SP),HL         ; Save code str" , Get pointer
1763:11705+11	0BDE  D5      	        PUSH    DE              ; Save variable address
1764:11716+7	0BDF  7E      	        LD      A,(HL)          ; Get next "INPUT"/"DATA" byte
1765:11723+7	0BE0  FE2C    	        CP      ','             ; Comma?
1766:11730+10	0BE2  CA020C  	        JP      Z,ANTVLU        ; Yes - Get another value
1767:11740+13	0BE5  3AA71E  	        LD      A,(READFG)      ; Is it READ?
1768:11753+4	0BE8  B7      	        OR      A
1769:11757+10	0BE9  C2780C  	        JP      NZ,FDTLP        ; Yes - Find next DATA stmt
1770:11767+7	0BEC  3E3F    	        LD      A,'?'           ; More INPUT needed
1771:11774+17	0BEE  CDC706  	        CALL    OUTC            ; Output character
1772:11791+17	0BF1  CD4305  	        CALL    PROMPT          ; Get INPUT with prompt
1773:11808+10	0BF4  D1      	        POP     DE              ; Variable address
1774:11818+10	0BF5  C1      	        POP     BC              ; Code string address
1775:11828+10	0BF6  DA9E08  	        JP      C,INPBRK        ; Break pressed
1776:11838+6	0BF9  23      	        INC     HL              ; Point to next DATA byte
1777:11844+7	0BFA  7E      	        LD      A,(HL)          ; Get byte
1778:11851+4	0BFB  B7      	        OR      A               ; Is it zero (No input) ?
1779:11855+6	0BFC  2B      	        DEC     HL              ; Back space INPUT pointer
1780:11861+11	0BFD  C5      	        PUSH    BC              ; Save code string address
1781:11872+10	0BFE  CAEF09  	        JP      Z,NXTDTA        ; Find end of buffer
1782:11882+11	0C01  D5      	        PUSH    DE              ; Save variable address
1783:11893+13	0C02  3A871E  	ANTVLU: LD      A,(TYPE)        ; Check data type
1784:11906+4	0C05  B7      	        OR      A               ; Is it numeric?
1785:11910+10	0C06  CA2C0C  	        JP      Z,INPBIN        ; Yes - Convert to binary
1786:11920+17	0C09  CD4F08  	        CALL    GETCHR          ; Get next character
1787:11937+4	0C0C  57      	        LD      D,A             ; Save input character
1788:11941+4	0C0D  47      	        LD      B,A             ; Again
1789:11945+7	0C0E  FE22    	        CP      '"'             ; Start of literal sting?
1790:11952+10	0C10  CA200C  	        JP      Z,STRENT        ; Yes - Create string entry
1791:11962+13	0C13  3AA71E  	        LD      A,(READFG)      ; "READ" or "INPUT" ?
1792:11975+4	0C16  B7      	        OR      A
1793:11979+4	0C17  57      	        LD      D,A             ; Save 00 if "INPUT"
1794:11983+10	0C18  CA1D0C  	        JP      Z,ITMSEP        ; "INPUT" - End with 00
1795:11993+7	0C1B  163A    	        LD      D,':'           ; "DATA" - End with 00 or ':'
1796:12000+7	0C1D  062C    	ITMSEP: LD      B,','           ; Item separator
1797:12007+6	0C1F  2B      	        DEC     HL              ; Back space for DTSTR
1798:12013+17	0C20  CDBA11  	STRENT: CALL    DTSTR           ; Get string terminated by D
1799:12030+4	0C23  EB      	        EX      DE,HL           ; String address to DE
1800:12034+10	0C24  21400C  	        LD      HL,LTSTND       ; Where to go after LETSTR
1801:12044+19	0C27  E3      	        EX      (SP),HL         ; Save HL , get input pointer
1802:12063+11	0C28  D5      	        PUSH    DE              ; Save address of string
1803:12074+10	0C29  C3220A  	        JP      LETSTR          ; Assign string to variable
1804:				
1805:12084+17	0C2C  CD4F08  	INPBIN: CALL    GETCHR          ; Get next character
1806:12101+17	0C2F  CD3718  	        CALL    ASCTFP          ; Convert ASCII to FP number
1807:12118+19	0C32  E3      	        EX      (SP),HL         ; Save input ptr, Get var addr
1808:12137+10	0C33  11BE1E  	        LD      DE,FPREG        ; Move FPREG to variable
1809:12147+4	0C36  EB      	        EX      DE,HL
1810:12151+16	0C37  EDA0    	        LDI                     ; 4 bytes to move (HL++)->(DE++)
1811:12167+16	0C39  EDA0    	        LDI
1812:12183+16	0C3B  EDA0    	        LDI
1813:12199+16	0C3D  EDA0    	        LDI
1814:12215+10	0C3F  E1      	        POP     HL              ; Restore input pointer
1815:12225+6	0C40  2B      	LTSTND: DEC     HL              ; DEC 'cos GETCHR INCs
1816:12231+17	0C41  CD4F08  	        CALL    GETCHR          ; Get next character
1817:12248+10	0C44  CA4C0C  	        JP      Z,MORDT         ; End of line - More needed?
1818:12258+7	0C47  FE2C    	        CP      ','             ; Another value?
1819:12265+10	0C49  C2890B  	        JP      NZ,BADINP       ; No - Bad input
1820:12275+19	0C4C  E3      	MORDT:  EX      (SP),HL         ; Get code string address
1821:12294+6	0C4D  2B      	        DEC     HL              ; DEC 'cos GETCHR INCs
1822:12300+17	0C4E  CD4F08  	        CALL    GETCHR          ; Get next character
1823:12317+10	0C51  C2D60B  	        JP      NZ,NEDMOR       ; More needed - Get it
1824:12327+10	0C54  D1      	        POP     DE              ; Restore DATA pointer
1825:12337+13	0C55  3AA71E  	        LD      A,(READFG)      ; "READ" or "INPUT" ?
1826:12350+4	0C58  B7      	        OR      A
1827:12354+4	0C59  EB      	        EX      DE,HL           ; DATA pointer to HL
1828:12358+10	0C5A  C27408  	        JP      NZ,UPDATA       ; Update DATA pointer if "READ"
1829:12368+11	0C5D  D5      	        PUSH    DE              ; Save code string address
1830:12379+7	0C5E  B6      	        OR      (HL)            ; More input given?
1831:12386+10	0C5F  21670C  	        LD      HL,EXTIG        ; "?Extra ignored" message
1832:12396+10+7	0C62  C40212  	        CALL    NZ,PRS          ; Output string if extra given
1833:12406+10	0C65  E1      	        POP     HL              ; Restore code string address
1834:12416+10	0C66  C9      	        RET
1835:				
1836:     -	0C67  3F457874	EXTIG:  .BYTE   "?Extra ignored",CR,LF,0
	              72612069
	              676E6F72
	              65640D0A
	              00
1837:				
1838:12426+17	0C78  CDF009  	FDTLP:  CALL    DATA            ; Get next statement
1839:12443+4	0C7B  B7      	        OR      A               ; End of line?
1840:12447+10	0C7C  C2900C  	        JP      NZ,FANDT        ; No - See if DATA statement
1841:12457+6	0C7F  23      	        INC     HL
1842:12463+7	0C80  7E      	        LD      A,(HL)          ; End of program?
1843:12470+6	0C81  23      	        INC     HL
1844:12476+7	0C82  B6      	        OR      (HL)            ; 00 00 Ends program
1845:12483+7	0C83  1E06    	        LD      E,OD            ; ?OD Error
1846:12490+10	0C85  CAFF03  	        JP      Z,ERROR         ; Yes - Out of DATA
1847:12500+6	0C88  23      	        INC     HL
1848:12506+7	0C89  5E      	        LD      E,(HL)          ; LSB of line number
1849:12513+6	0C8A  23      	        INC     HL
1850:12519+7	0C8B  56      	        LD      D,(HL)          ; MSB of line number
1851:12526+20	0C8C  ED53A31E	        LD      (DATLIN),DE     ; Set line of current DATA item
1852:12546+17	0C90  CD4F08  	FANDT:  CALL    GETCHR          ; Get next character
1853:12563+7	0C93  FE83    	        CP      ZDATA           ; "DATA" token
1854:12570+10	0C95  C2780C  	        JP      NZ,FDTLP        ; No "DATA" - Keep looking
1855:12580+10	0C98  C3020C  	        JP      ANTVLU          ; Found - Convert input
1856:				
1857:12590+10	0C9B  110000  	NEXT:   LD      DE,0            ; In case no index given
1858:12600+10+7	0C9E  C4F50E  	NEXT1:  CALL    NZ,GETVAR       ; Get index address
1859:12610+16	0CA1  22A81E  	        LD      (BRKLIN),HL     ; Save code string address
1860:12626+17	0CA4  CD8E03  	        CALL    BAKSTK          ; Look for "FOR" block
1861:12643+10	0CA7  C2F103  	        JP      NZ,NFERR        ; No "FOR" - ?NF Error
1862:12653+6	0CAA  F9      	        LD      SP,HL           ; Clear nested loops
1863:12659+11	0CAB  D5      	        PUSH    DE              ; Save index address
1864:12670+7	0CAC  7E      	        LD      A,(HL)          ; Get sign of STEP
1865:12677+6	0CAD  23      	        INC     HL
1866:12683+11	0CAE  F5      	        PUSH    AF              ; Save sign of STEP
1867:12694+11	0CAF  D5      	        PUSH    DE              ; Save index address
1868:12705+10	0CB0  11BE1E  	        LD      DE,FPREG        ; Move index value to FPREG
1869:12715+16	0CB3  EDA0    	        LDI                     ; 4 bytes to move (HL++)->(DE++)
1870:12731+16	0CB5  EDA0    	        LDI
1871:12747+16	0CB7  EDA0    	        LDI
1872:12763+16	0CB9  EDA0    	        LDI
1873:12779+19	0CBB  E3      	        EX      (SP),HL         ; Save address of TO value
1874:12798+11	0CBC  E5      	        PUSH    HL              ; Save address of index
1875:12809+17	0CBD  CDCD14  	        CALL    ADDPHL          ; Add STEP to index value
1876:12826+10	0CC0  D1      	        POP     DE              ; Restore address of index
1877:12836+10	0CC1  21BE1E  	        LD      HL,FPREG        ; Move FPREG to index variable
1878:12846+16	0CC4  EDA0    	        LDI                     ; 4 bytes to move (HL++)->(DE++)
1879:12862+16	0CC6  EDA0    	        LDI
1880:12878+16	0CC8  EDA0    	        LDI
1881:12894+16	0CCA  EDA0    	        LDI
1882:12910+10	0CCC  E1      	        POP     HL              ; Restore address of TO value
1883:12920+17	0CCD  CD8917  	        CALL    LOADFP          ; Move TO value to BCDE
1884:12937+11	0CD0  E5      	        PUSH    HL              ; Save address of line of FOR
1885:12948+17	0CD1  CDA717  	        CALL    CMPNUM          ; Compare index with TO value
1886:12965+10	0CD4  E1      	        POP     HL              ; Restore address of line num
1887:12975+10	0CD5  C1      	        POP     BC              ; Address of sign of STEP
1888:12985+4	0CD6  90      	        SUB     B               ; Compare with expected sign
1889:12989+17	0CD7  CD8917  	        CALL    LOADFP          ; BC = Loop stmt,DE = Line num
1890:13006+10	0CDA  CAE60C  	        JP      Z,KILFOR        ; Loop finished - Terminate it
1891:13016+4	0CDD  EB      	        EX      DE,HL           ; Loop statement line number
1892:13020+16	0CDE  22361E  	        LD      (LINEAT),HL     ; Set loop line number
1893:13036+4	0CE1  69      	        LD      L,C             ; Set code string to loop
1894:13040+4	0CE2  60      	        LD      H,B
1895:13044+10	0CE3  C30C08  	        JP      PUTFID          ; Put back "FOR" and continue
1896:				
1897:13054+6	0CE6  F9      	KILFOR: LD      SP,HL           ; Remove "FOR" block
1898:13060+16	0CE7  2AA81E  	        LD      HL,(BRKLIN)     ; Code string after "NEXT"
1899:13076+7	0CEA  7E      	        LD      A,(HL)          ; Get next byte in code string
1900:13083+7	0CEB  FE2C    	        CP      ','             ; More NEXTs ?
1901:13090+10	0CED  C21008  	        JP      NZ,RUNCNT       ; No - Do next statement
1902:13100+17	0CF0  CD4F08  	        CALL    GETCHR          ; Position to index name
1903:13117+17	0CF3  CD9E0C  	        CALL    NEXT1           ; Re-enter NEXT routine
1904:				; < will not RETurn to here , Exit to RUNCNT or Loop >
1905:				
1906:13134+17	0CF6  CD080D  	GETNUM: CALL    EVAL            ; Get a numeric expression
1907:     -	0CF9  F6      	TSTNUM: .BYTE   0F6H            ; Clear carry (numeric)
1908:13151+4	0CFA  37      	TSTSTR: SCF                     ; Set carry (string)
1909:13155+13	0CFB  3A871E  	CHKTYP: LD      A,(TYPE)        ; Check types match
1910:13168+4	0CFE  8F      	        ADC     A,A             ; Expected + actual
1911:13172+4	0CFF  B7      	        OR      A               ; Clear carry , set parity
1912:13176+5+6	0D00  E8      	        RET     PE              ; Even parity - Types match
1913:13181+10	0D01  C3FD03  	        JP      TMERR           ; Different types - Error
1914:				
1915:13191+17	0D04  CDBC06  	OPNPAR: CALL    CHKSYN          ; Make sure "(" follows
1916:     -	0D07  28      	        .BYTE   "("
1917:13208+6	0D08  2B      	EVAL:   DEC     HL              ; Evaluate expression & save
1918:13214+7	0D09  1600    	        LD      D,0             ; Precedence value
1919:13221+11	0D0B  D5      	EVAL1:  PUSH    DE              ; Save precedence
1920:13232+7	0D0C  0E01    	        LD      C,1
1921:13239+17	0D0E  CDC803  	        CALL    CHKSTK          ; Check for 1 level of stack
1922:13256+17	0D11  CD820D  	        CALL    OPRND           ; Get next expression value
1923:13273+16	0D14  22AA1E  	EVAL2:  LD      (NXTOPR),HL     ; Save address of next operator
1924:13289+16	0D17  2AAA1E  	EVAL3:  LD      HL,(NXTOPR)     ; Restore address of next opr
1925:13305+10	0D1A  C1      	        POP     BC              ; Precedence value and operator
1926:13315+4	0D1B  78      	        LD      A,B             ; Get precedence value
1927:13319+7	0D1C  FE78    	        CP      78H             ; "AND" or "OR" ?
1928:13326+10+7	0D1E  D4F90C  	        CALL    NC,TSTNUM       ; No - Make sure it's a number
1929:13336+7	0D21  7E      	        LD      A,(HL)          ; Get next operator / function
1930:13343+7	0D22  1600    	        LD      D,0             ; Clear Last relation
1931:13350+7	0D24  D6B0    	RLTLP:  SUB     ZGTR            ; ">" Token
1932:13357+10	0D26  DA400D  	        JP      C,FOPRND        ; + - * / ^ AND OR - Test it
1933:13367+7	0D29  FE03    	        CP      ZLTH+1-ZGTR     ; < = >
1934:13374+10	0D2B  D2400D  	        JP      NC,FOPRND       ; Function - Call it
1935:13384+7	0D2E  FE01    	        CP      ZEQUAL-ZGTR     ; "="
1936:13391+4	0D30  17      	        RLA                     ; <- Test for legal
1937:13395+4	0D31  AA      	        XOR     D               ; <- combinations of < = >
1938:13399+4	0D32  BA      	        CP      D               ; <- by combining last token
1939:13403+4	0D33  57      	        LD      D,A             ; <- with current one
1940:13407+10	0D34  DAEB03  	        JP      C,SNERR         ; Error if "<<' '==" or ">>"
1941:13417+16	0D37  229F1E  	        LD      (CUROPR),HL     ; Save address of current token
1942:13433+17	0D3A  CD4F08  	        CALL    GETCHR          ; Get next character
1943:13450+10	0D3D  C3240D  	        JP      RLTLP           ; Treat the two as one
1944:				
1945:13460+4	0D40  7A      	FOPRND: LD      A,D             ; < = > found ?
1946:13464+4	0D41  B7      	        OR      A
1947:13468+10	0D42  C2700E  	        JP      NZ,TSTRED       ; Yes - Test for reduction
1948:13478+7	0D45  7E      	        LD      A,(HL)          ; Get operator token
1949:13485+16	0D46  229F1E  	        LD      (CUROPR),HL     ; Save operator address
1950:13501+7	0D49  D6A9    	        SUB     ZPLUS           ; Operator or function?
1951:13508+5+6	0D4B  D8      	        RET     C               ; Neither - Exit
1952:13513+7	0D4C  FE07    	        CP      ZOR+1-ZPLUS     ; Is it + - * / ^ AND OR ?
1953:13520+5+6	0D4E  D0      	        RET     NC              ; No - Exit
1954:13525+4	0D4F  5F      	        LD      E,A             ; Coded operator
1955:13529+13	0D50  3A871E  	        LD      A,(TYPE)        ; Get data type
1956:13542+4	0D53  3D      	        DEC     A               ; FF = numeric , 00 = string
1957:13546+4	0D54  B3      	        OR      E               ; Combine with coded operator
1958:13550+4	0D55  7B      	        LD      A,E             ; Get coded operator
1959:13554+10	0D56  CA0913  	        JP      Z,CONCAT        ; String concatenation
1960:13564+4	0D59  07      	        RLCA                    ; Times 2
1961:13568+4	0D5A  83      	        ADD     A,E             ; Times 3
1962:13572+4	0D5B  5F      	        LD      E,A             ; To DE (D is 0)
1963:13576+10	0D5C  21DF02  	        LD      HL,PRITAB       ; Precedence table
1964:13586+11	0D5F  19      	        ADD     HL,DE           ; To the operator concerned
1965:13597+4	0D60  78      	        LD      A,B             ; Last operator precedence
1966:13601+7	0D61  56      	        LD      D,(HL)          ; Get evaluation precedence
1967:13608+4	0D62  BA      	        CP      D               ; Compare with eval precedence
1968:13612+5+6	0D63  D0      	        RET     NC              ; Exit if higher precedence
1969:13617+6	0D64  23      	        INC     HL              ; Point to routine address
1970:13623+17	0D65  CDF90C  	        CALL    TSTNUM          ; Make sure it's a number
1971:				
1972:13640+11	0D68  C5      	STKTHS: PUSH    BC              ; Save last precedence & token
1973:13651+10	0D69  01170D  	        LD      BC,EVAL3        ; Where to go on prec' break
1974:13661+11	0D6C  C5      	        PUSH    BC              ; Save on stack for return
1975:13672+20	0D6D  ED4BBE1E	        LD      BC,(FPREG)      ; LSB,NLSB of FPREG
1976:13692+11	0D71  C5      	        PUSH    BC              ; Stack them
1977:13703+20	0D72  ED4BC01E	        LD      BC,(FPREG+2)    ; MSB and exponent of FPREG
1978:13723+11	0D76  C5      	        PUSH    BC              ; Stack them
1979:13734+7	0D77  4E      	        LD      C,(HL)          ; Get LSB of routine address
1980:13741+6	0D78  23      	        INC     HL
1981:13747+7	0D79  46      	        LD      B,(HL)          ; Get MSB of routine address
1982:13754+6	0D7A  23      	        INC     HL
1983:13760+11	0D7B  C5      	        PUSH    BC              ; Save routine address
1984:13771+16	0D7C  2A9F1E  	        LD      HL,(CUROPR)     ; Address of current operator
1985:13787+10	0D7F  C30B0D  	        JP      EVAL1           ; Loop until prec' break
1986:				
1987:13797+4	0D82  AF      	OPRND:  XOR     A               ; Get operand routine
1988:13801+13	0D83  32871E  	        LD      (TYPE),A        ; Set numeric expected
1989:13814+17	0D86  CD4F08  	        CALL    GETCHR          ; Get next character
1990:13831+7	0D89  1E24    	        LD      E,MO            ; ?MO Error
1991:13838+10	0D8B  CAFF03  	        JP      Z,ERROR         ; No operand - Error
1992:13848+10	0D8E  DA3718  	        JP      C,ASCTFP        ; Number - Get value
1993:13858+17	0D91  CDED08  	        CALL    CHKLTR          ; See if a letter
1994:13875+10	0D94  D2EA0D  	        JP      NC,CONVAR       ; Letter - Find variable
1995:13885+7	0D97  FEA9    	        CP      ZPLUS           ; '+' Token ?
1996:13892+10	0D99  CA820D  	        JP      Z,OPRND         ; Yes - Look for operand
1997:13902+7	0D9C  FE2E    	        CP      '.'             ; '.' ?
1998:13909+10	0D9E  CA3718  	        JP      Z,ASCTFP        ; Yes - Create FP number
1999:13919+7	0DA1  FEAA    	        CP      ZMINUS          ; '-' Token ?
2000:13926+10	0DA3  CAD90D  	        JP      Z,MINUS         ; Yes - Do minus
2001:13936+7	0DA6  FE22    	        CP      '"'             ; Literal string ?
2002:13943+10	0DA8  CAB711  	        JP      Z,QTSTR         ; Get string terminated by '"'
2003:13953+7	0DAB  FEA7    	        CP      ZNOT            ; "NOT" Token ?
2004:13960+10	0DAD  CAD00E  	        JP      Z,EVNOT         ; Yes - Eval NOT expression
2005:13970+7	0DB0  FEA4    	        CP      ZFN             ; "FN" Token ?
2006:13977+10	0DB2  CA1311  	        JP      Z,DOFN          ; Yes - Do FN routine
2007:13987+7	0DB5  FE26    	        CP      '&'             ; &H = HEX, &B = BINARY
2008:13994+10	0DB7  C2CC0D  	        JP      NZ,NOTAMP       ; No - Skip to functions
2009:14004+17	0DBA  CD4F08  	        CALL    GETCHR          ; Get next character
2010:14021+7	0DBD  FE48    	        CP      'H'             ; Hex number indicated? [Searle function added]
2011:14028+10	0DBF  CA431D  	        JP      Z,HEXTFP        ; Convert Hex to FPREG
2012:14038+7	0DC2  FE42    	        CP      'B'             ; Binary number indicated? [Searle function added]
2013:14045+10	0DC4  CAB31D  	        JP      Z,BINTFP        ; Convert Bin to FPREG
2014:14055+7	0DC7  1E02    	        LD      E,SN            ; If neither then a ?SN Error
2015:14062+10	0DC9  CAFF03  	        JP      Z,ERROR         ; 
2016:14072+7	0DCC  D6B3    	NOTAMP: SUB     ZSGN            ; Is it a function?
2017:14079+10	0DCE  D2FB0D  	        JP      NC,FNOFST       ; Yes - Evaluate function
2018:14089+17	0DD1  CD040D  	EVLPAR: CALL    OPNPAR          ; Evaluate expression in "()"
2019:14106+17	0DD4  CDBC06  	        CALL    CHKSYN          ; Make sure ")" follows
2020:     -	0DD7  29      	        .BYTE   ")"
2021:14123+10	0DD8  C9      	        RET
2022:				
2023:14133+7	0DD9  167D    	MINUS:  LD      D,7DH           ; '-' precedence
2024:14140+17	0DDB  CD0B0D  	        CALL    EVAL1           ; Evaluate until prec' break
2025:14157+16	0DDE  2AAA1E  	        LD      HL,(NXTOPR)     ; Get next operator address
2026:14173+11	0DE1  E5      	        PUSH    HL              ; Save next operator address
2027:14184+17	0DE2  CD6817  	        CALL    INVSGN          ; Negate value
2028:14201+17	0DE5  CDF90C  	RETNUM: CALL    TSTNUM          ; Make sure it's a number
2029:14218+10	0DE8  E1      	        POP     HL              ; Restore next operator address
2030:14228+10	0DE9  C9      	        RET
2031:				
2032:14238+17	0DEA  CDF50E  	CONVAR: CALL    GETVAR          ; Get variable address to DE
2033:14255+11	0DED  E5      	FRMEVL: PUSH    HL              ; Save code string address
2034:14266+4	0DEE  EB      	        EX      DE,HL           ; Variable address to HL
2035:14270+16	0DEF  22BE1E  	        LD      (FPREG),HL      ; Save address of variable
2036:14286+13	0DF2  3A871E  	        LD      A,(TYPE)        ; Get type
2037:14299+4	0DF5  B7      	        OR      A               ; Numeric?
2038:14303+10+7	0DF6  CC7D17  	        CALL    Z,PHLTFP        ; Yes - Move contents to FPREG
2039:14313+10	0DF9  E1      	        POP     HL              ; Restore code string address
2040:14323+10	0DFA  C9      	        RET
2041:				
2042:14333+7	0DFB  0600    	FNOFST: LD      B,0             ; Get address of function
2043:14340+4	0DFD  07      	        RLCA                    ; Double function offset
2044:14344+4	0DFE  4F      	        LD      C,A             ; BC = Offset in function table
2045:14348+11	0DFF  C5      	        PUSH    BC              ; Save adjusted token value
2046:14359+17	0E00  CD4F08  	        CALL    GETCHR          ; Get next character
2047:14376+4	0E03  79      	        LD      A,C             ; Get adjusted token value
2048:14380+7	0E04  FE2F    	        CP      2*(ZLEFT-ZSGN)-1; Adj' LEFT$,RIGHT$ or MID$ ?
2049:14387+10	0E06  DA220E  	        JP      C,FNVAL         ; No - Do function
2050:14397+17	0E09  CD040D  	        CALL    OPNPAR          ; Evaluate expression  (X,...
2051:14414+17	0E0C  CDBC06  	        CALL    CHKSYN          ; Make sure ',' follows
2052:     -	0E0F  2C      	        .BYTE   ','
2053:14431+17	0E10  CDFA0C  	        CALL    TSTSTR          ; Make sure it's a string
2054:14448+4	0E13  EB      	        EX      DE,HL           ; Save code string address
2055:14452+16	0E14  2ABE1E  	        LD      HL,(FPREG)      ; Get address of string
2056:14468+19	0E17  E3      	        EX      (SP),HL         ; Save address of string
2057:14487+11	0E18  E5      	        PUSH    HL              ; Save adjusted token value
2058:14498+4	0E19  EB      	        EX      DE,HL           ; Restore code string address
2059:14502+17	0E1A  CDA114  	        CALL    GETINT          ; Get integer 0-255
2060:14519+4	0E1D  EB      	        EX      DE,HL           ; Save code string address
2061:14523+19	0E1E  E3      	        EX      (SP),HL         ; Save integer,HL = adj' token
2062:14542+10	0E1F  C32A0E  	        JP      GOFUNC          ; Jump to string function
2063:				
2064:14552+17	0E22  CDD10D  	FNVAL:  CALL    EVLPAR          ; Evaluate expression
2065:14569+19	0E25  E3      	        EX      (SP),HL         ; HL = Adjusted token value
2066:14588+10	0E26  11E50D  	        LD      DE,RETNUM       ; Return number from function
2067:14598+11	0E29  D5      	        PUSH    DE              ; Save on stack
2068:14609+10	0E2A  015901  	GOFUNC: LD      BC,FNCTAB       ; Function routine addresses
2069:14619+11	0E2D  09      	        ADD     HL,BC           ; Point to right address
2070:14630+7	0E2E  4E      	        LD      C,(HL)          ; Get LSB of address
2071:14637+6	0E2F  23      	        INC     HL              ;
2072:14643+7	0E30  66      	        LD      H,(HL)          ; Get MSB of address
2073:14650+4	0E31  69      	        LD      L,C             ; Address to HL
2074:14654+4	0E32  E9      	        JP      (HL)            ; Jump to function
2075:				
2076:14658+4	0E33  15      	SGNEXP: DEC     D               ; Dee to flag negative exponent
2077:14662+7	0E34  FEAA    	        CP      ZMINUS          ; '-' token ?
2078:14669+5+6	0E36  C8      	        RET     Z               ; Yes - Return
2079:14674+7	0E37  FE2D    	        CP      '-'             ; '-' ASCII ?
2080:14681+5+6	0E39  C8      	        RET     Z               ; Yes - Return
2081:14686+4	0E3A  14      	        INC     D               ; Inc to flag positive exponent
2082:14690+7	0E3B  FE2B    	        CP      '+'             ; '+' ASCII ?
2083:14697+5+6	0E3D  C8      	        RET     Z               ; Yes - Return
2084:14702+7	0E3E  FEA9    	        CP      ZPLUS           ; '+' token ?
2085:14709+5+6	0E40  C8      	        RET     Z               ; Yes - Return
2086:14714+6	0E41  2B      	        DEC     HL              ; DEC 'cos GETCHR INCs
2087:14720+10	0E42  C9      	        RET                     ; Return "NZ"
2088:				
2089:     -	0E43  F6      	POR:    .BYTE   0F6H            ; Flag "OR"
2090:14730+4	0E44  AF      	PAND:   XOR     A               ; Flag "AND"
2091:14734+11	0E45  F5      	        PUSH    AF              ; Save "AND" / "OR" flag
2092:14745+17	0E46  CDF90C  	        CALL    TSTNUM          ; Make sure it's a number
2093:14762+17	0E49  CD0109  	        CALL    DEINT           ; Get integer -32768 to 32767
2094:14779+10	0E4C  F1      	        POP     AF              ; Restore "AND" / "OR" flag
2095:14789+4	0E4D  EB      	        EX      DE,HL           ; <- Get last
2096:14793+10	0E4E  C1      	        POP     BC              ; <-  value
2097:14803+19	0E4F  E3      	        EX      (SP),HL         ; <-  from
2098:14822+4	0E50  EB      	        EX      DE,HL           ; <-  stack
2099:14826+20	0E51  ED53BE1E	        LD      (FPREG),DE      ; Move last value to FPREG
2100:14846+20	0E55  ED43C01E	        LD      (FPREG+2),BC
2101:14866+11	0E59  F5      	        PUSH    AF              ; Save "AND" / "OR" flag
2102:14877+17	0E5A  CD0109  	        CALL    DEINT           ; Get integer -32768 to 32767
2103:14894+10	0E5D  F1      	        POP     AF              ; Restore "AND" / "OR" flag
2104:14904+10	0E5E  C1      	        POP     BC              ; Get value
2105:14914+4	0E5F  79      	        LD      A,C             ; Get LSB
2106:14918+10	0E60  21D110  	        LD      HL,ACPASS       ; Address of save AC as current
2107:14928+10	0E63  C26B0E  	        JP      NZ,POR1         ; Jump if OR
2108:14938+4	0E66  A3      	        AND     E               ; "AND" LSBs
2109:14942+4	0E67  4F      	        LD      C,A             ; Save LSB
2110:14946+4	0E68  78      	        LD      A,B             ; Get MBS
2111:14950+4	0E69  A2      	        AND     D               ; "AND" MSBs
2112:14954+4	0E6A  E9      	        JP      (HL)            ; Save AC as current (ACPASS)
2113:				
2114:14958+4	0E6B  B3      	POR1:   OR      E               ; "OR" LSBs
2115:14962+4	0E6C  4F      	        LD      C,A             ; Save LSB
2116:14966+4	0E6D  78      	        LD      A,B             ; Get MSB
2117:14970+4	0E6E  B2      	        OR      D               ; "OR" MSBs
2118:14974+4	0E6F  E9      	        JP      (HL)            ; Save AC as current (ACPASS)
2119:				
2120:14978+10	0E70  21820E  	TSTRED: LD      HL,CMPLOG       ; Logical compare routine
2121:14988+13	0E73  3A871E  	        LD      A,(TYPE)        ; Get data type
2122:15001+4	0E76  1F      	        RRA                     ; Carry set = string
2123:15005+4	0E77  7A      	        LD      A,D             ; Get last precedence value
2124:15009+4	0E78  17      	        RLA                     ; Times 2 plus carry
2125:15013+4	0E79  5F      	        LD      E,A             ; To E
2126:15017+7	0E7A  1664    	        LD      D,64H           ; Relational precedence
2127:15024+4	0E7C  78      	        LD      A,B             ; Get current precedence
2128:15028+4	0E7D  BA      	        CP      D               ; Compare with last
2129:15032+5+6	0E7E  D0      	        RET     NC              ; Eval if last was rel' or log'
2130:15037+10	0E7F  C3680D  	        JP      STKTHS          ; Stack this one and get next
2131:				
2132:     -	0E82  840E    	CMPLOG: .WORD   CMPLG1          ; Compare two values / strings
2133:15047+4	0E84  79      	CMPLG1: LD      A,C             ; Get data type
2134:15051+4	0E85  B7      	        OR      A
2135:15055+4	0E86  1F      	        RRA
2136:15059+10	0E87  C1      	        POP     BC              ; Get last expression to BCDE
2137:15069+10	0E88  D1      	        POP     DE
2138:15079+11	0E89  F5      	        PUSH    AF              ; Save status
2139:15090+17	0E8A  CDFB0C  	        CALL    CHKTYP          ; Check that types match
2140:15107+10	0E8D  21C60E  	        LD      HL,CMPRES       ; Result to comparison
2141:15117+11	0E90  E5      	        PUSH    HL              ; Save for RETurn
2142:15128+10	0E91  CAA717  	        JP      Z,CMPNUM        ; Compare values if numeric
2143:15138+4	0E94  AF      	        XOR     A               ; Compare two strings
2144:15142+13	0E95  32871E  	        LD      (TYPE),A        ; Set type to numeric
2145:15155+11	0E98  D5      	        PUSH    DE              ; Save string name
2146:15166+17	0E99  CD5613  	        CALL    GSTRCU          ; Get current string
2147:15183+7	0E9C  7E      	        LD      A,(HL)          ; Get length of string
2148:15190+6	0E9D  23      	        INC     HL
2149:15196+6	0E9E  23      	        INC     HL
2150:15202+7	0E9F  4E      	        LD      C,(HL)          ; Get LSB of address
2151:15209+6	0EA0  23      	        INC     HL
2152:15215+7	0EA1  46      	        LD      B,(HL)          ; Get MSB of address
2153:15222+10	0EA2  D1      	        POP     DE              ; Restore string name
2154:15232+11	0EA3  C5      	        PUSH    BC              ; Save address of string
2155:15243+11	0EA4  F5      	        PUSH    AF              ; Save length of string
2156:15254+17	0EA5  CD5A13  	        CALL    GSTRDE          ; Get second string
2157:15271+17	0EA8  CD8917  	        CALL    LOADFP          ; Get address of second string
2158:15288+10	0EAB  F1      	        POP     AF              ; Restore length of string 1
2159:15298+4	0EAC  57      	        LD      D,A             ; Length to D
2160:15302+10	0EAD  E1      	        POP     HL              ; Restore address of string 1
2161:15312+4	0EAE  7B      	CMPSTR: LD      A,E             ; Bytes of string 2 to do
2162:15316+4	0EAF  B2      	        OR      D               ; Bytes of string 1 to do
2163:15320+5+6	0EB0  C8      	        RET     Z               ; Exit if all bytes compared
2164:15325+4	0EB1  7A      	        LD      A,D             ; Get bytes of string 1 to do
2165:15329+7	0EB2  D601    	        SUB     1
2166:15336+5+6	0EB4  D8      	        RET     C               ; Exit if end of string 1
2167:15341+4	0EB5  AF      	        XOR     A
2168:15345+4	0EB6  BB      	        CP      E               ; Bytes of string 2 to do
2169:15349+4	0EB7  3C      	        INC     A
2170:15353+5+6	0EB8  D0      	        RET     NC              ; Exit if end of string 2
2171:15358+4	0EB9  15      	        DEC     D               ; Count bytes in string 1
2172:15362+4	0EBA  1D      	        DEC     E               ; Count bytes in string 2
2173:15366+7	0EBB  0A      	        LD      A,(BC)          ; Byte in string 2
2174:15373+7	0EBC  BE      	        CP      (HL)            ; Compare to byte in string 1
2175:15380+6	0EBD  23      	        INC     HL              ; Move up string 1
2176:15386+6	0EBE  03      	        INC     BC              ; Move up string 2
2177:15392+10	0EBF  CAAE0E  	        JP      Z,CMPSTR        ; Same - Try next bytes
2178:15402+4	0EC2  3F      	        CCF                     ; Flag difference (">" or "<")
2179:15406+10	0EC3  C34A17  	        JP      FLGDIF          ; "<" gives -1 , ">" gives +1
2180:				
2181:15416+4	0EC6  3C      	CMPRES: INC     A               ; Increment current value
2182:15420+4	0EC7  8F      	        ADC     A,A             ; Double plus carry
2183:15424+10	0EC8  C1      	        POP     BC              ; Get other value
2184:15434+4	0EC9  A0      	        AND     B               ; Combine them
2185:15438+7	0ECA  C6FF    	        ADD     A,-1            ; Carry set if different
2186:15445+4	0ECC  9F      	        SBC     A,A             ; 00 - Equal , FF - Different
2187:15449+10	0ECD  C35117  	        JP      FLGREL          ; Set current value & continue
2188:				
2189:15459+7	0ED0  165A    	EVNOT:  LD      D,5AH           ; Precedence value for "NOT"
2190:15466+17	0ED2  CD0B0D  	        CALL    EVAL1           ; Eval until precedence break
2191:15483+17	0ED5  CDF90C  	        CALL    TSTNUM          ; Make sure it's a number
2192:15500+17	0ED8  CD0109  	        CALL    DEINT           ; Get integer -32768 - 32767
2193:15517+4	0EDB  7B      	        LD      A,E             ; Get LSB
2194:15521+4	0EDC  2F      	        CPL                     ; Invert LSB
2195:15525+4	0EDD  4F      	        LD      C,A             ; Save "NOT" of LSB
2196:15529+4	0EDE  7A      	        LD      A,D             ; Get MSB
2197:15533+4	0EDF  2F      	        CPL                     ; Invert MSB
2198:15537+17	0EE0  CDD110  	        CALL    ACPASS          ; Save AC as current
2199:15554+10	0EE3  C1      	        POP     BC              ; Clean up stack
2200:15564+10	0EE4  C3170D  	        JP      EVAL3           ; Continue evaluation
2201:				
2202:15574+6	0EE7  2B      	DIMRET: DEC     HL              ; DEC 'cos GETCHR INCs
2203:15580+17	0EE8  CD4F08  	        CALL    GETCHR          ; Get next character
2204:15597+5+6	0EEB  C8      	        RET     Z               ; End of DIM statement
2205:15602+17	0EEC  CDBC06  	        CALL    CHKSYN          ; Make sure ',' follows
2206:     -	0EEF  2C      	        .BYTE   ','
2207:15619+10	0EF0  01E70E  	DIM:    LD      BC,DIMRET       ; Return to "DIMRET"
2208:15629+11	0EF3  C5      	        PUSH    BC              ; Save on stack
2209:     -	0EF4  F6      	        .BYTE   0F6H            ; Flag "Create" variable
2210:15640+4	0EF5  AF      	GETVAR: XOR     A               ; Find variable address,to DE
2211:15644+13	0EF6  32861E  	        LD      (LCRFLG),A      ; Set locate / create flag
2212:15657+7	0EF9  46      	        LD      B,(HL)          ; Get First byte of name
2213:15664+17	0EFA  CDED08  	GTFNAM: CALL    CHKLTR          ; See if a letter
2214:15681+10	0EFD  DAEB03  	        JP      C,SNERR         ; ?SN Error if not a letter
2215:15691+4	0F00  AF      	        XOR     A
2216:15695+4	0F01  4F      	        LD      C,A             ; Clear second byte of name
2217:15699+13	0F02  32871E  	        LD      (TYPE),A        ; Set type to numeric
2218:15712+17	0F05  CD4F08  	        CALL    GETCHR          ; Get next character
2219:15729+10	0F08  DA110F  	        JP      C,SVNAM2        ; Numeric - Save in name
2220:15739+17	0F0B  CDED08  	        CALL    CHKLTR          ; See if a letter
2221:15756+10	0F0E  DA1E0F  	        JP      C,CHARTY        ; Not a letter - Check type
2222:15766+4	0F11  4F      	SVNAM2: LD      C,A             ; Save second byte of name
2223:15770+17	0F12  CD4F08  	ENDNAM: CALL    GETCHR          ; Get next character
2224:15787+10	0F15  DA120F  	        JP      C,ENDNAM        ; Numeric - Get another
2225:15797+17	0F18  CDED08  	        CALL    CHKLTR          ; See if a letter
2226:15814+10	0F1B  D2120F  	        JP      NC,ENDNAM       ; Letter - Get another
2227:15824+7	0F1E  D624    	CHARTY: SUB     '$'             ; String variable?
2228:15831+10	0F20  C22D0F  	        JP      NZ,NOTSTR       ; No - Numeric variable
2229:15841+4	0F23  3C      	        INC     A               ; A = 1 (string type)
2230:15845+13	0F24  32871E  	        LD      (TYPE),A        ; Set type to string
2231:15858+4	0F27  0F      	        RRCA                    ; A = 80H , Flag for string
2232:15862+4	0F28  81      	        ADD     A,C             ; 2nd byte of name has bit 7 on
2233:15866+4	0F29  4F      	        LD      C,A             ; Resave second byte on name
2234:15870+17	0F2A  CD4F08  	        CALL    GETCHR          ; Get next character
2235:15887+13	0F2D  3AA51E  	NOTSTR: LD      A,(FORFLG)      ; Array name needed ?
2236:15900+4	0F30  3D      	        DEC     A
2237:15904+10	0F31  CAE80F  	        JP      Z,ARLDSV        ; Yes - Get array name
2238:15914+10	0F34  F23D0F  	        JP      P,NSCFOR        ; No array with "FOR" or "FN"
2239:15924+7	0F37  7E      	        LD      A,(HL)          ; Get byte again
2240:15931+7	0F38  D628    	        SUB     '('             ; Subscripted variable?
2241:15938+10	0F3A  CAC00F  	        JP      Z,SBSCPT        ; Yes - Sort out subscript
2242:				
2243:15948+4	0F3D  AF      	NSCFOR: XOR     A               ; Simple variable
2244:15952+13	0F3E  32A51E  	        LD      (FORFLG),A      ; Clear "FOR" flag
2245:15965+11	0F41  E5      	        PUSH    HL              ; Save code string address
2246:15976+4	0F42  50      	        LD      D,B             ; DE = Variable name to find
2247:15980+4	0F43  59      	        LD      E,C
2248:15984+16	0F44  2AB81E  	        LD      HL,(FNRGNM)     ; FN argument name
2249:16000+4	0F47  7C      	        LD      A,H             ; Is it the FN argument?
2250:16004+4	0F48  92      	        SUB     D               ; Compare with D
2251:16008+10	0F49  C24E0F  	        JP      NZ,$+5          ; Different - Exit
2252:16018+4	0F4C  7D      	        LD      A,L             ; Get L
2253:16022+4	0F4D  93      	        SUB     E               ; Compare with E
2254:16026+10	0F4E  11BA1E  	        LD      DE,FNARG        ; Point to argument value
2255:16036+10	0F51  CA7513  	        JP      Z,POPHRT        ; Yes - Return FN argument value
2256:16046+16	0F54  2AB21E  	        LD      HL,(VAREND)     ; End of variables
2257:16062+4	0F57  EB      	        EX      DE,HL           ; Address of end of search
2258:16066+16	0F58  2AB01E  	        LD      HL,(PROGND)     ; Start of variables address
2259:				
2260:16082+4	0F5B  7C      	FNDVAR: LD      A,H             ; End of variable list table?
2261:16086+4	0F5C  92      	        SUB     D               ; Compare with D        
2262:16090+10	0F5D  C2620F  	        JP      NZ,$+5          ; Different - Exit
2263:16100+4	0F60  7D      	        LD      A,L             ; Get L
2264:16104+4	0F61  93      	        SUB     E               ; Compare with E
2265:16108+10	0F62  CA780F  	        JP      Z,CFEVAL        ; Yes - Called from EVAL?
2266:16118+4	0F65  79      	        LD      A,C             ; Get second byte of name
2267:16122+7	0F66  96      	        SUB     (HL)            ; Compare with name in list
2268:16129+6	0F67  23      	        INC     HL              ; Move on to first byte
2269:16135+10	0F68  C26D0F  	        JP      NZ,FNTHR        ; Different - Find another
2270:16145+4	0F6B  78      	        LD      A,B             ; Get first byte of name
2271:16149+7	0F6C  96      	        SUB     (HL)            ; Compare with name in list
2272:16156+6	0F6D  23      	FNTHR:  INC     HL              ; Move on to LSB of value
2273:16162+10	0F6E  CAB20F  	        JP      Z,RETADR        ; Found - Return address
2274:16172+6	0F71  23      	        INC     HL              ; <- Skip
2275:16178+6	0F72  23      	        INC     HL              ; <- over
2276:16184+6	0F73  23      	        INC     HL              ; <- F.P.
2277:16190+6	0F74  23      	        INC     HL              ; <- value
2278:16196+10	0F75  C35B0F  	        JP      FNDVAR          ; Keep looking
2279:				
2280:16206+10	0F78  E1      	CFEVAL: POP     HL              ; Restore code string address
2281:16216+19	0F79  E3      	        EX      (SP),HL         ; Get return address
2282:16235+11	0F7A  D5      	        PUSH    DE              ; Save address of variable
2283:16246+10	0F7B  11ED0D  	        LD      DE,FRMEVL       ; Return address in EVAL
2284:16256+4	0F7E  7C      	        LD      A,H             ; Called from EVAL ?
2285:16260+4	0F7F  92      	        SUB     D               ; Compare with D
2286:16264+7+5	0F80  2002    	        JR      NZ,$+4          ; Different - Exit
2287:16271+4	0F82  7D      	        LD      A,L             ; Get L
2288:16275+4	0F83  93      	        SUB     E               ; Compare with E
2289:16279+10	0F84  D1      	        POP     DE              ; Restore address of variable
2290:16289+10	0F85  CAB50F  	        JP      Z,RETNUL        ; Yes - Return null variable
2291:16299+19	0F88  E3      	        EX      (SP),HL         ; Put back return
2292:16318+11	0F89  E5      	        PUSH    HL              ; Save code string address
2293:16329+11	0F8A  C5      	        PUSH    BC              ; Save variable name
2294:16340+10	0F8B  010600  	        LD      BC,6            ; 2 byte name plus 4 byte data
2295:16350+16	0F8E  2AB41E  	        LD      HL,(ARREND)     ; End of arrays
2296:16366+11	0F91  E5      	        PUSH    HL              ; Save end of arrays
2297:16377+11	0F92  09      	        ADD     HL,BC           ; Move up 6 bytes
2298:16388+10	0F93  C1      	        POP     BC              ; Source address in BC
2299:16398+11	0F94  E5      	        PUSH    HL              ; Save new end address
2300:16409+17	0F95  CDB403  	        CALL    MOVUP           ; Move arrays up
2301:16426+10	0F98  E1      	        POP     HL              ; Restore new end address
2302:16436+16	0F99  22B41E  	        LD      (ARREND),HL     ; Set new end address
2303:16452+4	0F9C  60      	        LD      H,B             ; End of variables to HL
2304:16456+4	0F9D  69      	        LD      L,C
2305:16460+16	0F9E  22B21E  	        LD      (VAREND),HL     ; Set new end address
2306:				
2307:16476+6	0FA1  2B      	ZEROLP: DEC     HL              ; Back through to zero variable
2308:16482+10	0FA2  3600    	        LD      (HL),0          ; Zero byte in variable
2309:16492+4	0FA4  7C      	        LD      A,H             ; Done them all?
2310:16496+4	0FA5  92      	        SUB     D               ; Compare with D
2311:16500+7+5	0FA6  2002    	        JR      NZ,$+4          ; Different - Exit
2312:16507+4	0FA8  7D      	        LD      A,L             ; Get L
2313:16511+4	0FA9  93      	        SUB     E               ; Compare with E
2314:16515+10	0FAA  C2A10F  	        JP      NZ,ZEROLP       ; No - Keep on going
2315:16525+10	0FAD  D1      	        POP     DE              ; Get variable name
2316:16535+7	0FAE  73      	        LD      (HL),E          ; Store second character
2317:16542+6	0FAF  23      	        INC     HL
2318:16548+7	0FB0  72      	        LD      (HL),D          ; Store first character
2319:16555+6	0FB1  23      	        INC     HL
2320:16561+4	0FB2  EB      	RETADR: EX      DE,HL           ; Address of variable in DE
2321:16565+10	0FB3  E1      	        POP     HL              ; Restore code string address
2322:16575+10	0FB4  C9      	        RET
2323:				
2324:16585+13	0FB5  32C11E  	RETNUL: LD      (FPEXP),A       ; Set result to zero
2325:16598+10	0FB8  218103  	        LD      HL,ZERBYT       ; Also set a null string
2326:16608+16	0FBB  22BE1E  	        LD      (FPREG),HL      ; Save for EVAL
2327:16624+10	0FBE  E1      	        POP     HL              ; Restore code string address
2328:16634+10	0FBF  C9      	        RET
2329:				
2330:16644+11	0FC0  E5      	SBSCPT: PUSH    HL              ; Save code string address
2331:16655+16	0FC1  2A861E  	        LD      HL,(LCRFLG)     ; Locate/Create and Type
2332:16671+19	0FC4  E3      	        EX      (SP),HL         ; Save and get code string
2333:16690+4	0FC5  57      	        LD      D,A             ; Zero number of dimensions
2334:16694+11	0FC6  D5      	SCPTLP: PUSH    DE              ; Save number of dimensions
2335:16705+11	0FC7  C5      	        PUSH    BC              ; Save array name
2336:16716+17	0FC8  CDF508  	        CALL    FPSINT          ; Get subscript (0-32767)
2337:16733+10	0FCB  C1      	        POP     BC              ; Restore array name
2338:16743+10	0FCC  F1      	        POP     AF              ; Get number of dimensions
2339:16753+4	0FCD  EB      	        EX      DE,HL
2340:16757+19	0FCE  E3      	        EX      (SP),HL         ; Save subscript value
2341:16776+11	0FCF  E5      	        PUSH    HL              ; Save LCRFLG and TYPE
2342:16787+4	0FD0  EB      	        EX      DE,HL
2343:16791+4	0FD1  3C      	        INC     A               ; Count dimensions
2344:16795+4	0FD2  57      	        LD      D,A             ; Save in D
2345:16799+7	0FD3  7E      	        LD      A,(HL)          ; Get next byte in code string
2346:16806+7	0FD4  FE2C    	        CP      ','             ; Comma (more to come)?
2347:16813+10	0FD6  CAC60F  	        JP      Z,SCPTLP        ; Yes - More subscripts
2348:16823+17	0FD9  CDBC06  	        CALL    CHKSYN          ; Make sure ")" follows
2349:     -	0FDC  29      	        .BYTE   ")"
2350:16840+16	0FDD  22AA1E  	        LD      (NXTOPR),HL     ; Save code string address
2351:16856+10	0FE0  E1      	        POP     HL              ; Get LCRFLG and TYPE
2352:16866+16	0FE1  22861E  	        LD      (LCRFLG),HL     ; Restore Locate/create & type
2353:16882+7	0FE4  1E00    	        LD      E,0             ; Flag not CSAVE* or CLOAD*
2354:16889+11	0FE6  D5      	        PUSH    DE              ; Save number of dimensions (D)
2355:     -	0FE7  11      	        .BYTE   11H             ; Skip "PUSH HL" and "PUSH AF'
2356:				
2357:16900+11	0FE8  E5      	ARLDSV: PUSH    HL              ; Save code string address
2358:16911+11	0FE9  F5      	        PUSH    AF              ; A = 00 , Flags set = Z,N
2359:16922+16	0FEA  2AB21E  	        LD      HL,(VAREND)     ; Start of arrays
2360:     -	0FED  3E      	        .BYTE   3EH             ; Skip "ADD HL,DE"
2361:16938+11	0FEE  19      	FNDARY: ADD     HL,DE           ; Move to next array start
2362:16949+20	0FEF  ED5BB41E	        LD      DE,(ARREND)     ; End of arrays
2363:16969+4	0FF3  7C      	        LD      A,H             ; End of arrays found?
2364:16973+4	0FF4  92      	        SUB     D               ; Compare with D
2365:16977+10	0FF5  C2FA0F  	        JP      NZ,$+5          ; Different - Exit
2366:16987+4	0FF8  7D      	        LD      A,L             ; Get L
2367:16991+4	0FF9  93      	        SUB     E               ; Compare with E
2368:16995+10	0FFA  CA2310  	        JP      Z,CREARY        ; Yes - Create array
2369:17005+7	0FFD  7E      	        LD      A,(HL)          ; Get second byte of name
2370:17012+4	0FFE  B9      	        CP      C               ; Compare with name given
2371:17016+6	0FFF  23      	        INC     HL              ; Move on
2372:17022+10	1000  C20510  	        JP      NZ,NXTARY       ; Different - Find next array
2373:17032+7	1003  7E      	        LD      A,(HL)          ; Get first byte of name
2374:17039+4	1004  B8      	        CP      B               ; Compare with name given
2375:17043+6	1005  23      	NXTARY: INC     HL              ; Move on
2376:17049+7	1006  5E      	        LD      E,(HL)          ; Get LSB of next array address
2377:17056+6	1007  23      	        INC     HL
2378:17062+7	1008  56      	        LD      D,(HL)          ; Get MSB of next array address
2379:17069+6	1009  23      	        INC     HL
2380:17075+10	100A  C2EE0F  	        JP      NZ,FNDARY       ; Not found - Keep looking
2381:17085+13	100D  3A861E  	        LD      A,(LCRFLG)      ; Found Locate or Create it?
2382:17098+4	1010  B7      	        OR      A
2383:17102+10	1011  C2F403  	        JP      NZ,DDERR        ; Create - ?DD Error
2384:17112+10	1014  F1      	        POP     AF              ; Locate - Get number of dim'ns
2385:17122+4	1015  44      	        LD      B,H             ; BC Points to array dim'ns
2386:17126+4	1016  4D      	        LD      C,L
2387:17130+10	1017  CA7513  	        JP      Z,POPHRT        ; Jump if array load/save
2388:17140+7	101A  96      	        SUB     (HL)            ; Same number of dimensions?
2389:17147+10	101B  CA8410  	        JP      Z,FINDEL        ; Yes - Find element
2390:17157+7	101E  1E10    	BSERR:  LD      E,BS            ; ?BS Error
2391:17164+10	1020  C3FF03  	        JP      ERROR           ; Output error
2392:				
2393:17174+10	1023  110400  	CREARY: LD      DE,4            ; 4 Bytes per entry
2394:17184+10	1026  F1      	        POP     AF              ; Array to save or 0 dim'ns?
2395:17194+10	1027  CA1609  	        JP      Z,FCERR         ; Yes - ?FC Error
2396:17204+7	102A  71      	        LD      (HL),C          ; Save second byte of name
2397:17211+6	102B  23      	        INC     HL
2398:17217+7	102C  70      	        LD      (HL),B          ; Save first byte of name
2399:17224+6	102D  23      	        INC     HL
2400:17230+4	102E  4F      	        LD      C,A             ; Number of dimensions to C
2401:17234+17	102F  CDC803  	        CALL    CHKSTK          ; Check if enough memory
2402:17251+6	1032  23      	        INC     HL              ; Point to number of dimensions
2403:17257+6	1033  23      	        INC     HL
2404:17263+16	1034  229F1E  	        LD      (CUROPR),HL     ; Save address of pointer
2405:17279+7	1037  71      	        LD      (HL),C          ; Set number of dimensions
2406:17286+6	1038  23      	        INC     HL
2407:17292+13	1039  3A861E  	        LD      A,(LCRFLG)      ; Locate of Create?
2408:17305+4	103C  17      	        RLA                     ; Carry set = Create
2409:17309+4	103D  79      	        LD      A,C             ; Get number of dimensions
2410:17313+10	103E  010B00  	CRARLP: LD      BC,10+1         ; Default dimension size 10
2411:17323+10	1041  D24610  	        JP      NC,DEFSIZ       ; Locate - Set default size
2412:17333+10	1044  C1      	        POP     BC              ; Get specified dimension size
2413:17343+6	1045  03      	        INC     BC              ; Include zero element
2414:17349+7	1046  71      	DEFSIZ: LD      (HL),C          ; Save LSB of dimension size
2415:17356+6	1047  23      	        INC     HL
2416:17362+7	1048  70      	        LD      (HL),B          ; Save MSB of dimension size
2417:17369+6	1049  23      	        INC     HL
2418:17375+11	104A  F5      	        PUSH    AF              ; Save num' of dim'ns an status
2419:17386+11	104B  E5      	        PUSH    HL              ; Save address of dim'n size
2420:17397+17	104C  CD1D18  	        CALL    MLDEBC          ; Multiply DE by BC to HL
2421:17414+4	104F  EB      	        EX      DE,HL           ; amount of mem needed (to DE)
2422:17418+10	1050  E1      	        POP     HL              ; Restore address of dimension
2423:17428+10	1051  F1      	        POP     AF              ; Restore number of dimensions
2424:17438+4	1052  3D      	        DEC     A               ; Count them
2425:17442+10	1053  C23E10  	        JP      NZ,CRARLP       ; Do next dimension if more
2426:17452+11	1056  F5      	        PUSH    AF              ; Save locate/create flag
2427:17463+4	1057  42      	        LD      B,D             ; MSB of memory needed
2428:17467+4	1058  4B      	        LD      C,E             ; LSB of memory needed
2429:17471+4	1059  EB      	        EX      DE,HL
2430:17475+11	105A  19      	        ADD     HL,DE           ; Add bytes to array start
2431:17486+10	105B  DAE003  	        JP      C,OMERR         ; Too big - Error
2432:17496+17	105E  CDD103  	        CALL    ENFMEM          ; See if enough memory
2433:17513+16	1061  22B41E  	        LD      (ARREND),HL     ; Save new end of array
2434:				
2435:17529+6	1064  2B      	ZERARY: DEC     HL              ; Back through array data
2436:17535+10	1065  3600    	        LD      (HL),0          ; Set array element to zero
2437:17545+4	1067  7C      	        LD      A,H             ; All elements zeroed?
2438:17549+4	1068  92      	        SUB     D               ; Compare with D
2439:17553+7+5	1069  2002    	        JR      NZ,$+4          ; Different - Exit
2440:17560+4	106B  7D      	        LD      A,L             ; Get L
2441:17564+4	106C  93      	        SUB     E               ; Compare with E
2442:17568+10	106D  C26410  	        JP      NZ,ZERARY       ; No - Keep on going
2443:17578+6	1070  03      	        INC     BC              ; Number of bytes + 1
2444:17584+4	1071  57      	        LD      D,A             ; A=0
2445:17588+16	1072  2A9F1E  	        LD      HL,(CUROPR)     ; Get address of array
2446:17604+7	1075  5E      	        LD      E,(HL)          ; Number of dimensions
2447:17611+4	1076  EB      	        EX      DE,HL           ; To HL
2448:17615+11	1077  29      	        ADD     HL,HL           ; Two bytes per dimension size
2449:17626+11	1078  09      	        ADD     HL,BC           ; Add number of bytes
2450:17637+4	1079  EB      	        EX      DE,HL           ; Bytes needed to DE
2451:17641+6	107A  2B      	        DEC     HL
2452:17647+6	107B  2B      	        DEC     HL
2453:17653+7	107C  73      	        LD      (HL),E          ; Save LSB of bytes needed
2454:17660+6	107D  23      	        INC     HL
2455:17666+7	107E  72      	        LD      (HL),D          ; Save MSB of bytes needed
2456:17673+6	107F  23      	        INC     HL
2457:17679+10	1080  F1      	        POP     AF              ; Locate / Create?
2458:17689+10	1081  DAAC10  	        JP      C,ENDDIM        ; A is 0 , End if create
2459:17699+4	1084  47      	FINDEL: LD      B,A             ; Find array element
2460:17703+4	1085  4F      	        LD      C,A
2461:17707+7	1086  7E      	        LD      A,(HL)          ; Number of dimensions
2462:17714+6	1087  23      	        INC     HL
2463:     -	1088  16      	        .BYTE   16H             ; Skip "POP HL"
2464:17720+10	1089  E1      	FNDELP: POP     HL              ; Address of next dim' size
2465:17730+7	108A  5E      	        LD      E,(HL)          ; Get LSB of dim'n size
2466:17737+6	108B  23      	        INC     HL
2467:17743+7	108C  56      	        LD      D,(HL)          ; Get MSB of dim'n size
2468:17750+6	108D  23      	        INC     HL
2469:17756+19	108E  E3      	        EX      (SP),HL         ; Save address - Get index
2470:17775+11	108F  F5      	        PUSH    AF              ; Save number of dim'ns
2471:17786+4	1090  7C      	        LD      A,H             ; Dimension too large?
2472:17790+4	1091  92      	        SUB     D               ; Compare with D
2473:17794+10	1092  C29710  	        JP      NZ,$+5          ; Different - Exit
2474:17804+4	1095  7D      	        LD      A,L             ; Get L
2475:17808+4	1096  93      	        SUB     E               ; Compare with E
2476:17812+10	1097  D21E10  	        JP      NC,BSERR        ; Yes - ?BS Error
2477:17822+11	109A  E5      	        PUSH    HL              ; Save index
2478:17833+17	109B  CD1D18  	        CALL    MLDEBC          ; Multiply previous by size
2479:17850+10	109E  D1      	        POP     DE              ; Index supplied to DE
2480:17860+11	109F  19      	        ADD     HL,DE           ; Add index to pointer
2481:17871+10	10A0  F1      	        POP     AF              ; Number of dimensions
2482:17881+4	10A1  3D      	        DEC     A               ; Count them
2483:17885+4	10A2  44      	        LD      B,H             ; MSB of pointer
2484:17889+4	10A3  4D      	        LD      C,L             ; LSB of pointer
2485:17893+10	10A4  C28910  	        JP      NZ,FNDELP       ; More - Keep going
2486:17903+11	10A7  29      	        ADD     HL,HL           ; 4 Bytes per element
2487:17914+11	10A8  29      	        ADD     HL,HL
2488:17925+10	10A9  C1      	        POP     BC              ; Start of array
2489:17935+11	10AA  09      	        ADD     HL,BC           ; Point to element
2490:17946+4	10AB  EB      	        EX      DE,HL           ; Address of element to DE
2491:17950+16	10AC  2AAA1E  	ENDDIM: LD      HL,(NXTOPR)     ; Got code string address
2492:17966+10	10AF  C9      	        RET
2493:				
2494:17976+16	10B0  2AB41E  	FRE:    LD      HL,(ARREND)     ; Start of free memory
2495:17992+4	10B3  EB      	        EX      DE,HL           ; To DE
2496:17996+10	10B4  210000  	        LD      HL,0            ; End of free memory
2497:18006+11	10B7  39      	        ADD     HL,SP           ; Current stack value
2498:18017+13	10B8  3A871E  	        LD      A,(TYPE)        ; Dummy argument type
2499:18030+4	10BB  B7      	        OR      A
2500:18034+10	10BC  CACC10  	        JP      Z,FRENUM        ; Numeric - Free variable space
2501:18044+17	10BF  CD5613  	        CALL    GSTRCU          ; Current string to pool
2502:18061+17	10C2  CD4812  	        CALL    GARBGE          ; Garbage collection
2503:18078+16	10C5  2A341E  	        LD      HL,(STRSPC)     ; Bottom of string space in use
2504:18094+4	10C8  EB      	        EX      DE,HL           ; To DE
2505:18098+16	10C9  2A9D1E  	        LD      HL,(STRBOT)     ; Bottom of string space
2506:18114+4	10CC  7D      	FRENUM: LD      A,L             ; Get LSB of end
2507:18118+4	10CD  93      	        SUB     E               ; Subtract LSB of beginning
2508:18122+4	10CE  4F      	        LD      C,A             ; Save difference if C
2509:18126+4	10CF  7C      	        LD      A,H             ; Get MSB of end
2510:18130+4	10D0  9A      	        SBC     A,D             ; Subtract MSB of beginning
2511:18134+4	10D1  41      	ACPASS: LD      B,C             ; Return integer AC
2512:18138+4	10D2  50      	ABPASS: LD      D,B             ; Return integer AB
2513:18142+7	10D3  1E00    	        LD      E,0
2514:18149+10	10D5  21871E  	        LD      HL,TYPE         ; Point to type
2515:18159+7	10D8  73      	        LD      (HL),E          ; Set type to numeric
2516:18166+7	10D9  0690    	        LD      B,80H+16        ; 16 bit integer
2517:18173+10	10DB  C35617  	        JP      RETINT          ; Return the integr
2518:				
2519:18183+13	10DE  3A851E  	POS:    LD      A,(CURPOS)      ; Get cursor position
2520:18196+4	10E1  47      	PASSA:  LD      B,A             ; Put A into AB
2521:18200+4	10E2  AF      	        XOR     A               ; Zero A
2522:18204+10	10E3  C3D210  	        JP      ABPASS          ; Return integer AB
2523:				
2524:18214+17	10E6  CD7111  	DEF:    CALL    CHEKFN          ; Get "FN" and name
2525:18231+17	10E9  CD6311  	        CALL    IDTEST          ; Test for illegal direct
2526:18248+10	10EC  01F009  	        LD      BC,DATA         ; To get next statement
2527:18258+11	10EF  C5      	        PUSH    BC              ; Save address for RETurn
2528:18269+11	10F0  D5      	        PUSH    DE              ; Save address of function ptr
2529:18280+17	10F1  CDBC06  	        CALL    CHKSYN          ; Make sure "(" follows
2530:     -	10F4  28      	        .BYTE   "("
2531:18297+17	10F5  CDF50E  	        CALL    GETVAR          ; Get argument variable name
2532:18314+11	10F8  E5      	        PUSH    HL              ; Save code string address
2533:18325+4	10F9  EB      	        EX      DE,HL           ; Argument address to HL
2534:18329+6	10FA  2B      	        DEC     HL
2535:18335+7	10FB  56      	        LD      D,(HL)          ; Get first byte of arg name
2536:18342+6	10FC  2B      	        DEC     HL
2537:18348+7	10FD  5E      	        LD      E,(HL)          ; Get second byte of arg name
2538:18355+10	10FE  E1      	        POP     HL              ; Restore code string address
2539:18365+17	10FF  CDF90C  	        CALL    TSTNUM          ; Make sure numeric argument
2540:18382+17	1102  CDBC06  	        CALL    CHKSYN          ; Make sure ")" follows
2541:     -	1105  29      	        .BYTE   ")"
2542:18399+17	1106  CDBC06  	        CALL    CHKSYN          ; Make sure "=" follows
2543:     -	1109  B1      	        .BYTE   ZEQUAL          ; "=" token
2544:18416+4	110A  44      	        LD      B,H             ; Code string address to BC
2545:18420+4	110B  4D      	        LD      C,L
2546:18424+19	110C  E3      	        EX      (SP),HL         ; Save code str , Get FN ptr
2547:18443+7	110D  71      	        LD      (HL),C          ; Save LSB of FN code string
2548:18450+6	110E  23      	        INC     HL
2549:18456+7	110F  70      	        LD      (HL),B          ; Save MSB of FN code string
2550:18463+10	1110  C3B011  	        JP      SVSTAD          ; Save address and do function
2551:				
2552:18473+17	1113  CD7111  	DOFN:   CALL    CHEKFN          ; Make sure FN follows
2553:18490+11	1116  D5      	        PUSH    DE              ; Save function pointer address
2554:18501+17	1117  CDD10D  	        CALL    EVLPAR          ; Evaluate expression in "()"
2555:18518+17	111A  CDF90C  	        CALL    TSTNUM          ; Make sure numeric result
2556:18535+19	111D  E3      	        EX      (SP),HL         ; Save code str , Get FN ptr
2557:18554+7	111E  5E      	        LD      E,(HL)          ; Get LSB of FN code string
2558:18561+6	111F  23      	        INC     HL
2559:18567+7	1120  56      	        LD      D,(HL)          ; Get MSB of FN code string
2560:18574+6	1121  23      	        INC     HL
2561:18580+4	1122  7A      	        LD      A,D             ; And function DEFined?
2562:18584+4	1123  B3      	        OR      E
2563:18588+10	1124  CAF703  	        JP      Z,UFERR         ; No - ?UF Error
2564:18598+7	1127  7E      	        LD      A,(HL)          ; Get LSB of argument address
2565:18605+6	1128  23      	        INC     HL
2566:18611+7	1129  66      	        LD      H,(HL)          ; Get MSB of argument address
2567:18618+4	112A  6F      	        LD      L,A             ; HL = Arg variable address
2568:18622+11	112B  E5      	        PUSH    HL              ; Save it
2569:18633+16	112C  2AB81E  	        LD      HL,(FNRGNM)     ; Get old argument name
2570:18649+19	112F  E3      	        EX      (SP),HL         ; Save old , Get new
2571:18668+16	1130  22B81E  	        LD      (FNRGNM),HL     ; Set new argument name
2572:18684+16	1133  2ABC1E  	        LD      HL,(FNARG+2)    ; Get LSB,NLSB of old arg value
2573:18700+11	1136  E5      	        PUSH    HL              ; Save it
2574:18711+16	1137  2ABA1E  	        LD      HL,(FNARG)      ; Get MSB,EXP of old arg value
2575:18727+11	113A  E5      	        PUSH    HL              ; Save it
2576:18738+11	113B  D5      	        PUSH    DE              ; Save FN code string address
2577:18749+10	113C  11BA1E  	        LD      DE,FNARG        ; DE = Value of argument
2578:18759+10	113F  21BE1E  	        LD      HL,FPREG        ; Move FPREG to argument
2579:18769+16	1142  EDA0    	        LDI                     ; 4 bytes to move (HL++)->(DE++)
2580:18785+16	1144  EDA0    	        LDI
2581:18801+16	1146  EDA0    	        LDI
2582:18817+16	1148  EDA0    	        LDI
2583:18833+10	114A  E1      	        POP     HL              ; Get FN code string address
2584:18843+17	114B  CDF60C  	        CALL    GETNUM          ; Get value from function
2585:18860+6	114E  2B      	        DEC     HL              ; DEC 'cos GETCHR INCs
2586:18866+17	114F  CD4F08  	        CALL    GETCHR          ; Get next character
2587:18883+10	1152  C2EB03  	        JP      NZ,SNERR        ; Bad character in FN - Error
2588:18893+10	1155  E1      	        POP     HL              ; Get MSB,EXP of old arg
2589:18903+16	1156  22BA1E  	        LD      (FNARG),HL      ; Restore it
2590:18919+10	1159  E1      	        POP     HL              ; Get LSB,NLSB of old arg
2591:18929+16	115A  22BC1E  	        LD      (FNARG+2),HL    ; Restore it
2592:18945+10	115D  E1      	        POP     HL              ; Get name of old arg
2593:18955+16	115E  22B81E  	        LD      (FNRGNM),HL     ; Restore it
2594:18971+10	1161  E1      	        POP     HL              ; Restore code string address
2595:18981+10	1162  C9      	        RET
2596:				
2597:18991+11	1163  E5      	IDTEST: PUSH    HL              ; Save code string address
2598:19002+16	1164  2A361E  	        LD      HL,(LINEAT)     ; Get current line number
2599:19018+6	1167  23      	        INC     HL              ; -1 means direct statement
2600:19024+4	1168  7C      	        LD      A,H
2601:19028+4	1169  B5      	        OR      L
2602:19032+10	116A  E1      	        POP     HL              ; Restore code string address
2603:19042+5+6	116B  C0      	        RET     NZ              ; Return if in program
2604:19047+7	116C  1E16    	        LD      E,ID            ; ?ID Error
2605:19054+10	116E  C3FF03  	        JP      ERROR
2606:				
2607:19064+17	1171  CDBC06  	CHEKFN: CALL    CHKSYN          ; Make sure FN follows
2608:     -	1174  A4      	        .BYTE   ZFN             ; "FN" token
2609:19081+7	1175  3E80    	        LD      A,80H
2610:19088+13	1177  32A51E  	        LD      (FORFLG),A      ; Flag FN name to find
2611:19101+7	117A  B6      	        OR      (HL)            ; FN name has bit 7 set
2612:19108+4	117B  47      	        LD      B,A             ; in first byte of name
2613:19112+17	117C  CDFA0E  	        CALL    GTFNAM          ; Get FN name
2614:19129+10	117F  C3F90C  	        JP      TSTNUM          ; Make sure numeric function
2615:				
2616:19139+17	1182  CDF90C  	STR:    CALL    TSTNUM          ; Make sure it's a number
2617:19156+17	1185  CDDA18  	        CALL    NUMASC          ; Turn number into text
2618:19173+17	1188  CDB611  	STR1:   CALL    CRTST           ; Create string entry for it
2619:19190+17	118B  CD5613  	        CALL    GSTRCU          ; Current string to pool
2620:19207+10	118E  01B713  	        LD      BC,TOPOOL       ; Save in string pool
2621:19217+11	1191  C5      	        PUSH    BC              ; Save address on stack
2622:				
2623:19228+7	1192  7E      	SAVSTR: LD      A,(HL)          ; Get string length
2624:19235+6	1193  23      	        INC     HL
2625:19241+6	1194  23      	        INC     HL
2626:19247+11	1195  E5      	        PUSH    HL              ; Save pointer to string
2627:19258+17	1196  CD1B12  	        CALL    TESTR           ; See if enough string space
2628:19275+10	1199  E1      	        POP     HL              ; Restore pointer to string
2629:19285+7	119A  4E      	        LD      C,(HL)          ; Get LSB of address
2630:19292+6	119B  23      	        INC     HL
2631:19298+7	119C  46      	        LD      B,(HL)          ; Get MSB of address
2632:19305+17	119D  CDAA11  	        CALL    CRTMST          ; Create string entry
2633:19322+11	11A0  E5      	        PUSH    HL              ; Save pointer to MSB of addr
2634:19333+4	11A1  6F      	        LD      L,A             ; Length of string
2635:19337+17	11A2  CD4913  	        CALL    TOSTRA          ; Move to string area
2636:19354+10	11A5  D1      	        POP     DE              ; Restore pointer to MSB
2637:19364+10	11A6  C9      	        RET
2638:				
2639:19374+17	11A7  CD1B12  	MKTMST: CALL    TESTR           ; See if enough string space
2640:19391+10	11AA  21991E  	CRTMST: LD      HL,TMPSTR       ; Temporary string
2641:19401+11	11AD  E5      	        PUSH    HL              ; Save it
2642:19412+7	11AE  77      	        LD      (HL),A          ; Save length of string
2643:19419+6	11AF  23      	        INC     HL
2644:19425+6	11B0  23      	SVSTAD: INC     HL
2645:19431+7	11B1  73      	        LD      (HL),E          ; Save LSB of address
2646:19438+6	11B2  23      	        INC     HL
2647:19444+7	11B3  72      	        LD      (HL),D          ; Save MSB of address
2648:19451+10	11B4  E1      	        POP     HL              ; Restore pointer
2649:19461+10	11B5  C9      	        RET
2650:				
2651:19471+6	11B6  2B      	CRTST:  DEC     HL              ; DEC - INCed after
2652:19477+7	11B7  0622    	QTSTR:  LD      B,'"'           ; Terminating quote
2653:19484+4	11B9  50      	        LD      D,B             ; Quote to D
2654:19488+11	11BA  E5      	DTSTR:  PUSH    HL              ; Save start
2655:19499+7	11BB  0EFF    	        LD      C,-1            ; Set counter to -1
2656:19506+6	11BD  23      	QTSTLP: INC     HL              ; Move on
2657:19512+7	11BE  7E      	        LD      A,(HL)          ; Get byte
2658:19519+4	11BF  0C      	        INC     C               ; Count bytes
2659:19523+4	11C0  B7      	        OR      A               ; End of line?
2660:19527+10	11C1  CACC11  	        JP      Z,CRTSTE        ; Yes - Create string entry
2661:19537+4	11C4  BA      	        CP      D               ; Terminator D found?
2662:19541+10	11C5  CACC11  	        JP      Z,CRTSTE        ; Yes - Create string entry
2663:19551+4	11C8  B8      	        CP      B               ; Terminator B found?
2664:19555+10	11C9  C2BD11  	        JP      NZ,QTSTLP       ; No - Keep looking
2665:19565+7	11CC  FE22    	CRTSTE: CP      '"'             ; End with '"'?
2666:19572+10+7	11CE  CC4F08  	        CALL    Z,GETCHR        ; Yes - Get next character
2667:19582+19	11D1  E3      	        EX      (SP),HL         ; Starting quote
2668:19601+6	11D2  23      	        INC     HL              ; First byte of string
2669:19607+4	11D3  EB      	        EX      DE,HL           ; To DE
2670:19611+4	11D4  79      	        LD      A,C             ; Get length
2671:19615+17	11D5  CDAA11  	        CALL    CRTMST          ; Create string entry
2672:19632+10	11D8  11991E  	TSTOPL: LD      DE,TMPSTR       ; Temporary string
2673:19642+16	11DB  2A8B1E  	        LD      HL,(TMSTPT)     ; Temporary string pool pointer
2674:19658+16	11DE  22BE1E  	        LD      (FPREG),HL      ; Save address of string ptr
2675:19674+7	11E1  3E01    	        LD      A,1
2676:19681+13	11E3  32871E  	        LD      (TYPE),A        ; Set type to string
2677:19694+4	11E6  EB      	        EX      DE,HL           ; Move string to pool
2678:19698+16	11E7  EDA0    	        LDI                     ; 4 bytes to move (HL++)->(DE++)
2679:19714+16	11E9  EDA0    	        LDI
2680:19730+16	11EB  EDA0    	        LDI
2681:19746+16	11ED  EDA0    	        LDI
2682:19762+4	11EF  EB      	        EX      DE,HL           ; Swap source destination
2683:19766+4	11F0  7C      	        LD      A,H             ; Out of string pool?
2684:19770+4	11F1  92      	        SUB     D               ; Compare with D
2685:19774+7+5	11F2  2002    	        JR      NZ,$+4          ; Different - Exit
2686:19781+4	11F4  7D      	        LD      A,L             ; Get L
2687:19785+4	11F5  93      	        SUB     E               ; Compare with E
2688:19789+16	11F6  228B1E  	        LD      (TMSTPT),HL     ; Save new pointer
2689:19805+10	11F9  E1      	        POP     HL              ; Restore code string address
2690:19815+7	11FA  7E      	        LD      A,(HL)          ; Get next code byte
2691:19822+5+6	11FB  C0      	        RET     NZ              ; Return if pool OK
2692:19827+7	11FC  1E1E    	        LD      E,ST            ; ?ST Error
2693:19834+10	11FE  C3FF03  	        JP      ERROR           ; String pool overflow
2694:				
2695:19844+6	1201  23      	PRNUMS: INC     HL              ; Skip leading space
2696:19850+17	1202  CDB611  	PRS:    CALL    CRTST           ; Create string entry for it
2697:19867+17	1205  CD5613  	PRS1:   CALL    GSTRCU          ; Current string to pool
2698:19884+17	1208  CD8917  	        CALL    LOADFP          ; Move string block to BCDE
2699:19901+4	120B  1C      	        INC     E               ; Length + 1
2700:19905+4	120C  1D      	PRSLP:  DEC     E               ; Count characters
2701:19909+5+6	120D  C8      	        RET     Z               ; End of string
2702:19914+7	120E  0A      	        LD      A,(BC)          ; Get byte to output
2703:19921+17	120F  CDC706  	        CALL    OUTC            ; Output character in A
2704:19938+7	1212  FE0D    	        CP      CR              ; Return?
2705:19945+10+7	1214  CC230B  	        CALL    Z,DONULL        ; Yes - Do nulls
2706:19955+6	1217  03      	        INC     BC              ; Next byte in string
2707:19961+10	1218  C30C12  	        JP      PRSLP           ; More characters to output
2708:				
2709:19971+4	121B  B7      	TESTR:  OR      A               ; Test if enough room
2710:     -	121C  0E      	        .BYTE   0EH             ; No garbage collection done
2711:19975+10	121D  F1      	GRBDON: POP     AF              ; Garbage collection done
2712:19985+11	121E  F5      	        PUSH    AF              ; Save status
2713:19996+16	121F  2A341E  	        LD      HL,(STRSPC)     ; Bottom of string space in use
2714:20012+4	1222  EB      	        EX      DE,HL           ; To DE
2715:20016+16	1223  2A9D1E  	        LD      HL,(STRBOT)     ; Bottom of string area
2716:20032+4	1226  2F      	        CPL                     ; Negate length (Top down)
2717:20036+4	1227  4F      	        LD      C,A             ; -Length to BC
2718:20040+7	1228  06FF    	        LD      B,-1            ; BC = -ve length of string
2719:20047+11	122A  09      	        ADD     HL,BC           ; Add to bottom of space in use
2720:20058+6	122B  23      	        INC     HL              ; Plus one for 2's complement
2721:20064+4	122C  7C      	        LD      A,H             ; Below string RAM area?
2722:20068+4	122D  92      	        SUB     D               ; Compare with D
2723:20072+7+5	122E  2002    	        JR      NZ,$+4          ; Different - Exit
2724:20079+4	1230  7D      	        LD      A,L             ; Get L
2725:20083+4	1231  93      	        SUB     E               ; Compare with E
2726:20087+10	1232  DA3C12  	        JP      C,TESTOS        ; Tidy up if not done else err
2727:20097+16	1235  229D1E  	        LD      (STRBOT),HL     ; Save new bottom of area
2728:20113+6	1238  23      	        INC     HL              ; Point to first byte of string
2729:20119+4	1239  EB      	        EX      DE,HL           ; Address to DE
2730:20123+10	123A  F1      	POPAF:  POP     AF              ; Throw away status push
2731:20133+10	123B  C9      	        RET
2732:				
2733:20143+10	123C  F1      	TESTOS: POP     AF              ; Garbage collect been done?
2734:20153+7	123D  1E1A    	        LD      E,OS            ; ?OS Error
2735:20160+10	123F  CAFF03  	        JP      Z,ERROR         ; Yes - Not enough string apace
2736:20170+4	1242  BF      	        CP      A               ; Flag garbage collect done
2737:20174+11	1243  F5      	        PUSH    AF              ; Save status
2738:20185+10	1244  011D12  	        LD      BC,GRBDON       ; Garbage collection done
2739:20195+11	1247  C5      	        PUSH    BC              ; Save for RETurn
2740:20206+16	1248  2A891E  	GARBGE: LD      HL,(LSTRAM)     ; Get end of RAM pointer
2741:20222+16	124B  229D1E  	GARBLP: LD      (STRBOT),HL     ; Reset string pointer
2742:20238+10	124E  210000  	        LD      HL,0
2743:20248+11	1251  E5      	        PUSH    HL              ; Flag no string found
2744:20259+16	1252  2A341E  	        LD      HL,(STRSPC)     ; Get bottom of string space
2745:20275+11	1255  E5      	        PUSH    HL              ; Save bottom of string space
2746:20286+10	1256  218D1E  	        LD      HL,TMSTPL       ; Temporary string pool
2747:20296+20	1259  ED5B8B1E	GRBLP:  LD      DE,(TMSTPT)     ; Temporary string pool pointer
2748:20316+4	125D  7C      	        LD      A,H             ; Temporary string pool done?
2749:20320+4	125E  92      	        SUB     D               ; Compare with D
2750:20324+7+5	125F  2002    	        JR      NZ,$+4          ; Different - Exit
2751:20331+4	1261  7D      	        LD      A,L             ; Get L
2752:20335+4	1262  93      	        SUB     E               ; Compare with E
2753:20339+10	1263  015912  	        LD      BC,GRBLP        ; Loop until string pool done
2754:20349+10	1266  C2B512  	        JP      NZ,STPOOL       ; No - See if in string area
2755:20359+16	1269  2AB01E  	        LD      HL,(PROGND)     ; Start of simple variables
2756:20375+20	126C  ED5BB21E	SMPVAR: LD      DE,(VAREND)     ; End of simple variables
2757:20395+4	1270  7C      	        LD      A,H             ; All simple strings done?
2758:20399+4	1271  92      	        SUB     D               ; Compare with D
2759:20403+7+5	1272  2002    	        JR      NZ,$+4          ; Different - Exit
2760:20410+4	1274  7D      	        LD      A,L             ; Get L
2761:20414+4	1275  93      	        SUB     E               ; Compare with E
2762:20418+10	1276  CA8412  	        JP      Z,ARRLP         ; Yes - Do string arrays
2763:20428+7	1279  7E      	        LD      A,(HL)          ; Get type of variable
2764:20435+6	127A  23      	        INC     HL
2765:20441+6	127B  23      	        INC     HL
2766:20447+4	127C  B7      	        OR      A               ; "S" flag set if string
2767:20451+17	127D  CDB812  	        CALL    STRADD          ; See if string in string area
2768:20468+10	1280  C36C12  	        JP      SMPVAR          ; Loop until simple ones done
2769:				
2770:20478+10	1283  C1      	GNXARY: POP     BC              ; Scrap address of this array
2771:20488+20	1284  ED5BB41E	ARRLP:  LD      DE,(ARREND)     ; End of string arrays
2772:20508+4	1288  7C      	        LD      A,H             ; All string arrays done?
2773:20512+4	1289  92      	        SUB     D               ; Compare with D
2774:20516+7+5	128A  2002    	        JR      NZ,$+4          ; Different - Exit
2775:20523+4	128C  7D      	        LD      A,L             ; Get L
2776:20527+4	128D  93      	        SUB     E               ; Compare with E
2777:20531+10	128E  CAE412  	        JP      Z,SCNEND        ; Yes - Move string if found
2778:20541+17	1291  CD8917  	        CALL    LOADFP          ; Get array name to BCDE
2779:20558+4	1294  7B      	        LD      A,E             ; Get type of array     
2780:20562+11	1295  E5      	        PUSH    HL              ; Save address of num of dim'ns
2781:20573+11	1296  09      	        ADD     HL,BC           ; Start of next array
2782:20584+4	1297  B7      	        OR      A               ; Test type of array
2783:20588+10	1298  F28312  	        JP      P,GNXARY        ; Numeric array - Ignore it
2784:20598+16	129B  229F1E  	        LD      (CUROPR),HL     ; Save address of next array
2785:20614+10	129E  E1      	        POP     HL              ; Get address of num of dim'ns
2786:20624+7	129F  4E      	        LD      C,(HL)          ; BC = Number of dimensions
2787:20631+7	12A0  0600    	        LD      B,0
2788:20638+11	12A2  09      	        ADD     HL,BC           ; Two bytes per dimension size
2789:20649+11	12A3  09      	        ADD     HL,BC
2790:20660+6	12A4  23      	        INC     HL              ; Plus one for number of dim'ns
2791:20666+20	12A5  ED5B9F1E	GRBARY: LD      DE,(CUROPR)     ; Get address of next array
2792:20686+4	12A9  7C      	        LD      A,H             ; Is this array finished?
2793:20690+4	12AA  92      	        SUB     D               ; Compare with D
2794:20694+7+5	12AB  2002    	        JR      NZ,$+4          ; Different - Exit
2795:20701+4	12AD  7D      	        LD      A,L             ; Get L
2796:20705+4	12AE  93      	        SUB     E               ; Compare with E
2797:20709+10	12AF  CA8412  	        JP      Z,ARRLP         ; Yes - Get next one
2798:20719+10	12B2  01A512  	        LD      BC,GRBARY       ; Loop until array all done
2799:20729+11	12B5  C5      	STPOOL: PUSH    BC              ; Save return address
2800:20740+7	12B6  F680    	        OR      80H             ; Flag string type
2801:20747+7	12B8  7E      	STRADD: LD      A,(HL)          ; Get string length
2802:20754+6	12B9  23      	        INC     HL
2803:20760+6	12BA  23      	        INC     HL
2804:20766+7	12BB  5E      	        LD      E,(HL)          ; Get LSB of string address
2805:20773+6	12BC  23      	        INC     HL
2806:20779+7	12BD  56      	        LD      D,(HL)          ; Get MSB of string address
2807:20786+6	12BE  23      	        INC     HL
2808:20792+5+6	12BF  F0      	        RET     P               ; Not a string - Return
2809:20797+4	12C0  B7      	        OR      A               ; Set flags on string length
2810:20801+5+6	12C1  C8      	        RET     Z               ; Null string - Return
2811:20806+4	12C2  44      	        LD      B,H             ; Save variable pointer
2812:20810+4	12C3  4D      	        LD      C,L
2813:20814+16	12C4  2A9D1E  	        LD      HL,(STRBOT)     ; Bottom of new area
2814:20830+4	12C7  7C      	        LD      A,H             ; String been done?
2815:20834+4	12C8  92      	        SUB     D               ; Compare with D
2816:20838+7+5	12C9  2002    	        JR      NZ,$+4          ; Different - Exit
2817:20845+4	12CB  7D      	        LD      A,L             ; Get L
2818:20849+4	12CC  93      	        SUB     E               ; Compare with E
2819:20853+4	12CD  60      	        LD      H,B             ; Restore variable pointer
2820:20857+4	12CE  69      	        LD      L,C
2821:20861+5+6	12CF  D8      	        RET     C               ; String done - Ignore
2822:20866+10	12D0  E1      	        POP     HL              ; Return address
2823:20876+19	12D1  E3      	        EX      (SP),HL         ; Lowest available string area
2824:20895+4	12D2  7C      	        LD      A,H             ; String within string area?
2825:20899+4	12D3  92      	        SUB     D               ; Compare with D
2826:20903+7+5	12D4  2002    	        JR      NZ,$+4          ; Different - Exit
2827:20910+4	12D6  7D      	        LD      A,L             ; Get L
2828:20914+4	12D7  93      	        SUB     E               ; Compare with E
2829:20918+19	12D8  E3      	        EX      (SP),HL         ; Lowest available string area
2830:20937+11	12D9  E5      	        PUSH    HL              ; Re-save return address
2831:20948+4	12DA  60      	        LD      H,B             ; Restore variable pointer
2832:20952+4	12DB  69      	        LD      L,C
2833:20956+5+6	12DC  D0      	        RET     NC              ; Outside string area - Ignore
2834:20961+10	12DD  C1      	        POP     BC              ; Get return , Throw 2 away
2835:20971+10	12DE  F1      	        POP     AF              ; 
2836:20981+10	12DF  F1      	        POP     AF              ; 
2837:20991+11	12E0  E5      	        PUSH    HL              ; Save variable pointer
2838:21002+11	12E1  D5      	        PUSH    DE              ; Save address of current
2839:21013+11	12E2  C5      	        PUSH    BC              ; Put back return address
2840:21024+10	12E3  C9      	        RET                     ; Go to it
2841:				
2842:21034+10	12E4  D1      	SCNEND: POP     DE              ; Addresses of strings
2843:21044+10	12E5  E1      	        POP     HL              ; 
2844:21054+4	12E6  7D      	        LD      A,L             ; HL = 0 if no more to do
2845:21058+4	12E7  B4      	        OR      H
2846:21062+5+6	12E8  C8      	        RET     Z               ; No more to do - Return
2847:21067+6	12E9  2B      	        DEC     HL
2848:21073+7	12EA  46      	        LD      B,(HL)          ; MSB of address of string
2849:21080+6	12EB  2B      	        DEC     HL
2850:21086+7	12EC  4E      	        LD      C,(HL)          ; LSB of address of string
2851:21093+11	12ED  E5      	        PUSH    HL              ; Save variable address
2852:21104+6	12EE  2B      	        DEC     HL
2853:21110+6	12EF  2B      	        DEC     HL
2854:21116+7	12F0  6E      	        LD      L,(HL)          ; HL = Length of string
2855:21123+7	12F1  2600    	        LD      H,0
2856:21130+11	12F3  09      	        ADD     HL,BC           ; Address of end of string+1
2857:21141+4	12F4  50      	        LD      D,B             ; String address to DE
2858:21145+4	12F5  59      	        LD      E,C
2859:21149+6	12F6  2B      	        DEC     HL              ; Last byte in string
2860:21155+4	12F7  44      	        LD      B,H             ; Address to BC
2861:21159+4	12F8  4D      	        LD      C,L
2862:21163+16	12F9  2A9D1E  	        LD      HL,(STRBOT)     ; Current bottom of string area
2863:21179+17	12FC  CDB703  	        CALL    MOVSTR          ; Move string to new address
2864:21196+10	12FF  E1      	        POP     HL              ; Restore variable address
2865:21206+7	1300  71      	        LD      (HL),C          ; Save new LSB of address
2866:21213+6	1301  23      	        INC     HL
2867:21219+7	1302  70      	        LD      (HL),B          ; Save new MSB of address
2868:21226+4	1303  69      	        LD      L,C             ; Next string area+1 to HL
2869:21230+4	1304  60      	        LD      H,B
2870:21234+6	1305  2B      	        DEC     HL              ; Next string area address
2871:21240+10	1306  C34B12  	        JP      GARBLP          ; Look for more strings
2872:				
2873:21250+11	1309  C5      	CONCAT: PUSH    BC              ; Save prec' opr & code string
2874:21261+11	130A  E5      	        PUSH    HL              ; 
2875:21272+16	130B  2ABE1E  	        LD      HL,(FPREG)      ; Get first string
2876:21288+19	130E  E3      	        EX      (SP),HL         ; Save first string
2877:21307+17	130F  CD820D  	        CALL    OPRND           ; Get second string
2878:21324+19	1312  E3      	        EX      (SP),HL         ; Restore first string
2879:21343+17	1313  CDFA0C  	        CALL    TSTSTR          ; Make sure it's a string
2880:21360+7	1316  7E      	        LD      A,(HL)          ; Get length of second string
2881:21367+11	1317  E5      	        PUSH    HL              ; Save first string
2882:21378+16	1318  2ABE1E  	        LD      HL,(FPREG)      ; Get second string
2883:21394+11	131B  E5      	        PUSH    HL              ; Save second string
2884:21405+7	131C  86      	        ADD     A,(HL)          ; Add length of second string
2885:21412+7	131D  1E1C    	        LD      E,LS            ; ?LS Error
2886:21419+10	131F  DAFF03  	        JP      C,ERROR         ; String too long - Error
2887:21429+17	1322  CDA711  	        CALL    MKTMST          ; Make temporary string
2888:21446+10	1325  D1      	        POP     DE              ; Get second string to DE
2889:21456+17	1326  CD5A13  	        CALL    GSTRDE          ; Move to string pool if needed
2890:21473+19	1329  E3      	        EX      (SP),HL         ; Get first string
2891:21492+17	132A  CD5913  	        CALL    GSTRHL          ; Move to string pool if needed
2892:21509+11	132D  E5      	        PUSH    HL              ; Save first string
2893:21520+16	132E  2A9B1E  	        LD      HL,(TMPSTR+2)   ; Temporary string address
2894:21536+4	1331  EB      	        EX      DE,HL           ; To DE
2895:21540+17	1332  CD4013  	        CALL    SSTSA           ; First string to string area
2896:21557+17	1335  CD4013  	        CALL    SSTSA           ; Second string to string area
2897:21574+10	1338  21140D  	        LD      HL,EVAL2        ; Return to evaluation loop
2898:21584+19	133B  E3      	        EX      (SP),HL         ; Save return,get code string
2899:21603+11	133C  E5      	        PUSH    HL              ; Save code string address
2900:21614+10	133D  C3D811  	        JP      TSTOPL          ; To temporary string to pool
2901:				
2902:21624+10	1340  E1      	SSTSA:  POP     HL              ; Return address
2903:21634+19	1341  E3      	        EX      (SP),HL         ; Get string block,save return
2904:21653+7	1342  7E      	        LD      A,(HL)          ; Get length of string
2905:21660+6	1343  23      	        INC     HL
2906:21666+6	1344  23      	        INC     HL
2907:21672+7	1345  4E      	        LD      C,(HL)          ; Get LSB of string address
2908:21679+6	1346  23      	        INC     HL
2909:21685+7	1347  46      	        LD      B,(HL)          ; Get MSB of string address
2910:21692+4	1348  6F      	        LD      L,A             ; Length to L
2911:21696+4	1349  2C      	TOSTRA: INC     L               ; INC - DECed after
2912:21700+4	134A  2D      	TSALP:  DEC     L               ; Count bytes moved
2913:21704+5+6	134B  C8      	        RET     Z               ; End of string - Return
2914:21709+7	134C  0A      	        LD      A,(BC)          ; Get source
2915:21716+7	134D  12      	        LD      (DE),A          ; Save destination
2916:21723+6	134E  03      	        INC     BC              ; Next source
2917:21729+6	134F  13      	        INC     DE              ; Next destination
2918:21735+10	1350  C34A13  	        JP      TSALP           ; Loop until string moved
2919:				
2920:21745+17	1353  CDFA0C  	GETSTR: CALL    TSTSTR          ; Make sure it's a string
2921:21762+16	1356  2ABE1E  	GSTRCU: LD      HL,(FPREG)      ; Get current string
2922:21778+4	1359  EB      	GSTRHL: EX      DE,HL           ; Save DE
2923:21782+17	135A  CD7713  	GSTRDE: CALL    BAKTMP          ; Was it last tmp-str?
2924:21799+4	135D  EB      	        EX      DE,HL           ; Restore DE
2925:21803+5+6	135E  C0      	        RET     NZ              ; No - Return
2926:21808+11	135F  D5      	        PUSH    DE              ; Save string
2927:21819+4	1360  50      	        LD      D,B             ; String block address to DE
2928:21823+4	1361  59      	        LD      E,C
2929:21827+6	1362  1B      	        DEC     DE              ; Point to length
2930:21833+7	1363  4E      	        LD      C,(HL)          ; Get string length
2931:21840+16	1364  2A9D1E  	        LD      HL,(STRBOT)     ; Current bottom of string area
2932:21856+4	1367  7C      	        LD      A,H             ; Last one in string area?
2933:21860+4	1368  92      	        SUB     D               ; Compare with D
2934:21864+7+5	1369  2002    	        JR      NZ,$+4          ; Different - Exit
2935:21871+4	136B  7D      	        LD      A,L             ; Get L
2936:21875+4	136C  93      	        SUB     E               ; Compare with E
2937:21879+10	136D  C27513  	        JP      NZ,POPHL        ; No - Return
2938:21889+4	1370  47      	        LD      B,A             ; Clear B (A=0)
2939:21893+11	1371  09      	        ADD     HL,BC           ; Remove string from str' area
2940:21904+16	1372  229D1E  	        LD      (STRBOT),HL     ; Save new bottom of str' area
2941:     -	1375          	POPHRT:                         ; Restore address of number
2942:21920+10	1375  E1      	POPHL:  POP     HL              ; Restore string
2943:21930+10	1376  C9      	        RET
2944:				
2945:21940+16	1377  2A8B1E  	BAKTMP: LD      HL,(TMSTPT)     ; Get temporary string pool top
2946:21956+6	137A  2B      	        DEC     HL              ; Back
2947:21962+7	137B  46      	        LD      B,(HL)          ; Get MSB of address
2948:21969+6	137C  2B      	        DEC     HL              ; Back
2949:21975+7	137D  4E      	        LD      C,(HL)          ; Get LSB of address
2950:21982+6	137E  2B      	        DEC     HL              ; Back
2951:21988+6	137F  2B      	        DEC     HL              ; Back
2952:21994+4	1380  7C      	        LD      A,H             ; String last in string pool?
2953:21998+4	1381  92      	        SUB     D               ; Compare with D
2954:22002+7+5	1382  2002    	        JR      NZ,$+4          ; Different - Exit
2955:22009+4	1384  7D      	        LD      A,L             ; Get L
2956:22013+4	1385  93      	        SUB     E               ; Compare with E
2957:22017+5+6	1386  C0      	        RET     NZ              ; Yes - Leave it
2958:22022+16	1387  228B1E  	        LD      (TMSTPT),HL     ; Save new string pool top
2959:22038+10	138A  C9      	        RET
2960:				
2961:22048+10	138B  01E110  	LEN:    LD      BC,PASSA        ; To return integer A
2962:22058+11	138E  C5      	        PUSH    BC              ; Save address
2963:22069+17	138F  CD5313  	GETLEN: CALL    GETSTR          ; Get string and its length
2964:22086+4	1392  AF      	        XOR     A
2965:22090+4	1393  57      	        LD      D,A             ; Clear D
2966:22094+13	1394  32871E  	        LD      (TYPE),A        ; Set type to numeric
2967:22107+7	1397  7E      	        LD      A,(HL)          ; Get length of string
2968:22114+4	1398  B7      	        OR      A               ; Set status flags
2969:22118+10	1399  C9      	        RET
2970:				
2971:22128+10	139A  01E110  	ASC:    LD      BC,PASSA        ; To return integer A
2972:22138+11	139D  C5      	        PUSH    BC              ; Save address
2973:22149+17	139E  CD8F13  	GTFLNM: CALL    GETLEN          ; Get length of string
2974:22166+10	13A1  CA1609  	        JP      Z,FCERR         ; Null string - Error
2975:22176+6	13A4  23      	        INC     HL
2976:22182+6	13A5  23      	        INC     HL
2977:22188+7	13A6  5E      	        LD      E,(HL)          ; Get LSB of address
2978:22195+6	13A7  23      	        INC     HL
2979:22201+7	13A8  56      	        LD      D,(HL)          ; Get MSB of address
2980:22208+7	13A9  1A      	        LD      A,(DE)          ; Get first byte of string
2981:22215+10	13AA  C9      	        RET
2982:				
2983:22225+7	13AB  3E01    	CHR:    LD      A,1             ; One character string
2984:22232+17	13AD  CDA711  	        CALL    MKTMST          ; Make a temporary string
2985:22249+17	13B0  CDA414  	        CALL    MAKINT          ; Make it integer A
2986:22266+16	13B3  2A9B1E  	        LD      HL,(TMPSTR+2)   ; Get address of string
2987:22282+7	13B6  73      	        LD      (HL),E          ; Save character
2988:22289+10	13B7  C1      	TOPOOL: POP     BC              ; Clean up stack
2989:22299+10	13B8  C3D811  	        JP      TSTOPL          ; Temporary string to pool
2990:				
2991:22309+17	13BB  CD5414  	LEFT:   CALL    LFRGNM          ; Get number and ending ")"
2992:22326+4	13BE  AF      	        XOR     A               ; Start at first byte in string
2993:22330+19	13BF  E3      	RIGHT1: EX      (SP),HL         ; Save code string,Get string
2994:22349+4	13C0  4F      	        LD      C,A             ; Starting position in string
2995:22353+11	13C1  E5      	MID1:   PUSH    HL              ; Save string block address
2996:22364+7	13C2  7E      	        LD      A,(HL)          ; Get length of string
2997:22371+4	13C3  B8      	        CP      B               ; Compare with number given
2998:22375+10	13C4  DAC913  	        JP      C,ALLFOL        ; All following bytes required
2999:22385+4	13C7  78      	        LD      A,B             ; Get new length
3000:     -	13C8  11      	        .BYTE   11H             ; Skip "LD C,0"
3001:22389+7	13C9  0E00    	ALLFOL: LD      C,0             ; First byte of string
3002:22396+11	13CB  C5      	        PUSH    BC              ; Save position in string
3003:22407+17	13CC  CD1B12  	        CALL    TESTR           ; See if enough string space
3004:22424+10	13CF  C1      	        POP     BC              ; Get position in string
3005:22434+10	13D0  E1      	        POP     HL              ; Restore string block address
3006:22444+11	13D1  E5      	        PUSH    HL              ; And re-save it
3007:22455+6	13D2  23      	        INC     HL
3008:22461+6	13D3  23      	        INC     HL
3009:22467+7	13D4  46      	        LD      B,(HL)          ; Get LSB of address
3010:22474+6	13D5  23      	        INC     HL
3011:22480+7	13D6  66      	        LD      H,(HL)          ; Get MSB of address
3012:22487+4	13D7  68      	        LD      L,B             ; HL = address of string
3013:22491+7	13D8  0600    	        LD      B,0             ; BC = starting address
3014:22498+11	13DA  09      	        ADD     HL,BC           ; Point to that byte
3015:22509+4	13DB  44      	        LD      B,H             ; BC = source string
3016:22513+4	13DC  4D      	        LD      C,L
3017:22517+17	13DD  CDAA11  	        CALL    CRTMST          ; Create a string entry
3018:22534+4	13E0  6F      	        LD      L,A             ; Length of new string
3019:22538+17	13E1  CD4913  	        CALL    TOSTRA          ; Move string to string area
3020:22555+10	13E4  D1      	        POP     DE              ; Clear stack
3021:22565+17	13E5  CD5A13  	        CALL    GSTRDE          ; Move to string pool if needed
3022:22582+10	13E8  C3D811  	        JP      TSTOPL          ; Temporary string to pool
3023:				
3024:22592+17	13EB  CD5414  	RIGHT:  CALL    LFRGNM          ; Get number and ending ")"
3025:22609+10	13EE  D1      	        POP     DE              ; Get string length
3026:22619+11	13EF  D5      	        PUSH    DE              ; And re-save
3027:22630+7	13F0  1A      	        LD      A,(DE)          ; Get length
3028:22637+4	13F1  90      	        SUB     B               ; Move back N bytes
3029:22641+10	13F2  C3BF13  	        JP      RIGHT1          ; Go and get sub-string
3030:				
3031:22651+4	13F5  EB      	MID:    EX      DE,HL           ; Get code string address
3032:22655+7	13F6  7E      	        LD      A,(HL)          ; Get next byte ',' or ")"
3033:22662+17	13F7  CD5914  	        CALL    MIDNUM          ; Get number supplied
3034:22679+4	13FA  04      	        INC     B               ; Is it character zero?
3035:22683+4	13FB  05      	        DEC     B
3036:22687+10	13FC  CA1609  	        JP      Z,FCERR         ; Yes - Error
3037:22697+11	13FF  C5      	        PUSH    BC              ; Save starting position
3038:22708+7	1400  1EFF    	        LD      E,255           ; All of string
3039:22715+7	1402  FE29    	        CP      ')'             ; Any length given?
3040:22722+10	1404  CA0E14  	        JP      Z,RSTSTR        ; No - Rest of string
3041:22732+17	1407  CDBC06  	        CALL    CHKSYN          ; Make sure ',' follows
3042:     -	140A  2C      	        .BYTE   ','
3043:22749+17	140B  CDA114  	        CALL    GETINT          ; Get integer 0-255
3044:22766+17	140E  CDBC06  	RSTSTR: CALL    CHKSYN          ; Make sure ")" follows
3045:     -	1411  29      	        .BYTE   ")"
3046:22783+10	1412  F1      	        POP     AF              ; Restore starting position
3047:22793+19	1413  E3      	        EX      (SP),HL         ; Get string,8ave code string
3048:22812+10	1414  01C113  	        LD      BC,MID1         ; Continuation of MID$ routine
3049:22822+11	1417  C5      	        PUSH    BC              ; Save for return
3050:22833+4	1418  3D      	        DEC     A               ; Starting position-1
3051:22837+7	1419  BE      	        CP      (HL)            ; Compare with length
3052:22844+7	141A  0600    	        LD      B,0             ; Zero bytes length
3053:22851+5+6	141C  D0      	        RET     NC              ; Null string if start past end
3054:22856+4	141D  4F      	        LD      C,A             ; Save starting position-1
3055:22860+7	141E  7E      	        LD      A,(HL)          ; Get length of string
3056:22867+4	141F  91      	        SUB     C               ; Subtract start
3057:22871+4	1420  BB      	        CP      E               ; Enough string for it?
3058:22875+4	1421  47      	        LD      B,A             ; Save maximum length available
3059:22879+5+6	1422  D8      	        RET     C               ; Truncate string if needed
3060:22884+4	1423  43      	        LD      B,E             ; Set specified length
3061:22888+10	1424  C9      	        RET                     ; Go and create string
3062:				
3063:22898+17	1425  CD8F13  	VAL:    CALL    GETLEN          ; Get length of string
3064:22915+10	1428  CA4A15  	        JP      Z,RESZER        ; Result zero
3065:22925+4	142B  5F      	        LD      E,A             ; Save length
3066:22929+6	142C  23      	        INC     HL
3067:22935+6	142D  23      	        INC     HL
3068:22941+7	142E  7E      	        LD      A,(HL)          ; Get LSB of address
3069:22948+6	142F  23      	        INC     HL
3070:22954+7	1430  66      	        LD      H,(HL)          ; Get MSB of address
3071:22961+4	1431  6F      	        LD      L,A             ; HL = String address
3072:22965+11	1432  E5      	        PUSH    HL              ; Save string address
3073:22976+11	1433  19      	        ADD     HL,DE
3074:22987+7	1434  46      	        LD      B,(HL)          ; Get end of string+1 byte
3075:22994+7	1435  72      	        LD      (HL),D          ; Zero it to terminate
3076:23001+19	1436  E3      	        EX      (SP),HL         ; Save string end,get start
3077:23020+11	1437  C5      	        PUSH    BC              ; Save end+1 byte
3078:23031+7	1438  7E      	        LD      A,(HL)          ; Get starting byte
3079:23038+7	1439  FE24    	        CP      '$'             ; Hex number indicated? [Searle function added]
3080:23045+10	143B  C24314  	        JP      NZ,VAL1
3081:23055+17	143E  CD431D  	        CALL    HEXTFP          ; Convert Hex to FPREG
3082:23072+12	1441  180D    	        JR      VAL3
3083:23084+7	1443  FE25    	VAL1:   CP      '%'             ; Binary number indicated? [Searle function added]
3084:23091+10	1445  C24D14  	        JP      NZ,VAL2
3085:23101+17	1448  CDB31D  	        CALL    BINTFP          ; Convert Bin to FPREG
3086:23118+12	144B  1803    	        JR      VAL3
3087:23130+17	144D  CD3718  	VAL2:   CALL    ASCTFP          ; Convert ASCII string to FP
3088:23147+10	1450  C1      	VAL3:   POP     BC              ; Restore end+1 byte
3089:23157+10	1451  E1      	        POP     HL              ; Restore end+1 address
3090:23167+7	1452  70      	        LD      (HL),B          ; Put back original byte
3091:23174+10	1453  C9      	        RET
3092:				
3093:23184+4	1454  EB      	LFRGNM: EX      DE,HL           ; Code string address to HL
3094:23188+17	1455  CDBC06  	        CALL    CHKSYN          ; Make sure ")" follows
3095:     -	1458  29      	        .BYTE   ")"
3096:23205+10	1459  C1      	MIDNUM: POP     BC              ; Get return address
3097:23215+10	145A  D1      	        POP     DE              ; Get number supplied
3098:23225+11	145B  C5      	        PUSH    BC              ; Re-save return address
3099:23236+4	145C  43      	        LD      B,E             ; Number to B
3100:23240+10	145D  C9      	        RET
3101:				
3102:23250+17	145E  CDA414  	INP:    CALL    MAKINT          ; Make it integer A
3103:23267+13	1461  32221E  	        LD      (INPORT),A      ; Set input port
3104:23280+17	1464  CD211E  	        CALL    INPSUB          ; Get input from port
3105:23297+10	1467  C3E110  	        JP      PASSA           ; Return integer A
3106:				
3107:23307+17	146A  CD8E14  	POUT:   CALL    SETIO           ; Set up port number
3108:23324+10	146D  C3E91D  	        JP      OUTSUB          ; Output data and return
3109:				
3110:23334+17	1470  CD8E14  	WAIT:   CALL    SETIO           ; Set up port number
3111:23351+11	1473  F5      	        PUSH    AF              ; Save AND mask
3112:23362+7	1474  1E00    	        LD      E,0             ; Assume zero if none given
3113:23369+6	1476  2B      	        DEC     HL              ; DEC 'cos GETCHR INCs
3114:23375+17	1477  CD4F08  	        CALL    GETCHR          ; Get next character
3115:23392+10	147A  CA8414  	        JP      Z,NOXOR         ; No XOR byte given
3116:23402+17	147D  CDBC06  	        CALL    CHKSYN          ; Make sure ',' follows
3117:     -	1480  2C      	        .BYTE   ','
3118:23419+17	1481  CDA114  	        CALL    GETINT          ; Get integer 0-255 to XOR with
3119:23436+10	1484  C1      	NOXOR:  POP     BC              ; Restore AND mask
3120:23446+17	1485  CD211E  	WAITLP: CALL    INPSUB          ; Get input
3121:23463+4	1488  AB      	        XOR     E               ; Flip selected bits
3122:23467+4	1489  A0      	        AND     B               ; Result non-zero?
3123:23471+10	148A  CA8514  	        JP      Z,WAITLP        ; No = keep waiting
3124:23481+10	148D  C9      	        RET
3125:				
3126:23491+17	148E  CDA114  	SETIO:  CALL    GETINT          ; Get integer 0-255
3127:23508+13	1491  32221E  	        LD      (INPORT),A      ; Set input port
3128:23521+13	1494  32EA1D  	        LD      (OTPORT),A      ; Set output port
3129:23534+17	1497  CDBC06  	        CALL    CHKSYN          ; Make sure ',' follows
3130:     -	149A  2C      	        .BYTE   ','
3131:23551+10	149B  C3A114  	        JP      GETINT          ; Get integer 0-255 and return
3132:				
3133:23561+17	149E  CD4F08  	FNDNUM: CALL    GETCHR          ; Get next character
3134:23578+17	14A1  CDF60C  	GETINT: CALL    GETNUM          ; Get a number from 0 to 255
3135:23595+17	14A4  CDFB08  	MAKINT: CALL    DEPINT          ; Make sure value 0 - 255
3136:23612+4	14A7  7A      	        LD      A,D             ; Get MSB of number
3137:23616+4	14A8  B7      	        OR      A               ; Zero?
3138:23620+10	14A9  C21609  	        JP      NZ,FCERR        ; No - Error
3139:23630+6	14AC  2B      	        DEC     HL              ; DEC 'cos GETCHR INCs
3140:23636+17	14AD  CD4F08  	        CALL    GETCHR          ; Get next character
3141:23653+4	14B0  7B      	        LD      A,E             ; Get number to A
3142:23657+10	14B1  C9      	        RET
3143:				
3144:23667+17	14B2  CD0109  	PEEK:   CALL    DEINT           ; Get memory address
3145:23684+7	14B5  1A      	        LD      A,(DE)          ; Get byte in memory
3146:23691+10	14B6  C3E110  	        JP      PASSA           ; Return integer A
3147:				
3148:23701+17	14B9  CDF60C  	POKE:   CALL    GETNUM          ; Get memory address
3149:23718+17	14BC  CD0109  	        CALL    DEINT           ; Get integer -32768 to 3276
3150:23735+11	14BF  D5      	        PUSH    DE              ; Save memory address
3151:23746+17	14C0  CDBC06  	        CALL    CHKSYN          ; Make sure ',' follows
3152:     -	14C3  2C      	        .BYTE   ','
3153:23763+17	14C4  CDA114  	        CALL    GETINT          ; Get integer 0-255
3154:23780+10	14C7  D1      	        POP     DE              ; Restore memory address
3155:23790+7	14C8  12      	        LD      (DE),A          ; Load it into memory
3156:23797+10	14C9  C9      	        RET
3157:				
3158:23807+10	14CA  21C119  	ROUND:  LD      HL,HALF         ; Add 0.5 to FPREG
3159:23817+17	14CD  CD8917  	ADDPHL: CALL    LOADFP          ; Load FP at (HL) to BCDE
3160:23834+10	14D0  C3DC14  	        JP      FPADD           ; Add BCDE to FPREG
3161:				
3162:23844+17	14D3  CD8917  	SUBPHL: CALL    LOADFP          ; FPREG = -FPREG + number at HL
3163:     -	14D6  21      	        .BYTE   21H             ; Skip "POP BC" and "POP DE"
3164:23861+10	14D7  C1      	PSUB:   POP     BC              ; Get FP number from stack
3165:23871+10	14D8  D1      	        POP     DE
3166:23881+17	14D9  CD6817  	SUBCDE: CALL    INVSGN          ; Negate FPREG
3167:23898+4	14DC  78      	FPADD:  LD      A,B             ; Get FP exponent
3168:23902+4	14DD  B7      	        OR      A               ; Is number zero?
3169:23906+5+6	14DE  C8      	        RET     Z               ; Yes - Nothing to add
3170:23911+13	14DF  3AC11E  	        LD      A,(FPEXP)       ; Get exponent of FPREG
3171:23924+4	14E2  B7      	        OR      A               ; Is this number zero?
3172:23928+10	14E3  CA7915  	        JP      Z,FPBCDE        ; Yes - Move BCDE to FPREG
3173:23938+4	14E6  90      	        SUB     B               ; BCDE number larger?
3174:23942+10	14E7  D2FE14  	        JP      NC,NOSWAP       ; No - Don't swap them
3175:23952+4	14EA  2F      	        CPL                     ; Two's complement
3176:23956+4	14EB  3C      	        INC     A               ; FP exponent
3177:23960+16	14EC  2ABE1E  	        LD      HL,(FPREG)      ; LSB,NLSB of FPREG
3178:23976+11	14EF  E5      	        PUSH    HL              ; Stack them
3179:23987+16	14F0  2AC01E  	        LD      HL,(FPREG+2)    ; MSB and exponent of FPREG
3180:24003+11	14F3  E5      	        PUSH    HL              ; Stack them
3181:24014+20	14F4  ED53BE1E	        LD      (FPREG),DE      ; Move BCDE to FPREG
3182:24034+20	14F8  ED43C01E	        LD      (FPREG+2),BC
3183:24054+10	14FC  C1      	        POP     BC              ; Restore number from stack
3184:24064+10	14FD  D1      	        POP     DE
3185:24074+7	14FE  FE19    	NOSWAP: CP      24+1            ; Second number insignificant?
3186:24081+5+6	1500  D0      	        RET     NC              ; Yes - First number is result
3187:24086+11	1501  F5      	        PUSH    AF              ; Save number of bits to scale
3188:24097+17	1502  CD9217  	        CALL    SIGNS           ; Set MSBs & sign of result
3189:24114+4	1505  67      	        LD      H,A             ; Save sign of result
3190:24118+10	1506  F1      	        POP     AF              ; Restore scaling factor
3191:24128+17	1507  CDAF15  	        CALL    SCALE           ; Scale BCDE to same exponent
3192:24145+4	150A  B4      	        OR      H               ; Result to be positive?
3193:24149+10	150B  21BE1E  	        LD      HL,FPREG        ; Point to FPREG
3194:24159+10	150E  F22415  	        JP      P,MINCDE        ; No - Subtract FPREG from CDE
3195:24169+17	1511  CD8F15  	        CALL    PLUCDE          ; Add FPREG to CDE
3196:24186+10	1514  D26A15  	        JP      NC,RONDUP       ; No overflow - Round it up
3197:24196+6	1517  23      	        INC     HL              ; Point to exponent
3198:24202+11	1518  34      	        INC     (HL)            ; Increment it
3199:24213+10	1519  CAFA03  	        JP      Z,OVERR         ; Number overflowed - Error
3200:24223+7	151C  2E01    	        LD      L,1             ; 1 bit to shift right
3201:24230+17	151E  CDC515  	        CALL    SHRT1           ; Shift result right
3202:24247+10	1521  C36A15  	        JP      RONDUP          ; Round it up
3203:				
3204:24257+4	1524  AF      	MINCDE: XOR     A               ; Clear A and carry
3205:24261+4	1525  90      	        SUB     B               ; Negate exponent
3206:24265+4	1526  47      	        LD      B,A             ; Re-save exponent
3207:24269+7	1527  7E      	        LD      A,(HL)          ; Get LSB of FPREG
3208:24276+4	1528  9B      	        SBC     A, E            ; Subtract LSB of BCDE
3209:24280+4	1529  5F      	        LD      E,A             ; Save LSB of BCDE
3210:24284+6	152A  23      	        INC     HL
3211:24290+7	152B  7E      	        LD      A,(HL)          ; Get NMSB of FPREG
3212:24297+4	152C  9A      	        SBC     A,D             ; Subtract NMSB of BCDE
3213:24301+4	152D  57      	        LD      D,A             ; Save NMSB of BCDE
3214:24305+6	152E  23      	        INC     HL
3215:24311+7	152F  7E      	        LD      A,(HL)          ; Get MSB of FPREG
3216:24318+4	1530  99      	        SBC     A,C             ; Subtract MSB of BCDE
3217:24322+4	1531  4F      	        LD      C,A             ; Save MSB of BCDE
3218:24326+10+7	1532  DC9B15  	CONPOS: CALL    C,COMPL         ; Overflow - Make it positive
3219:				
3220:24336+4	1535  68      	BNORM:  LD      L,B             ; L = Exponent
3221:24340+4	1536  63      	        LD      H,E             ; H = LSB
3222:24344+4	1537  AF      	        XOR     A
3223:24348+4	1538  47      	BNRMLP: LD      B,A             ; Save bit count
3224:24352+4	1539  79      	        LD      A,C             ; Get MSB
3225:24356+4	153A  B7      	        OR      A               ; Is it zero?
3226:24360+10	153B  C25715  	        JP      NZ,PNORM        ; No - Do it bit at a time
3227:24370+4	153E  4A      	        LD      C,D             ; MSB = NMSB
3228:24374+4	153F  54      	        LD      D,H             ; NMSB= LSB
3229:24378+4	1540  65      	        LD      H,L             ; LSB = VLSB
3230:24382+4	1541  6F      	        LD      L,A             ; VLSB= 0
3231:24386+4	1542  78      	        LD      A,B             ; Get exponent
3232:24390+7	1543  D608    	        SUB     8               ; Count 8 bits
3233:24397+7	1545  FEE0    	        CP      -24-8           ; Was number zero?
3234:24404+10	1547  C23815  	        JP      NZ,BNRMLP       ; No - Keep normalising
3235:24414+4	154A  AF      	RESZER: XOR     A               ; Result is zero
3236:24418+13	154B  32C11E  	SAVEXP: LD      (FPEXP),A       ; Save result as zero
3237:24431+10	154E  C9      	        RET
3238:				
3239:24441+4	154F  05      	NORMAL: DEC     B               ; Count bits
3240:24445+11	1550  29      	        ADD     HL,HL           ; Shift HL left
3241:24456+4	1551  7A      	        LD      A,D             ; Get NMSB
3242:24460+4	1552  17      	        RLA                     ; Shift left with last bit
3243:24464+4	1553  57      	        LD      D,A             ; Save NMSB
3244:24468+4	1554  79      	        LD      A,C             ; Get MSB
3245:24472+4	1555  8F      	        ADC     A,A             ; Shift left with last bit
3246:24476+4	1556  4F      	        LD      C,A             ; Save MSB
3247:24480+10	1557  F24F15  	PNORM:  JP      P,NORMAL        ; Not done - Keep going
3248:24490+4	155A  78      	        LD      A,B             ; Number of bits shifted
3249:24494+4	155B  5C      	        LD      E,H             ; Save HL in EB
3250:24498+4	155C  45      	        LD      B,L
3251:24502+4	155D  B7      	        OR      A               ; Any shifting done?
3252:24506+10	155E  CA6A15  	        JP      Z,RONDUP        ; No - Round it up
3253:24516+10	1561  21C11E  	        LD      HL,FPEXP        ; Point to exponent
3254:24526+7	1564  86      	        ADD     A,(HL)          ; Add shifted bits
3255:24533+7	1565  77      	        LD      (HL),A          ; Re-save exponent
3256:24540+10	1566  D24A15  	        JP      NC,RESZER       ; Underflow - Result is zero
3257:24550+5+6	1569  C8      	        RET     Z               ; Result is zero
3258:24555+4	156A  78      	RONDUP: LD      A,B             ; Get VLSB of number
3259:24559+10	156B  21C11E  	RONDB:  LD      HL,FPEXP        ; Point to exponent
3260:24569+4	156E  B7      	        OR      A               ; Any rounding?
3261:24573+10+7	156F  FC8215  	        CALL    M,FPROND        ; Yes - Round number up
3262:24583+7	1572  46      	        LD      B,(HL)          ; B = Exponent
3263:24590+6	1573  23      	        INC     HL
3264:24596+7	1574  7E      	        LD      A,(HL)          ; Get sign of result
3265:24603+7	1575  E680    	        AND     10000000B       ; Only bit 7 needed
3266:24610+4	1577  A9      	        XOR     C               ; Set correct sign
3267:24614+4	1578  4F      	        LD      C,A             ; Save correct sign in number
3268:24618+20	1579  ED53BE1E	FPBCDE: LD      (FPREG),DE      ; Move BCDE to FPREG
3269:24638+20	157D  ED43C01E	        LD      (FPREG+2),BC
3270:24658+10	1581  C9      	        RET
3271:				
3272:24668+4	1582  1C      	FPROND: INC     E               ; Round LSB
3273:24672+5+6	1583  C0      	        RET     NZ              ; Return if ok
3274:24677+4	1584  14      	        INC     D               ; Round NMSB
3275:24681+5+6	1585  C0      	        RET     NZ              ; Return if ok
3276:24686+4	1586  0C      	        INC     C               ; Round MSB
3277:24690+5+6	1587  C0      	        RET     NZ              ; Return if ok
3278:24695+7	1588  0E80    	        LD      C,80H           ; Set normal value
3279:24702+11	158A  34      	        INC     (HL)            ; Increment exponent
3280:24713+5+6	158B  C0      	        RET     NZ              ; Return if ok
3281:24718+10	158C  C3FA03  	        JP      OVERR           ; Overflow error
3282:				
3283:24728+7	158F  7E      	PLUCDE: LD      A,(HL)          ; Get LSB of FPREG
3284:24735+4	1590  83      	        ADD     A,E             ; Add LSB of BCDE
3285:24739+4	1591  5F      	        LD      E,A             ; Save LSB of BCDE
3286:24743+6	1592  23      	        INC     HL
3287:24749+7	1593  7E      	        LD      A,(HL)          ; Get NMSB of FPREG
3288:24756+4	1594  8A      	        ADC     A,D             ; Add NMSB of BCDE
3289:24760+4	1595  57      	        LD      D,A             ; Save NMSB of BCDE
3290:24764+6	1596  23      	        INC     HL
3291:24770+7	1597  7E      	        LD      A,(HL)          ; Get MSB of FPREG
3292:24777+4	1598  89      	        ADC     A,C             ; Add MSB of BCDE
3293:24781+4	1599  4F      	        LD      C,A             ; Save MSB of BCDE
3294:24785+10	159A  C9      	        RET
3295:				
3296:24795+10	159B  21C21E  	COMPL:  LD      HL,SGNRES       ; Sign of result
3297:24805+7	159E  7E      	        LD      A,(HL)          ; Get sign of result
3298:24812+4	159F  2F      	        CPL                     ; Negate it
3299:24816+7	15A0  77      	        LD      (HL),A          ; Put it back
3300:24823+4	15A1  AF      	        XOR     A
3301:24827+4	15A2  6F      	        LD      L,A             ; Set L to zero
3302:24831+4	15A3  90      	        SUB     B               ; Negate exponent,set carry
3303:24835+4	15A4  47      	        LD      B,A             ; Re-save exponent
3304:24839+4	15A5  7D      	        LD      A,L             ; Load zero
3305:24843+4	15A6  9B      	        SBC     A,E             ; Negate LSB
3306:24847+4	15A7  5F      	        LD      E,A             ; Re-save LSB
3307:24851+4	15A8  7D      	        LD      A,L             ; Load zero
3308:24855+4	15A9  9A      	        SBC     A,D             ; Negate NMSB
3309:24859+4	15AA  57      	        LD      D,A             ; Re-save NMSB
3310:24863+4	15AB  7D      	        LD      A,L             ; Load zero
3311:24867+4	15AC  99      	        SBC     A,C             ; Negate MSB
3312:24871+4	15AD  4F      	        LD      C,A             ; Re-save MSB
3313:24875+10	15AE  C9      	        RET
3314:				
3315:24885+7	15AF  0600    	SCALE:  LD      B,0             ; Clear underflow
3316:24892+7	15B1  D608    	SCALLP: SUB     8               ; 8 bits (a whole byte)?
3317:24899+10	15B3  DABE15  	        JP      C,SHRITE        ; No - Shift right A bits
3318:24909+4	15B6  43      	        LD      B,E             ; <- Shift
3319:24913+4	15B7  5A      	        LD      E,D             ; <- right
3320:24917+4	15B8  51      	        LD      D,C             ; <- eight
3321:24921+7	15B9  0E00    	        LD      C,0             ; <- bits
3322:24928+10	15BB  C3B115  	        JP      SCALLP          ; More bits to shift
3323:				
3324:24938+7	15BE  C609    	SHRITE: ADD     A,8+1           ; Adjust count
3325:24945+4	15C0  6F      	        LD      L,A             ; Save bits to shift
3326:24949+4	15C1  AF      	SHRLP:  XOR     A               ; Flag for all done
3327:24953+4	15C2  2D      	        DEC     L               ; All shifting done?
3328:24957+5+6	15C3  C8      	        RET     Z               ; Yes - Return
3329:24962+4	15C4  79      	        LD      A,C             ; Get MSB
3330:24966+4	15C5  1F      	SHRT1:  RRA                     ; Shift it right
3331:24970+4	15C6  4F      	        LD      C,A             ; Re-save
3332:24974+4	15C7  7A      	        LD      A,D             ; Get NMSB
3333:24978+4	15C8  1F      	        RRA                     ; Shift right with last bit
3334:24982+4	15C9  57      	        LD      D,A             ; Re-save it
3335:24986+4	15CA  7B      	        LD      A,E             ; Get LSB
3336:24990+4	15CB  1F      	        RRA                     ; Shift right with last bit
3337:24994+4	15CC  5F      	        LD      E,A             ; Re-save it
3338:24998+4	15CD  78      	        LD      A,B             ; Get underflow
3339:25002+4	15CE  1F      	        RRA                     ; Shift right with last bit
3340:25006+4	15CF  47      	        LD      B,A             ; Re-save underflow
3341:25010+10	15D0  C3C115  	        JP      SHRLP           ; More bits to do
3342:				
3343:     -	15D3  00000081	UNITY:  .BYTE   000H,000H,000H,081H     ; 1.00000
3344:				
3345:     -	15D7  03      	LOGTAB: .BYTE   3                       ; Table used by LOG
3346:     -	15D8  AA561980	        .BYTE   0AAH,056H,019H,080H     ; 0.59898
3347:     -	15DC  F1227680	        .BYTE   0F1H,022H,076H,080H     ; 0.96147
3348:     -	15E0  45AA3882	        .BYTE   045H,0AAH,038H,082H     ; 2.88539
3349:				
3350:25020+17	15E4  CD3F17  	LOG:    CALL    TSTSGN          ; Test sign of value
3351:25037+4	15E7  B7      	        OR      A
3352:25041+10	15E8  EA1609  	        JP      PE,FCERR        ; ?FC Error if <= zero
3353:25051+10	15EB  21C11E  	        LD      HL,FPEXP        ; Point to exponent
3354:25061+7	15EE  7E      	        LD      A,(HL)          ; Get exponent
3355:25068+10	15EF  013580  	        LD      BC,8035H        ; BCDE = SQR(1/2)
3356:25078+10	15F2  11F304  	        LD      DE,04F3H
3357:25088+4	15F5  90      	        SUB     B               ; Scale value to be < 1
3358:25092+11	15F6  F5      	        PUSH    AF              ; Save scale factor
3359:25103+7	15F7  70      	        LD      (HL),B          ; Save new exponent
3360:25110+11	15F8  D5      	        PUSH    DE              ; Save SQR(1/2)
3361:25121+11	15F9  C5      	        PUSH    BC
3362:25132+17	15FA  CDDC14  	        CALL    FPADD           ; Add SQR(1/2) to value
3363:25149+10	15FD  C1      	        POP     BC              ; Restore SQR(1/2)
3364:25159+10	15FE  D1      	        POP     DE
3365:25169+4	15FF  04      	        INC     B               ; Make it SQR(2)
3366:25173+17	1600  CD9016  	        CALL    DVBCDE          ; Divide by SQR(2)
3367:25190+10	1603  21D315  	        LD      HL,UNITY        ; Point to 1.
3368:25200+17	1606  CDD314  	        CALL    SUBPHL          ; Subtract FPREG from 1
3369:25217+10	1609  21D715  	        LD      HL,LOGTAB       ; Coefficient table
3370:25227+17	160C  CD981A  	        CALL    SUMSER          ; Evaluate sum of series
3371:25244+10	160F  018080  	        LD      BC,8080H        ; BCDE = -0.5
3372:25254+10	1612  110000  	        LD      DE,0000H
3373:25264+17	1615  CDDC14  	        CALL    FPADD           ; Subtract 0.5 from FPREG
3374:25281+10	1618  F1      	        POP     AF              ; Restore scale factor
3375:25291+17	1619  CDAB18  	        CALL    RSCALE          ; Re-scale number
3376:25308+10	161C  013180  	MULLN2: LD      BC,8031H        ; BCDE = Ln(2)
3377:25318+10	161F  111872  	        LD      DE,7218H
3378:     -	1622  21      	        .BYTE   21H             ; Skip "POP BC" and "POP DE"
3379:				
3380:25328+10	1623  C1      	MULT:   POP     BC              ; Get number from stack
3381:25338+10	1624  D1      	        POP     DE
3382:25348+17	1625  CD3F17  	FPMULT: CALL    TSTSGN          ; Test sign of FPREG
3383:25365+5+6	1628  C8      	        RET     Z               ; Return zero if zero
3384:25370+7	1629  2E00    	        LD      L,0             ; Flag add exponents
3385:25377+17	162B  CDF816  	        CALL    ADDEXP          ; Add exponents
3386:25394+4	162E  79      	        LD      A,C             ; Get MSB of multiplier
3387:25398+13	162F  32D01E  	        LD      (MULVAL),A      ; Save MSB of multiplier
3388:25411+4	1632  EB      	        EX      DE,HL
3389:25415+16	1633  22D11E  	        LD      (MULVAL+1),HL   ; Save rest of multiplier
3390:25431+10	1636  010000  	        LD      BC,0            ; Partial product (BCDE) = zero
3391:25441+4	1639  50      	        LD      D,B
3392:25445+4	163A  58      	        LD      E,B
3393:25449+10	163B  213515  	        LD      HL,BNORM        ; Address of normalise
3394:25459+11	163E  E5      	        PUSH    HL              ; Save for return
3395:25470+10	163F  214716  	        LD      HL,MULT8        ; Address of 8 bit multiply
3396:25480+11	1642  E5      	        PUSH    HL              ; Save for NMSB,MSB
3397:25491+11	1643  E5      	        PUSH    HL              ; 
3398:25502+10	1644  21BE1E  	        LD      HL,FPREG        ; Point to number
3399:25512+7	1647  7E      	MULT8:  LD      A,(HL)          ; Get LSB of number
3400:25519+6	1648  23      	        INC     HL              ; Point to NMSB
3401:25525+4	1649  B7      	        OR      A               ; Test LSB
3402:25529+10	164A  CA7316  	        JP      Z,BYTSFT        ; Zero - shift to next byte
3403:25539+11	164D  E5      	        PUSH    HL              ; Save address of number
3404:25550+7	164E  2E08    	        LD      L,8             ; 8 bits to multiply by
3405:25557+4	1650  1F      	MUL8LP: RRA                     ; Shift LSB right
3406:25561+4	1651  67      	        LD      H,A             ; Save LSB
3407:25565+4	1652  79      	        LD      A,C             ; Get MSB
3408:25569+10	1653  D26116  	        JP      NC,NOMADD       ; Bit was zero - Don't add
3409:25579+11	1656  E5      	        PUSH    HL              ; Save LSB and count
3410:25590+16	1657  2AD11E  	        LD      HL,(MULVAL+1)   ; Get LSB and NMSB
3411:25606+11	165A  19      	        ADD     HL,DE           ; Add NMSB and LSB
3412:25617+4	165B  EB      	        EX      DE,HL           ; Leave sum in DE
3413:25621+10	165C  E1      	        POP     HL              ; Restore MSB and count
3414:25631+13	165D  3AD01E  	        LD      A,(MULVAL)      ; Get MSB of multiplier
3415:25644+4	1660  89      	        ADC     A,C             ; Add MSB
3416:25648+4	1661  1F      	NOMADD: RRA                     ; Shift MSB right
3417:25652+4	1662  4F      	        LD      C,A             ; Re-save MSB
3418:25656+4	1663  7A      	        LD      A,D             ; Get NMSB
3419:25660+4	1664  1F      	        RRA                     ; Shift NMSB right
3420:25664+4	1665  57      	        LD      D,A             ; Re-save NMSB
3421:25668+4	1666  7B      	        LD      A,E             ; Get LSB
3422:25672+4	1667  1F      	        RRA                     ; Shift LSB right
3423:25676+4	1668  5F      	        LD      E,A             ; Re-save LSB
3424:25680+4	1669  78      	        LD      A,B             ; Get VLSB
3425:25684+4	166A  1F      	        RRA                     ; Shift VLSB right
3426:25688+4	166B  47      	        LD      B,A             ; Re-save VLSB
3427:25692+4	166C  2D      	        DEC     L               ; Count bits multiplied
3428:25696+4	166D  7C      	        LD      A,H             ; Get LSB of multiplier
3429:25700+10	166E  C25016  	        JP      NZ,MUL8LP       ; More - Do it
3430:25710+10	1671  E1      	        POP     HL              ; Restore address of number
3431:25720+10	1672  C9      	        RET
3432:				
3433:25730+4	1673  43      	BYTSFT: LD      B,E             ; Shift partial product left
3434:25734+4	1674  5A      	        LD      E,D
3435:25738+4	1675  51      	        LD      D,C
3436:25742+4	1676  4F      	        LD      C,A
3437:25746+10	1677  C9      	        RET
3438:				
3439:25756+16	1678  2ABE1E  	DIV10:  LD      HL,(FPREG)      ; LSB,NLSB of FPREG
3440:25772+11	167B  E5      	        PUSH    HL              ; Stack them
3441:25783+16	167C  2AC01E  	        LD      HL,(FPREG+2)    ; MSB and exponent of FPREG
3442:25799+11	167F  E5      	        PUSH    HL              ; Stack them
3443:25810+10	1680  012084  	        LD      BC,8420H        ; BCDE = 10.
3444:25820+10	1683  110000  	        LD      DE,0000H
3445:25830+20	1686  ED53BE1E	        LD      (FPREG),DE      ; Move 10 to FPREG
3446:25850+20	168A  ED43C01E	        LD      (FPREG+2),BC
3447:				
3448:25870+10	168E  C1      	DIV:    POP     BC              ; Get number from stack
3449:25880+10	168F  D1      	        POP     DE
3450:25890+17	1690  CD3F17  	DVBCDE: CALL    TSTSGN          ; Test sign of FPREG
3451:25907+10	1693  CAEE03  	        JP      Z,DZERR         ; Error if division by zero
3452:25917+7	1696  2EFF    	        LD      L,-1            ; Flag subtract exponents
3453:25924+17	1698  CDF816  	        CALL    ADDEXP          ; Subtract exponents
3454:25941+11	169B  34      	        INC     (HL)            ; Add 2 to exponent to adjust
3455:25952+11	169C  34      	        INC     (HL)
3456:25963+6	169D  2B      	        DEC     HL              ; Point to MSB
3457:25969+7	169E  7E      	        LD      A,(HL)          ; Get MSB of dividend
3458:25976+13	169F  32F51D  	        LD      (DIV3),A        ; Save for subtraction
3459:25989+6	16A2  2B      	        DEC     HL
3460:25995+7	16A3  7E      	        LD      A,(HL)          ; Get NMSB of dividend
3461:26002+13	16A4  32F11D  	        LD      (DIV2),A        ; Save for subtraction
3462:26015+6	16A7  2B      	        DEC     HL
3463:26021+7	16A8  7E      	        LD      A,(HL)          ; Get MSB of dividend
3464:26028+13	16A9  32ED1D  	        LD      (DIV1),A        ; Save for subtraction
3465:26041+4	16AC  41      	        LD      B,C             ; Get MSB
3466:26045+4	16AD  EB      	        EX      DE,HL           ; NMSB,LSB to HL
3467:26049+4	16AE  AF      	        XOR     A
3468:26053+4	16AF  4F      	        LD      C,A             ; Clear MSB of quotient
3469:26057+4	16B0  57      	        LD      D,A             ; Clear NMSB of quotient
3470:26061+4	16B1  5F      	        LD      E,A             ; Clear LSB of quotient
3471:26065+13	16B2  32F81D  	        LD      (DIV4),A        ; Clear overflow count
3472:26078+11	16B5  E5      	DIVLP:  PUSH    HL              ; Save divisor
3473:26089+11	16B6  C5      	        PUSH    BC
3474:26100+4	16B7  7D      	        LD      A,L             ; Get LSB of number
3475:26104+17	16B8  CDEC1D  	        CALL    DIVSUP          ; Subt' divisor from dividend
3476:26121+7	16BB  DE00    	        SBC     A,0             ; Count for overflows
3477:26128+4	16BD  3F      	        CCF
3478:26132+10	16BE  D2C816  	        JP      NC,RESDIV       ; Restore divisor if borrow
3479:26142+13	16C1  32F81D  	        LD      (DIV4),A        ; Re-save overflow count
3480:26155+10	16C4  F1      	        POP     AF              ; Scrap divisor
3481:26165+10	16C5  F1      	        POP     AF
3482:26175+4	16C6  37      	        SCF                     ; Set carry to
3483:     -	16C7  D2      	        .BYTE   0D2H            ; Skip "POP BC" and "POP HL"
3484:				
3485:26179+10	16C8  C1      	RESDIV: POP     BC              ; Restore divisor
3486:26189+10	16C9  E1      	        POP     HL
3487:26199+4	16CA  79      	        LD      A,C             ; Get MSB of quotient
3488:26203+4	16CB  3C      	        INC     A
3489:26207+4	16CC  3D      	        DEC     A
3490:26211+4	16CD  1F      	        RRA                     ; Bit 0 to bit 7
3491:26215+10	16CE  FA6B15  	        JP      M,RONDB         ; Done - Normalise result
3492:26225+4	16D1  17      	        RLA                     ; Restore carry
3493:26229+4	16D2  7B      	        LD      A,E             ; Get LSB of quotient
3494:26233+4	16D3  17      	        RLA                     ; Double it
3495:26237+4	16D4  5F      	        LD      E,A             ; Put it back
3496:26241+4	16D5  7A      	        LD      A,D             ; Get NMSB of quotient
3497:26245+4	16D6  17      	        RLA                     ; Double it
3498:26249+4	16D7  57      	        LD      D,A             ; Put it back
3499:26253+4	16D8  79      	        LD      A,C             ; Get MSB of quotient
3500:26257+4	16D9  17      	        RLA                     ; Double it
3501:26261+4	16DA  4F      	        LD      C,A             ; Put it back
3502:26265+11	16DB  29      	        ADD     HL,HL           ; Double NMSB,LSB of divisor
3503:26276+4	16DC  78      	        LD      A,B             ; Get MSB of divisor
3504:26280+4	16DD  17      	        RLA                     ; Double it
3505:26284+4	16DE  47      	        LD      B,A             ; Put it back
3506:26288+13	16DF  3AF81D  	        LD      A,(DIV4)        ; Get VLSB of quotient
3507:26301+4	16E2  17      	        RLA                     ; Double it
3508:26305+13	16E3  32F81D  	        LD      (DIV4),A        ; Put it back
3509:26318+4	16E6  79      	        LD      A,C             ; Get MSB of quotient
3510:26322+4	16E7  B2      	        OR      D               ; Merge NMSB
3511:26326+4	16E8  B3      	        OR      E               ; Merge LSB
3512:26330+10	16E9  C2B516  	        JP      NZ,DIVLP        ; Not done - Keep dividing
3513:26340+11	16EC  E5      	        PUSH    HL              ; Save divisor
3514:26351+10	16ED  21C11E  	        LD      HL,FPEXP        ; Point to exponent
3515:26361+11	16F0  35      	        DEC     (HL)            ; Divide by 2
3516:26372+10	16F1  E1      	        POP     HL              ; Restore divisor
3517:26382+10	16F2  C2B516  	        JP      NZ,DIVLP        ; Ok - Keep going
3518:26392+10	16F5  C3FA03  	        JP      OVERR           ; Overflow error
3519:				
3520:26402+4	16F8  78      	ADDEXP: LD      A,B             ; Get exponent of dividend
3521:26406+4	16F9  B7      	        OR      A               ; Test it
3522:26410+10	16FA  CA1C17  	        JP      Z,OVTST3        ; Zero - Result zero
3523:26420+4	16FD  7D      	        LD      A,L             ; Get add/subtract flag
3524:26424+10	16FE  21C11E  	        LD      HL,FPEXP        ; Point to exponent
3525:26434+7	1701  AE      	        XOR     (HL)            ; Add or subtract it
3526:26441+4	1702  80      	        ADD     A,B             ; Add the other exponent
3527:26445+4	1703  47      	        LD      B,A             ; Save new exponent
3528:26449+4	1704  1F      	        RRA                     ; Test exponent for overflow
3529:26453+4	1705  A8      	        XOR     B
3530:26457+4	1706  78      	        LD      A,B             ; Get exponent
3531:26461+10	1707  F21B17  	        JP      P,OVTST2        ; Positive - Test for overflow
3532:26471+7	170A  C680    	        ADD     A,80H           ; Add excess 128
3533:26478+7	170C  77      	        LD      (HL),A          ; Save new exponent
3534:26485+10	170D  CA7513  	        JP      Z,POPHRT        ; Zero - Result zero
3535:26495+17	1710  CD9217  	        CALL    SIGNS           ; Set MSBs and sign of result
3536:26512+7	1713  77      	        LD      (HL),A          ; Save new exponent
3537:26519+6	1714  2B      	        DEC     HL              ; Point to MSB
3538:26525+10	1715  C9      	        RET
3539:				
3540:26535+17	1716  CD3F17  	OVTST1: CALL    TSTSGN          ; Test sign of FPREG
3541:26552+4	1719  2F      	        CPL                     ; Invert sign
3542:26556+10	171A  E1      	        POP     HL              ; Clean up stack
3543:26566+4	171B  B7      	OVTST2: OR      A               ; Test if new exponent zero
3544:26570+10	171C  E1      	OVTST3: POP     HL              ; Clear off return address
3545:26580+10	171D  F24A15  	        JP      P,RESZER        ; Result zero
3546:26590+10	1720  C3FA03  	        JP      OVERR           ; Overflow error
3547:				
3548:26600+20	1723  ED5BBE1E	MLSP10: LD      DE,(FPREG)      ; Move FPREG to BCDE
3549:26620+20	1727  ED4BC01E	        LD      BC,(FPREG+2)
3550:26640+4	172B  78      	        LD      A,B             ; Get exponent
3551:26644+4	172C  B7      	        OR      A               ; Is it zero?
3552:26648+5+6	172D  C8      	        RET     Z               ; Yes - Result is zero
3553:26653+7	172E  C602    	        ADD     A,2             ; Multiply by 4
3554:26660+10	1730  DAFA03  	        JP      C,OVERR         ; Overflow - ?OV Error
3555:26670+4	1733  47      	        LD      B,A             ; Re-save exponent
3556:26674+17	1734  CDDC14  	        CALL    FPADD           ; Add BCDE to FPREG (Times 5)
3557:26691+10	1737  21C11E  	        LD      HL,FPEXP        ; Point to exponent
3558:26701+11	173A  34      	        INC     (HL)            ; Double number (Times 10)
3559:26712+5+6	173B  C0      	        RET     NZ              ; Ok - Return
3560:26717+10	173C  C3FA03  	        JP      OVERR           ; Overflow error
3561:				
3562:26727+13	173F  3AC11E  	TSTSGN: LD      A,(FPEXP)       ; Get sign of FPREG
3563:26740+4	1742  B7      	        OR      A
3564:26744+5+6	1743  C8      	        RET     Z               ; RETurn if number is zero
3565:26749+13	1744  3AC01E  	        LD      A,(FPREG+2)     ; Get MSB of FPREG
3566:     -	1747  FE      	        .BYTE   0FEH            ; Test sign
3567:26762+4	1748  2F      	RETREL: CPL                     ; Invert sign
3568:26766+4	1749  17      	        RLA                     ; Sign bit to carry
3569:26770+4	174A  9F      	FLGDIF: SBC     A,A             ; Carry to all bits of A
3570:26774+5+6	174B  C0      	        RET     NZ              ; Return -1 if negative
3571:26779+4	174C  3C      	        INC     A               ; Bump to +1
3572:26783+10	174D  C9      	        RET                     ; Positive - Return +1
3573:				
3574:26793+17	174E  CD3F17  	SGN:    CALL    TSTSGN          ; Test sign of FPREG
3575:26810+7	1751  0688    	FLGREL: LD      B,80H+8         ; 8 bit integer in exponent
3576:26817+10	1753  110000  	        LD      DE,0            ; Zero NMSB and LSB
3577:26827+10	1756  21C11E  	RETINT: LD      HL,FPEXP        ; Point to exponent
3578:26837+4	1759  4F      	        LD      C,A             ; CDE = MSB,NMSB and LSB
3579:26841+7	175A  70      	        LD      (HL),B          ; Save exponent
3580:26848+7	175B  0600    	        LD      B,0             ; CDE = integer to normalise
3581:26855+6	175D  23      	        INC     HL              ; Point to sign of result
3582:26861+10	175E  3680    	        LD      (HL),80H        ; Set sign of result
3583:26871+4	1760  17      	        RLA                     ; Carry = sign of integer
3584:26875+10	1761  C33215  	        JP      CONPOS          ; Set sign of result
3585:				
3586:26885+17	1764  CD3F17  	ABS:    CALL    TSTSGN          ; Test sign of FPREG
3587:26902+5+6	1767  F0      	        RET     P               ; Return if positive
3588:26907+10	1768  21C01E  	INVSGN: LD      HL,FPREG+2      ; Point to MSB
3589:26917+7	176B  7E      	        LD      A,(HL)          ; Get sign of mantissa
3590:26924+7	176C  EE80    	        XOR     80H             ; Invert sign of mantissa
3591:26931+7	176E  77      	        LD      (HL),A          ; Re-save sign of mantissa
3592:26938+10	176F  C9      	        RET
3593:				
3594:26948+4	1770  EB      	STAKFP: EX      DE,HL           ; Save code string address
3595:26952+16	1771  2ABE1E  	        LD      HL,(FPREG)      ; LSB,NLSB of FPREG
3596:26968+19	1774  E3      	        EX      (SP),HL         ; Stack them,get return
3597:26987+11	1775  E5      	        PUSH    HL              ; Re-save return
3598:26998+16	1776  2AC01E  	        LD      HL,(FPREG+2)    ; MSB and exponent of FPREG
3599:27014+19	1779  E3      	        EX      (SP),HL         ; Stack them,get return
3600:27033+11	177A  E5      	        PUSH    HL              ; Re-save return
3601:27044+4	177B  EB      	        EX      DE,HL           ; Restore code string address
3602:27048+10	177C  C9      	        RET
3603:				
3604:27058+10	177D  11BE1E  	PHLTFP: LD      DE,FPREG        ; Number at HL to FPREG
3605:27068+16	1780  EDA0    	        LDI                     ; 4 bytes to move (HL++)->(DE++)
3606:27084+16	1782  EDA0    	        LDI
3607:27100+16	1784  EDA0    	        LDI
3608:27116+16	1786  EDA0    	        LDI
3609:27132+10	1788  C9      	        RET
3610:				
3611:27142+7	1789  5E      	LOADFP: LD      E,(HL)          ; Get LSB of number
3612:27149+6	178A  23      	        INC     HL
3613:27155+7	178B  56      	        LD      D,(HL)          ; Get NMSB of number
3614:27162+6	178C  23      	        INC     HL
3615:27168+7	178D  4E      	        LD      C,(HL)          ; Get MSB of number
3616:27175+6	178E  23      	        INC     HL
3617:27181+7	178F  46      	        LD      B,(HL)          ; Get exponent of number
3618:27188+6	1790  23      	INCHL:  INC     HL              ; Used for conditional "INC HL"
3619:27194+10	1791  C9      	        RET
3620:				
3621:27204+10	1792  21C01E  	SIGNS:  LD      HL,FPREG+2      ; Point to MSB of FPREG
3622:27214+7	1795  7E      	        LD      A,(HL)          ; Get MSB
3623:27221+4	1796  07      	        RLCA                    ; Old sign to carry
3624:27225+4	1797  37      	        SCF                     ; Set MSBit
3625:27229+4	1798  1F      	        RRA                     ; Set MSBit of MSB
3626:27233+7	1799  77      	        LD      (HL),A          ; Save new MSB
3627:27240+4	179A  3F      	        CCF                     ; Complement sign
3628:27244+4	179B  1F      	        RRA                     ; Old sign to carry
3629:27248+6	179C  23      	        INC     HL
3630:27254+6	179D  23      	        INC     HL
3631:27260+7	179E  77      	        LD      (HL),A          ; Set sign of result SGNRES
3632:27267+4	179F  79      	        LD      A,C             ; Get MSB
3633:27271+4	17A0  07      	        RLCA                    ; Old sign to carry
3634:27275+4	17A1  37      	        SCF                     ; Set MSBit
3635:27279+4	17A2  1F      	        RRA                     ; Set MSBit of MSB
3636:27283+4	17A3  4F      	        LD      C,A             ; Save MSB
3637:27287+4	17A4  1F      	        RRA
3638:27291+7	17A5  AE      	        XOR     (HL)            ; New sign of result
3639:27298+10	17A6  C9      	        RET
3640:				
3641:27308+4	17A7  78      	CMPNUM: LD      A,B             ; Get exponent of number
3642:27312+4	17A8  B7      	        OR      A
3643:27316+10	17A9  CA3F17  	        JP      Z,TSTSGN        ; Zero - Test sign of FPREG
3644:27326+10	17AC  214817  	        LD      HL,RETREL       ; Return relation routine
3645:27336+11	17AF  E5      	        PUSH    HL              ; Save for return
3646:27347+17	17B0  CD3F17  	        CALL    TSTSGN          ; Test sign of FPREG
3647:27364+4	17B3  79      	        LD      A,C             ; Get MSB of number
3648:27368+5+6	17B4  C8      	        RET     Z               ; FPREG zero - Number's MSB
3649:27373+10	17B5  21C01E  	        LD      HL,FPREG+2      ; MSB of FPREG
3650:27383+7	17B8  AE      	        XOR     (HL)            ; Combine signs
3651:27390+4	17B9  79      	        LD      A,C             ; Get MSB of number
3652:27394+5+6	17BA  F8      	        RET     M               ; Exit if signs different
3653:27399+17	17BB  CDC117  	        CALL    CMPFP           ; Compare FP numbers
3654:27416+4	17BE  1F      	        RRA                     ; Get carry to sign
3655:27420+4	17BF  A9      	        XOR     C               ; Combine with MSB of number
3656:27424+10	17C0  C9      	        RET
3657:				
3658:27434+6	17C1  23      	CMPFP:  INC     HL              ; Point to exponent
3659:27440+4	17C2  78      	        LD      A,B             ; Get exponent
3660:27444+7	17C3  BE      	        CP      (HL)            ; Compare exponents
3661:27451+5+6	17C4  C0      	        RET     NZ              ; Different
3662:27456+6	17C5  2B      	        DEC     HL              ; Point to MBS
3663:27462+4	17C6  79      	        LD      A,C             ; Get MSB
3664:27466+7	17C7  BE      	        CP      (HL)            ; Compare MSBs
3665:27473+5+6	17C8  C0      	        RET     NZ              ; Different
3666:27478+6	17C9  2B      	        DEC     HL              ; Point to NMSB
3667:27484+4	17CA  7A      	        LD      A,D             ; Get NMSB
3668:27488+7	17CB  BE      	        CP      (HL)            ; Compare NMSBs
3669:27495+5+6	17CC  C0      	        RET     NZ              ; Different
3670:27500+6	17CD  2B      	        DEC     HL              ; Point to LSB
3671:27506+4	17CE  7B      	        LD      A,E             ; Get LSB
3672:27510+7	17CF  96      	        SUB     (HL)            ; Compare LSBs
3673:27517+5+6	17D0  C0      	        RET     NZ              ; Different
3674:27522+10	17D1  E1      	        POP     HL              ; Drop RETurn
3675:27532+10	17D2  E1      	        POP     HL              ; Drop another RETurn
3676:27542+10	17D3  C9      	        RET
3677:				
3678:27552+4	17D4  47      	FPINT:  LD      B,A             ; <- Move
3679:27556+4	17D5  4F      	        LD      C,A             ; <- exponent
3680:27560+4	17D6  57      	        LD      D,A             ; <- to all
3681:27564+4	17D7  5F      	        LD      E,A             ; <- bits
3682:27568+4	17D8  B7      	        OR      A               ; Test exponent
3683:27572+5+6	17D9  C8      	        RET     Z               ; Zero - Return zero
3684:27577+11	17DA  E5      	        PUSH    HL              ; Save pointer to number
3685:27588+20	17DB  ED5BBE1E	        LD      DE,(FPREG)      ; Move FPREG to BCDE
3686:27608+20	17DF  ED4BC01E	        LD      BC,(FPREG+2)
3687:27628+17	17E3  CD9217  	        CALL    SIGNS           ; Set MSBs & sign of result
3688:27645+7	17E6  AE      	        XOR     (HL)            ; Combine with sign of FPREG
3689:27652+4	17E7  67      	        LD      H,A             ; Save combined signs
3690:27656+10+7	17E8  FCFD17  	        CALL    M,DCBCDE        ; Negative - Decrement BCDE
3691:27666+7	17EB  3E98    	        LD      A,80H+24        ; 24 bits
3692:27673+4	17ED  90      	        SUB     B               ; Bits to shift
3693:27677+17	17EE  CDAF15  	        CALL    SCALE           ; Shift BCDE
3694:27694+4	17F1  7C      	        LD      A,H             ; Get combined sign
3695:27698+4	17F2  17      	        RLA                     ; Sign to carry
3696:27702+10+7	17F3  DC8215  	        CALL    C,FPROND        ; Negative - Round number up
3697:27712+7	17F6  0600    	        LD      B,0             ; Zero exponent
3698:27719+10+7	17F8  DC9B15  	        CALL    C,COMPL         ; If negative make positive
3699:27729+10	17FB  E1      	        POP     HL              ; Restore pointer to number
3700:27739+10	17FC  C9      	        RET
3701:				
3702:27749+6	17FD  1B      	DCBCDE: DEC     DE              ; Decrement BCDE
3703:27755+4	17FE  7A      	        LD      A,D             ; Test LSBs
3704:27759+4	17FF  A3      	        AND     E
3705:27763+4	1800  3C      	        INC     A
3706:27767+5+6	1801  C0      	        RET     NZ              ; Exit if LSBs not FFFF
3707:27772+6	1802  0B      	        DEC     BC              ; Decrement MSBs
3708:27778+10	1803  C9      	        RET
3709:				
3710:27788+10	1804  21C11E  	INT:    LD      HL,FPEXP        ; Point to exponent
3711:27798+7	1807  7E      	        LD      A,(HL)          ; Get exponent
3712:27805+7	1808  FE98    	        CP      80H+24          ; Integer accuracy only?
3713:27812+13	180A  3ABE1E  	        LD      A,(FPREG)       ; Get LSB
3714:27825+5+6	180D  D0      	        RET     NC              ; Yes - Already integer
3715:27830+7	180E  7E      	        LD      A,(HL)          ; Get exponent
3716:27837+17	180F  CDD417  	        CALL    FPINT           ; F.P to integer
3717:27854+10	1812  3698    	        LD      (HL),80H+24     ; Save 24 bit integer
3718:27864+4	1814  7B      	        LD      A,E             ; Get LSB of number
3719:27868+11	1815  F5      	        PUSH    AF              ; Save LSB
3720:27879+4	1816  79      	        LD      A,C             ; Get MSB of number
3721:27883+4	1817  17      	        RLA                     ; Sign to carry
3722:27887+17	1818  CD3215  	        CALL    CONPOS          ; Set sign of result
3723:27904+10	181B  F1      	        POP     AF              ; Restore LSB of number
3724:27914+10	181C  C9      	        RET
3725:				
3726:27924+10	181D  210000  	MLDEBC: LD      HL,0            ; Clear partial product
3727:27934+4	1820  78      	        LD      A,B             ; Test multiplier
3728:27938+4	1821  B1      	        OR      C
3729:27942+5+6	1822  C8      	        RET     Z               ; Return zero if zero
3730:27947+4	1823  78      	        LD      A,B
3731:27951+7	1824  0610    	        LD      B,16            ; 16 bits (iterations)
3732:27958+11	1826  29      	MLDBLP: ADD     HL,HL           ; Shift partial product left
3733:27969+10	1827  DA1E10  	        JP      C,BSERR         ; ?BS Error if overflow
3734:27979+8	182A  CB11    	        RL      C
3735:27987+4	182C  17      	        RLA
3736:27991+10	182D  D23418  	        JP      NC,NOMLAD       ; Bit was zero - No add
3737:28001+11	1830  19      	        ADD     HL,DE
3738:28012+10	1831  DA1E10  	        JP      C,BSERR         ; ?BS Error if overflow
3739:28022+8+5	1834  10F0    	NOMLAD: DJNZ    MLDBLP
3740:28030+10	1836  C9      	        RET
3741:				
3742:28040+7	1837  FE2D    	ASCTFP: CP      '-'             ; Negative?
3743:28047+11	1839  F5      	        PUSH    AF              ; Save it and flags
3744:28058+10	183A  CA4318  	        JP      Z,CNVNUM        ; Yes - Convert number
3745:28068+7	183D  FE2B    	        CP      '+'             ; Positive?
3746:28075+10	183F  CA4318  	        JP      Z,CNVNUM        ; Yes - Convert number
3747:28085+6	1842  2B      	        DEC     HL              ; DEC 'cos GETCHR INCs
3748:28091+17	1843  CD4A15  	CNVNUM: CALL    RESZER          ; Set result to zero
3749:28108+4	1846  47      	        LD      B,A             ; Digits after point counter
3750:28112+4	1847  57      	        LD      D,A             ; Sign of exponent
3751:28116+4	1848  5F      	        LD      E,A             ; Exponent of ten
3752:28120+4	1849  2F      	        CPL
3753:28124+4	184A  4F      	        LD      C,A             ; Before or after point flag
3754:28128+17	184B  CD4F08  	MANLP:  CALL    GETCHR          ; Get next character
3755:28145+10	184E  DA9418  	        JP      C,ADDIG         ; Digit - Add to number
3756:28155+7	1851  FE2E    	        CP      '.'
3757:28162+10	1853  CA6F18  	        JP      Z,DPOINT        ; '.' - Flag point
3758:28172+7	1856  FE45    	        CP      'E'
3759:28179+10	1858  C27318  	        JP      NZ,CONEXP       ; Not 'E' - Scale number
3760:28189+17	185B  CD4F08  	        CALL    GETCHR          ; Get next character
3761:28206+17	185E  CD330E  	        CALL    SGNEXP          ; Get sign of exponent
3762:28223+17	1861  CD4F08  	EXPLP:  CALL    GETCHR          ; Get next character
3763:28240+10	1864  DABB18  	        JP      C,EDIGIT        ; Digit - Add to exponent
3764:28250+4	1867  14      	        INC     D               ; Is sign negative?
3765:28254+10	1868  C27318  	        JP      NZ,CONEXP       ; No - Scale number
3766:28264+4	186B  AF      	        XOR     A
3767:28268+4	186C  93      	        SUB     E               ; Negate exponent
3768:28272+4	186D  5F      	        LD      E,A             ; And re-save it
3769:28276+4	186E  0C      	        INC     C               ; Flag end of number
3770:28280+4	186F  0C      	DPOINT: INC     C               ; Flag point passed
3771:28284+10	1870  CA4B18  	        JP      Z,MANLP         ; Zero - Get another digit
3772:28294+11	1873  E5      	CONEXP: PUSH    HL              ; Save code string address
3773:28305+4	1874  7B      	        LD      A,E             ; Get exponent
3774:28309+4	1875  90      	        SUB     B               ; Subtract digits after point
3775:28313+10+7	1876  F48C18  	SCALMI: CALL    P,SCALPL        ; Positive - Multiply number
3776:28323+10	1879  F28218  	        JP      P,ENDCON        ; Positive - All done
3777:28333+11	187C  F5      	        PUSH    AF              ; Save number of times to /10
3778:28344+17	187D  CD7816  	        CALL    DIV10           ; Divide by 10
3779:28361+10	1880  F1      	        POP     AF              ; Restore count
3780:28371+4	1881  3C      	        INC     A               ; Count divides
3781:				
3782:28375+10	1882  C27618  	ENDCON: JP      NZ,SCALMI       ; More to do
3783:28385+10	1885  D1      	        POP     DE              ; Restore code string address
3784:28395+10	1886  F1      	        POP     AF              ; Restore sign of number
3785:28405+10+7	1887  CC6817  	        CALL    Z,INVSGN        ; Negative - Negate number
3786:28415+4	188A  EB      	        EX      DE,HL           ; Code string address to HL
3787:28419+10	188B  C9      	        RET
3788:				
3789:28429+5+6	188C  C8      	SCALPL: RET     Z               ; Exit if no scaling needed
3790:28434+11	188D  F5      	MULTEN: PUSH    AF              ; Save count
3791:28445+17	188E  CD2317  	        CALL    MLSP10          ; Multiply number by 10
3792:28462+10	1891  F1      	        POP     AF              ; Restore count
3793:28472+4	1892  3D      	        DEC     A               ; Count multiplies
3794:28476+10	1893  C9      	        RET
3795:				
3796:28486+11	1894  D5      	ADDIG:  PUSH    DE              ; Save sign of exponent
3797:28497+4	1895  57      	        LD      D,A             ; Save digit
3798:28501+4	1896  78      	        LD      A,B             ; Get digits after point
3799:28505+4	1897  89      	        ADC     A,C             ; Add one if after point
3800:28509+4	1898  47      	        LD      B,A             ; Re-save counter
3801:28513+11	1899  C5      	        PUSH    BC              ; Save point flags
3802:28524+11	189A  E5      	        PUSH    HL              ; Save code string address
3803:28535+11	189B  D5      	        PUSH    DE              ; Save digit
3804:28546+17	189C  CD2317  	        CALL    MLSP10          ; Multiply number by 10
3805:28563+10	189F  F1      	        POP     AF              ; Restore digit
3806:28573+7	18A0  D630    	        SUB     '0'             ; Make it absolute
3807:28580+17	18A2  CDAB18  	        CALL    RSCALE          ; Re-scale number
3808:28597+10	18A5  E1      	        POP     HL              ; Restore code string address
3809:28607+10	18A6  C1      	        POP     BC              ; Restore point flags
3810:28617+10	18A7  D1      	        POP     DE              ; Restore sign of exponent
3811:28627+10	18A8  C34B18  	        JP      MANLP           ; Get another digit
3812:				
3813:28637+16	18AB  2ABE1E  	RSCALE: LD      HL,(FPREG)      ; LSB,NLSB of FPREG
3814:28653+11	18AE  E5      	        PUSH    HL              ; Stack them
3815:28664+16	18AF  2AC01E  	        LD      HL,(FPREG+2)    ; MSB and exponent of FPREG
3816:28680+11	18B2  E5      	        PUSH    HL              ; Stack them
3817:28691+17	18B3  CD5117  	        CALL    FLGREL          ; Digit to add to FPREG
3818:28708+10	18B6  C1      	PADD:   POP     BC              ; Restore number
3819:28718+10	18B7  D1      	        POP     DE
3820:28728+10	18B8  C3DC14  	        JP      FPADD           ; Add BCDE to FPREG and return
3821:				
3822:28738+4	18BB  7B      	EDIGIT: LD      A,E             ; Get digit
3823:28742+4	18BC  07      	        RLCA                    ; Times 2
3824:28746+4	18BD  07      	        RLCA                    ; Times 4
3825:28750+4	18BE  83      	        ADD     A,E             ; Times 5
3826:28754+4	18BF  07      	        RLCA                    ; Times 10
3827:28758+7	18C0  86      	        ADD     A,(HL)          ; Add next digit
3828:28765+7	18C1  D630    	        SUB     '0'             ; Make it absolute
3829:28772+4	18C3  5F      	        LD      E,A             ; Save new digit
3830:28776+10	18C4  C36118  	        JP      EXPLP           ; Look for another digit
3831:				
3832:28786+11	18C7  E5      	LINEIN: PUSH    HL              ; Save code string address
3833:28797+10	18C8  217D03  	        LD      HL,INMSG        ; Output " in "
3834:28807+17	18CB  CD0212  	        CALL    PRS             ; Output string at HL
3835:28824+10	18CE  E1      	        POP     HL              ; Restore code string address
3836:28834+4	18CF  EB      	PRNTHL: EX      DE,HL           ; Code string address to DE
3837:28838+4	18D0  AF      	        XOR     A
3838:28842+7	18D1  0698    	        LD      B,80H+24        ; 24 bits
3839:28849+17	18D3  CD5617  	        CALL    RETINT          ; Return the integer
3840:28866+10	18D6  210112  	        LD      HL,PRNUMS       ; Print number string
3841:28876+11	18D9  E5      	        PUSH    HL              ; Save for return
3842:28887+10	18DA  21C31E  	NUMASC: LD      HL,PBUFF        ; Convert number to ASCII
3843:28897+11	18DD  E5      	        PUSH    HL              ; Save for return
3844:28908+17	18DE  CD3F17  	        CALL    TSTSGN          ; Test sign of FPREG
3845:28925+10	18E1  3620    	        LD      (HL),' '        ; Space at start
3846:28935+10	18E3  F2E818  	        JP      P,SPCFST        ; Positive - Space to start
3847:28945+10	18E6  362D    	        LD      (HL),'-'        ; '-' sign at start
3848:28955+6	18E8  23      	SPCFST: INC     HL              ; First byte of number
3849:28961+10	18E9  3630    	        LD      (HL),'0'        ; '0' if zero
3850:28971+10	18EB  CAAC19  	        JP      Z,JSTZER        ; Return '0' if zero
3851:28981+11	18EE  E5      	        PUSH    HL              ; Save buffer address
3852:28992+10+7	18EF  FC6817  	        CALL    M,INVSGN        ; Negate FPREG if negative
3853:29002+4	18F2  AF      	        XOR     A               ; Zero A
3854:29006+11	18F3  F5      	        PUSH    AF              ; Save it
3855:29017+17	18F4  CDB219  	        CALL    RNGTST          ; Test number is in range
3856:29034+10	18F7  014391  	SIXDIG: LD      BC,9143H        ; BCDE - 99999.9
3857:29044+10	18FA  11F84F  	        LD      DE,4FF8H
3858:29054+17	18FD  CDA717  	        CALL    CMPNUM          ; Compare numbers
3859:29071+4	1900  B7      	        OR      A
3860:29075+10	1901  E21519  	        JP      PO,INRNG        ; > 99999.9 - Sort it out
3861:29085+10	1904  F1      	        POP     AF              ; Restore count
3862:29095+17	1905  CD8D18  	        CALL    MULTEN          ; Multiply by ten
3863:29112+11	1908  F5      	        PUSH    AF              ; Re-save count
3864:29123+10	1909  C3F718  	        JP      SIXDIG          ; Test it again
3865:				
3866:29133+17	190C  CD7816  	GTSIXD: CALL    DIV10           ; Divide by 10
3867:29150+10	190F  F1      	        POP     AF              ; Get count
3868:29160+4	1910  3C      	        INC     A               ; Count divides
3869:29164+11	1911  F5      	        PUSH    AF              ; Re-save count
3870:29175+17	1912  CDB219  	        CALL    RNGTST          ; Test number is in range
3871:29192+17	1915  CDCA14  	INRNG:  CALL    ROUND           ; Add 0.5 to FPREG
3872:29209+4	1918  3C      	        INC     A
3873:29213+17	1919  CDD417  	        CALL    FPINT           ; F.P to integer
3874:29230+20	191C  ED53BE1E	        LD      (FPREG),DE      ; Move BCDE to FPREG
3875:29250+20	1920  ED43C01E	        LD      (FPREG+2),BC
3876:29270+10	1924  010603  	        LD      BC,0306H        ; 1E+06 to 1E-03 range
3877:29280+10	1927  F1      	        POP     AF              ; Restore count
3878:29290+4	1928  81      	        ADD     A,C             ; 6 digits before point
3879:29294+4	1929  3C      	        INC     A               ; Add one
3880:29298+10	192A  FA3619  	        JP      M,MAKNUM        ; Do it in 'E' form if < 1E-02
3881:29308+7	192D  FE08    	        CP      6+1+1           ; More than 999999 ?
3882:29315+10	192F  D23619  	        JP      NC,MAKNUM       ; Yes - Do it in 'E' form
3883:29325+4	1932  3C      	        INC     A               ; Adjust for exponent
3884:29329+4	1933  47      	        LD      B,A             ; Exponent of number
3885:29333+7	1934  3E02    	        LD      A,2             ; Make it zero after
3886:				
3887:29340+4	1936  3D      	MAKNUM: DEC     A               ; Adjust for digits to do
3888:29344+4	1937  3D      	        DEC     A
3889:29348+10	1938  E1      	        POP     HL              ; Restore buffer address
3890:29358+11	1939  F5      	        PUSH    AF              ; Save count
3891:29369+10	193A  11C519  	        LD      DE,POWERS       ; Powers of ten
3892:29379+4	193D  05      	        DEC     B               ; Count digits before point
3893:29383+10	193E  C24719  	        JP      NZ,DIGTXT       ; Not zero - Do number
3894:29393+10	1941  362E    	        LD      (HL),'.'        ; Save point
3895:29403+6	1943  23      	        INC     HL              ; Move on
3896:29409+10	1944  3630    	        LD      (HL),'0'        ; Save zero
3897:29419+6	1946  23      	        INC     HL              ; Move on
3898:29425+4	1947  05      	DIGTXT: DEC     B               ; Count digits before point
3899:29429+10	1948  362E    	        LD      (HL),'.'        ; Save point in case
3900:29439+10+7	194A  CC9017  	        CALL    Z,INCHL         ; Last digit - move on
3901:29449+11	194D  C5      	        PUSH    BC              ; Save digits before point
3902:29460+11	194E  E5      	        PUSH    HL              ; Save buffer address
3903:29471+4	194F  EB      	        EX      DE,HL           ; Save powers of ten table
3904:29475+20	1950  ED5BBE1E	        LD      DE,(FPREG)      ; Move FPREG to BCDE
3905:29495+20	1954  ED4BC01E	        LD      BC,(FPREG+2)
3906:29515+7	1958  062F    	        LD      B,'0'-1         ; ASCII '0' - 1
3907:29522+4	195A  04      	TRYAGN: INC     B               ; Count subtractions
3908:29526+4	195B  7B      	        LD      A,E             ; Get LSB
3909:29530+7	195C  96      	        SUB     (HL)            ; Subtract LSB
3910:29537+4	195D  5F      	        LD      E,A             ; Save LSB
3911:29541+6	195E  23      	        INC     HL
3912:29547+4	195F  7A      	        LD      A,D             ; Get NMSB
3913:29551+7	1960  9E      	        SBC     A,(HL)          ; Subtract NMSB
3914:29558+4	1961  57      	        LD      D,A             ; Save NMSB
3915:29562+6	1962  23      	        INC     HL
3916:29568+4	1963  79      	        LD      A,C             ; Get MSB
3917:29572+7	1964  9E      	        SBC     A,(HL)          ; Subtract MSB
3918:29579+4	1965  4F      	        LD      C,A             ; Save MSB
3919:29583+6	1966  2B      	        DEC     HL              ; Point back to start
3920:29589+6	1967  2B      	        DEC     HL
3921:29595+10	1968  D25A19  	        JP      NC,TRYAGN       ; No overflow - Try again
3922:29605+17	196B  CD8F15  	        CALL    PLUCDE          ; Restore number
3923:29622+6	196E  23      	        INC     HL              ; Start of next number
3924:29628+20	196F  ED53BE1E	        LD      (FPREG),DE      ; Angle to FPREG
3925:29648+20	1973  ED43C01E	        LD      (FPREG+2),BC
3926:29668+4	1977  EB      	        EX      DE,HL           ; Save point in table
3927:29672+10	1978  E1      	        POP     HL              ; Restore buffer address
3928:29682+7	1979  70      	        LD      (HL),B          ; Save digit in buffer
3929:29689+6	197A  23      	        INC     HL              ; And move on
3930:29695+10	197B  C1      	        POP     BC              ; Restore digit count
3931:29705+4	197C  0D      	        DEC     C               ; Count digits
3932:29709+10	197D  C24719  	        JP      NZ,DIGTXT       ; More - Do them
3933:29719+4	1980  05      	        DEC     B               ; Any decimal part?
3934:29723+10	1981  CA9019  	        JP      Z,DOEBIT        ; No - Do 'E' bit
3935:29733+6	1984  2B      	SUPTLZ: DEC     HL              ; Move back through buffer
3936:29739+7	1985  7E      	        LD      A,(HL)          ; Get character
3937:29746+7	1986  FE30    	        CP      '0'             ; '0' character?
3938:29753+10	1988  CA8419  	        JP      Z,SUPTLZ        ; Yes - Look back for more
3939:29763+7	198B  FE2E    	        CP      '.'             ; A decimal point?
3940:29770+10+7	198D  C49017  	        CALL    NZ,INCHL        ; Move back over digit
3941:				
3942:29780+10	1990  F1      	DOEBIT: POP     AF              ; Get 'E' flag
3943:29790+10	1991  CAAF19  	        JP      Z,NOENED        ; No 'E' needed - End buffer
3944:29800+10	1994  3645    	        LD      (HL),'E'        ; Put 'E' in buffer
3945:29810+6	1996  23      	        INC     HL              ; And move on
3946:29816+10	1997  362B    	        LD      (HL),'+'        ; Put '+' in buffer
3947:29826+10	1999  F2A019  	        JP      P,OUTEXP        ; Positive - Output exponent
3948:29836+10	199C  362D    	        LD      (HL),'-'        ; Put '-' in buffer
3949:29846+4	199E  2F      	        CPL                     ; Negate exponent
3950:29850+4	199F  3C      	        INC     A
3951:29854+7	19A0  062F    	OUTEXP: LD      B,'0'-1         ; ASCII '0' - 1
3952:29861+4	19A2  04      	EXPTEN: INC     B               ; Count subtractions
3953:29865+7	19A3  D60A    	        SUB     10              ; Tens digit
3954:29872+10	19A5  D2A219  	        JP      NC,EXPTEN       ; More to do
3955:29882+7	19A8  C63A    	        ADD     A,'0'+10        ; Restore and make ASCII
3956:29889+6	19AA  23      	        INC     HL              ; Move on
3957:29895+7	19AB  70      	        LD      (HL),B          ; Save MSB of exponent
3958:29902+6	19AC  23      	JSTZER: INC     HL              ;
3959:29908+7	19AD  77      	        LD      (HL),A          ; Save LSB of exponent
3960:29915+6	19AE  23      	        INC     HL
3961:29921+7	19AF  71      	NOENED: LD      (HL),C          ; Mark end of buffer
3962:29928+10	19B0  E1      	        POP     HL              ; Restore code string address
3963:29938+10	19B1  C9      	        RET
3964:				
3965:29948+10	19B2  017494  	RNGTST: LD      BC,9474H        ; BCDE = 999999.
3966:29958+10	19B5  11F723  	        LD      DE,23F7H
3967:29968+17	19B8  CDA717  	        CALL    CMPNUM          ; Compare numbers
3968:29985+4	19BB  B7      	        OR      A
3969:29989+10	19BC  E1      	        POP     HL              ; Return address to HL
3970:29999+10	19BD  E20C19  	        JP      PO,GTSIXD       ; Too big - Divide by ten
3971:30009+4	19C0  E9      	        JP      (HL)            ; Otherwise return to caller
3972:				
3973:     -	19C1  00000080	HALF:   .BYTE   00H,00H,00H,80H ; 0.5
3974:				
3975:     -	19C5  A08601  	POWERS: .BYTE   0A0H,086H,001H  ; 100000
3976:     -	19C8  102700  	        .BYTE   010H,027H,000H  ;  10000
3977:     -	19CB  E80300  	        .BYTE   0E8H,003H,000H  ;   1000
3978:     -	19CE  640000  	        .BYTE   064H,000H,000H  ;    100
3979:     -	19D1  0A0000  	        .BYTE   00AH,000H,000H  ;     10
3980:     -	19D4  010000  	        .BYTE   001H,000H,000H  ;      1
3981:				
3982:30013+10	19D7  216817  	NEGAFT: LD  HL,INVSGN           ; Negate result
3983:30023+19	19DA  E3      	        EX      (SP),HL         ; To be done after caller
3984:30042+4	19DB  E9      	        JP      (HL)            ; Return to caller
3985:				
3986:30046+17	19DC  CD7017  	SQR:    CALL    STAKFP          ; Put value on stack
3987:30063+10	19DF  21C119  	        LD      HL,HALF         ; Set power to 1/2
3988:30073+10	19E2  11BE1E  	        LD      DE,FPREG        ; Move 1/2 to FPREG
3989:30083+16	19E5  EDA0    	        LDI                     ; 4 bytes to move (HL++)->(DE++)
3990:30099+16	19E7  EDA0    	        LDI
3991:30115+16	19E9  EDA0    	        LDI
3992:30131+16	19EB  EDA0    	        LDI
3993:				
3994:30147+10	19ED  C1      	POWER:  POP     BC              ; Get base from stack
3995:30157+10	19EE  D1      	        POP     DE
3996:30167+17	19EF  CD3F17  	        CALL    TSTSGN          ; Test sign of power
3997:30184+4	19F2  78      	        LD      A,B             ; Get exponent of base
3998:30188+10	19F3  CA371A  	        JP      Z,EXP           ; Make result 1 if zero
3999:30198+10	19F6  F2FD19  	        JP      P,POWER1        ; Positive base - Ok
4000:30208+4	19F9  B7      	        OR      A               ; Zero to negative power?
4001:30212+10	19FA  CAEE03  	        JP      Z,DZERR         ; Yes - ?/0 Error
4002:30222+4	19FD  B7      	POWER1: OR      A               ; Base zero?
4003:30226+10	19FE  CA4B15  	        JP      Z,SAVEXP        ; Yes - Return zero
4004:30236+11	1A01  D5      	        PUSH    DE              ; Save base
4005:30247+11	1A02  C5      	        PUSH    BC
4006:30258+4	1A03  79      	        LD      A,C             ; Get MSB of base
4007:30262+7	1A04  F67F    	        OR      01111111B       ; Get sign status
4008:30269+20	1A06  ED5BBE1E	        LD      DE,(FPREG)      ; Move power to BCDE
4009:30289+20	1A0A  ED4BC01E	        LD      BC,(FPREG+2)
4010:30309+10	1A0E  F21F1A  	        JP      P,POWER2        ; Positive base - Ok
4011:30319+11	1A11  D5      	        PUSH    DE              ; Save power
4012:30330+11	1A12  C5      	        PUSH    BC
4013:30341+17	1A13  CD0418  	        CALL    INT             ; Get integer of power
4014:30358+10	1A16  C1      	        POP     BC              ; Restore power
4015:30368+10	1A17  D1      	        POP     DE
4016:30378+11	1A18  F5      	        PUSH    AF              ; MSB of base
4017:30389+17	1A19  CDA717  	        CALL    CMPNUM          ; Power an integer?
4018:30406+10	1A1C  E1      	        POP     HL              ; Restore MSB of base
4019:30416+4	1A1D  7C      	        LD      A,H             ; but don't affect flags
4020:30420+4	1A1E  1F      	        RRA                     ; Exponent odd or even?
4021:30424+10	1A1F  E1      	POWER2: POP     HL              ; Restore MSB and exponent
4022:30434+16	1A20  22C01E  	        LD      (FPREG+2),HL    ; Save base in FPREG
4023:30450+10	1A23  E1      	        POP     HL              ; LSBs of base
4024:30460+16	1A24  22BE1E  	        LD      (FPREG),HL      ; Save in FPREG
4025:30476+10+7	1A27  DCD719  	        CALL    C,NEGAFT        ; Odd power - Negate result
4026:30486+10+7	1A2A  CC6817  	        CALL    Z,INVSGN        ; Negative base - Negate it
4027:30496+11	1A2D  D5      	        PUSH    DE              ; Save power
4028:30507+11	1A2E  C5      	        PUSH    BC
4029:30518+17	1A2F  CDE415  	        CALL    LOG             ; Get LOG of base
4030:30535+10	1A32  C1      	        POP     BC              ; Restore power
4031:30545+10	1A33  D1      	        POP     DE
4032:30555+17	1A34  CD2516  	        CALL    FPMULT          ; Multiply LOG by power
4033:				
4034:30572+17	1A37  CD7017  	EXP:    CALL    STAKFP          ; Put value on stack
4035:30589+10	1A3A  013881  	        LD      BC,08138H       ; BCDE = 1/Ln(2)
4036:30599+10	1A3D  113BAA  	        LD      DE,0AA3BH
4037:30609+17	1A40  CD2516  	        CALL    FPMULT          ; Multiply value by 1/LN(2)
4038:30626+13	1A43  3AC11E  	        LD      A,(FPEXP)       ; Get exponent
4039:30639+7	1A46  FE88    	        CP      80H+8           ; Is it in range?
4040:30646+10	1A48  D21617  	        JP      NC,OVTST1       ; No - Test for overflow
4041:30656+17	1A4B  CD0418  	        CALL    INT             ; Get INT of FPREG
4042:30673+7	1A4E  C680    	        ADD     A,80H           ; For excess 128
4043:30680+7	1A50  C602    	        ADD     A,2             ; Exponent > 126?
4044:30687+10	1A52  DA1617  	        JP      C,OVTST1        ; Yes - Test for overflow
4045:30697+11	1A55  F5      	        PUSH    AF              ; Save scaling factor
4046:30708+10	1A56  21D315  	        LD      HL,UNITY        ; Point to 1.
4047:30718+17	1A59  CDCD14  	        CALL    ADDPHL          ; Add 1 to FPREG
4048:30735+17	1A5C  CD1C16  	        CALL    MULLN2          ; Multiply by LN(2)
4049:30752+10	1A5F  F1      	        POP     AF              ; Restore scaling factor
4050:30762+10	1A60  C1      	        POP     BC              ; Restore exponent
4051:30772+10	1A61  D1      	        POP     DE
4052:30782+11	1A62  F5      	        PUSH    AF              ; Save scaling factor
4053:30793+17	1A63  CDD914  	        CALL    SUBCDE          ; Subtract exponent from FPREG
4054:30810+17	1A66  CD6817  	        CALL    INVSGN          ; Negate result
4055:30827+10	1A69  21771A  	        LD      HL,EXPTAB       ; Coefficient table
4056:30837+17	1A6C  CDAC1A  	        CALL    SMSER1          ; Sum the series
4057:30854+10	1A6F  110000  	        LD      DE,0            ; Zero LSBs
4058:30864+10	1A72  C1      	        POP     BC              ; Scaling factor
4059:30874+4	1A73  4A      	        LD      C,D             ; Zero MSB
4060:30878+10	1A74  C32516  	        JP      FPMULT          ; Scale result to correct value
4061:				
4062:     -	1A77  08      	EXPTAB: .BYTE   8                       ; Table used by EXP
4063:     -	1A78  402E9474	        .BYTE   040H,02EH,094H,074H     ; -1/7! (-1/5040)
4064:     -	1A7C  704F2E77	        .BYTE   070H,04FH,02EH,077H     ;  1/6! ( 1/720)
4065:     -	1A80  6E02887A	        .BYTE   06EH,002H,088H,07AH     ; -1/5! (-1/120)
4066:     -	1A84  E6A02A7C	        .BYTE   0E6H,0A0H,02AH,07CH     ;  1/4! ( 1/24)
4067:     -	1A88  50AAAA7E	        .BYTE   050H,0AAH,0AAH,07EH     ; -1/3! (-1/6)
4068:     -	1A8C  FFFF7F7F	        .BYTE   0FFH,0FFH,07FH,07FH     ;  1/2! ( 1/2)
4069:     -	1A90  00008081	        .BYTE   000H,000H,080H,081H     ; -1/1! (-1/1)
4070:     -	1A94  00000081	        .BYTE   000H,000H,000H,081H     ;  1/0! ( 1/1)
4071:				
4072:30888+17	1A98  CD7017  	SUMSER: CALL    STAKFP          ; Put FPREG on stack
4073:30905+10	1A9B  112316  	        LD      DE,MULT         ; Multiply by "X"
4074:30915+11	1A9E  D5      	        PUSH    DE              ; To be done after
4075:30926+11	1A9F  E5      	        PUSH    HL              ; Save address of table
4076:30937+20	1AA0  ED5BBE1E	        LD      DE,(FPREG)      ; Move FPREG to BCDE
4077:30957+20	1AA4  ED4BC01E	        LD      BC,(FPREG+2)
4078:30977+17	1AA8  CD2516  	        CALL    FPMULT          ; Square the value
4079:30994+10	1AAB  E1      	        POP     HL              ; Restore address of table
4080:31004+17	1AAC  CD7017  	SMSER1: CALL    STAKFP          ; Put value on stack
4081:31021+7	1AAF  7E      	        LD      A,(HL)          ; Get number of coefficients
4082:31028+6	1AB0  23      	        INC     HL              ; Point to start of table
4083:31034+10	1AB1  11BE1E  	        LD      DE,FPREG        ; Move coefficient to FPREG
4084:31044+16	1AB4  EDA0    	        LDI                     ; 4 bytes to move (HL++)->(DE++)
4085:31060+16	1AB6  EDA0    	        LDI
4086:31076+16	1AB8  EDA0    	        LDI
4087:31092+16	1ABA  EDA0    	        LDI
4088:     -	1ABC  06      	        .BYTE   06H             ; Skip "POP AF"
4089:31108+10	1ABD  F1      	SUMLP:  POP     AF              ; Restore count
4090:31118+10	1ABE  C1      	        POP     BC              ; Restore number
4091:31128+10	1ABF  D1      	        POP     DE
4092:31138+4	1AC0  3D      	        DEC     A               ; Cont coefficients
4093:31142+5+6	1AC1  C8      	        RET     Z               ; All done
4094:31147+11	1AC2  D5      	        PUSH    DE              ; Save number
4095:31158+11	1AC3  C5      	        PUSH    BC
4096:31169+11	1AC4  F5      	        PUSH    AF              ; Save count
4097:31180+11	1AC5  E5      	        PUSH    HL              ; Save address in table
4098:31191+17	1AC6  CD2516  	        CALL    FPMULT          ; Multiply FPREG by BCDE
4099:31208+10	1AC9  E1      	        POP     HL              ; Restore address in table
4100:31218+17	1ACA  CD8917  	        CALL    LOADFP          ; Number at HL to BCDE
4101:31235+11	1ACD  E5      	        PUSH    HL              ; Save address in table
4102:31246+17	1ACE  CDDC14  	        CALL    FPADD           ; Add coefficient to FPREG
4103:31263+10	1AD1  E1      	        POP     HL              ; Restore address in table
4104:31273+10	1AD2  C3BD1A  	        JP      SUMLP           ; More coefficients
4105:				
4106:31283+17	1AD5  CD3F17  	RND:    CALL    TSTSGN          ; Test sign of FPREG
4107:31300+10	1AD8  21FC1D  	        LD      HL,SEED+2       ; Random number seed
4108:31310+10	1ADB  FA4F1B  	        JP      M,RESEED        ; Negative - Re-seed
4109:31320+10	1ADE  211D1E  	        LD      HL,LSTRND       ; Last random number
4110:31330+10	1AE1  11BE1E  	        LD      DE,FPREG        ; Move last RND to FPREG
4111:31340+16	1AE4  EDA0    	        LDI                     ; 4 bytes to move (HL++)->(DE++)
4112:31356+16	1AE6  EDA0    	        LDI
4113:31372+16	1AE8  EDA0    	        LDI
4114:31388+16	1AEA  EDA0    	        LDI
4115:31404+10	1AEC  21FC1D  	        LD      HL,SEED+2       ; Random number seed
4116:31414+5+6	1AEF  C8      	        RET     Z               ; Return if RND(0)
4117:31419+7	1AF0  86      	        ADD     A,(HL)          ; Add (SEED)+2)
4118:31426+7	1AF1  E607    	        AND     00000111B       ; 0 to 7
4119:31433+7	1AF3  0600    	        LD      B,0
4120:31440+7	1AF5  77      	        LD      (HL),A          ; Re-save seed
4121:31447+6	1AF6  23      	        INC     HL              ; Move to coefficient table
4122:31453+4	1AF7  87      	        ADD     A,A             ; 4 bytes
4123:31457+4	1AF8  87      	        ADD     A,A             ; per entry
4124:31461+4	1AF9  4F      	        LD      C,A             ; BC = Offset into table
4125:31465+11	1AFA  09      	        ADD     HL,BC           ; Point to coefficient
4126:31476+17	1AFB  CD8917  	        CALL    LOADFP          ; Coefficient to BCDE
4127:31493+17	1AFE  CD2516  	        CALL    FPMULT          ; Multiply FPREG by coefficient
4128:31510+13	1B01  3AFB1D  	        LD      A,(SEED+1)      ; Get (SEED+1)
4129:31523+4	1B04  3C      	        INC     A               ; Add 1
4130:31527+7	1B05  E603    	        AND     00000011B       ; 0 to 3
4131:31534+7	1B07  0600    	        LD      B,0
4132:31541+7	1B09  FE01    	        CP      1               ; Is it zero?
4133:31548+4	1B0B  88      	        ADC     A,B             ; Yes - Make it 1
4134:31552+13	1B0C  32FB1D  	        LD      (SEED+1),A      ; Re-save seed
4135:31565+10	1B0F  21531B  	        LD      HL,RNDTAB-4     ; Addition table
4136:31575+4	1B12  87      	        ADD     A,A             ; 4 bytes
4137:31579+4	1B13  87      	        ADD     A,A             ; per entry
4138:31583+4	1B14  4F      	        LD      C,A             ; BC = Offset into table
4139:31587+11	1B15  09      	        ADD     HL,BC           ; Point to value
4140:31598+17	1B16  CDCD14  	        CALL    ADDPHL          ; Add value to FPREG
4141:31615+20	1B19  ED5BBE1E	RND1:   LD      DE,(FPREG)      ; Move FPREG to BCDE
4142:31635+20	1B1D  ED4BC01E	        LD      BC,(FPREG+2)
4143:31655+4	1B21  7B      	        LD      A,E             ; Get LSB
4144:31659+4	1B22  59      	        LD      E,C             ; LSB = MSB
4145:31663+7	1B23  EE4F    	        XOR     01001111B       ; Fiddle around
4146:31670+4	1B25  4F      	        LD      C,A             ; New MSB
4147:31674+10	1B26  21C21E  	        LD      HL,SGNRES
4148:31684+10	1B29  3680    	        LD      (HL),80H        ; Set saved signed bit to positive
4149:31694+6	1B2B  2B      	        DEC     HL              ; Point to Exponent
4150:31700+7	1B2C  46      	        LD      B,(HL)          ; Get Exponent to BCDE
4151:31707+10	1B2D  3680    	        LD      (HL),80H        ; Makes Exponent 1
4152:31717+10	1B2F  21FA1D  	        LD      HL,SEED         ; Random number seed
4153:31727+11	1B32  34      	        INC     (HL)            ; Count seed
4154:31738+7	1B33  7E      	        LD      A,(HL)          ; Get seed
4155:31745+7	1B34  D6AB    	        SUB     171             ; Do it modulo 171
4156:31752+10	1B36  C23D1B  	        JP      NZ,RND2         ; Non-zero - Ok
4157:31762+7	1B39  77      	        LD      (HL),A          ; Zero seed
4158:31769+4	1B3A  0C      	        INC     C               ; Fillde about
4159:31773+4	1B3B  15      	        DEC     D               ; with the
4160:31777+4	1B3C  1C      	        INC     E               ; number
4161:31781+17	1B3D  CD3515  	RND2:   CALL    BNORM           ; Normalise number
4162:31798+10	1B40  111D1E  	        LD      DE,LSTRND       ; Save random number
4163:31808+10	1B43  21BE1E  	        LD      HL,FPREG        ; Move FPREG to last and return
4164:31818+16	1B46  EDA0    	        LDI                     ; 4 bytes to move (HL++)->(DE++)
4165:31834+16	1B48  EDA0    	        LDI
4166:31850+16	1B4A  EDA0    	        LDI
4167:31866+16	1B4C  EDA0    	        LDI
4168:31882+10	1B4E  C9      	        RET
4169:				
4170:31892+7	1B4F  77      	RESEED: LD      (HL),A          ; Re-seed random numbers
4171:31899+6	1B50  2B      	        DEC     HL
4172:31905+7	1B51  77      	        LD      (HL),A
4173:31912+6	1B52  2B      	        DEC     HL
4174:31918+7	1B53  77      	        LD      (HL),A
4175:31925+10	1B54  C3191B  	        JP      RND1            ; Return RND seed
4176:				
4177:     -	1B57  68B14668	RNDTAB: .BYTE   068H,0B1H,046H,068H ; Table used by RND
4178:     -	1B5B  99E99269	        .BYTE   099H,0E9H,092H,069H
4179:     -	1B5F  10D17568	        .BYTE   010H,0D1H,075H,068H
4180:				
4181:31935+10	1B63  21B21B  	COS:    LD      HL,HALFPI       ; Point to PI/2
4182:31945+17	1B66  CDCD14  	        CALL    ADDPHL          ; Add it to FPREG
4183:31962+17	1B69  CD7017  	SIN:    CALL    STAKFP          ; Put angle on stack
4184:31979+10	1B6C  014983  	        LD      BC,8349H        ; BCDE = 2 PI
4185:31989+10	1B6F  11DB0F  	        LD      DE,0FDBH
4186:31999+20	1B72  ED53BE1E	        LD      (FPREG),DE      ; Move 2 PI to FPREG
4187:32019+20	1B76  ED43C01E	        LD      (FPREG+2),BC
4188:32039+10	1B7A  C1      	        POP     BC              ; Restore angle
4189:32049+10	1B7B  D1      	        POP     DE
4190:32059+17	1B7C  CD9016  	        CALL    DVBCDE          ; Divide angle by 2 PI
4191:32076+17	1B7F  CD7017  	        CALL    STAKFP          ; Put it on stack
4192:32093+17	1B82  CD0418  	        CALL    INT             ; Get INT of result
4193:32110+10	1B85  C1      	        POP     BC              ; Restore number
4194:32120+10	1B86  D1      	        POP     DE
4195:32130+17	1B87  CDD914  	        CALL    SUBCDE          ; Make it 0 <= value < 1
4196:32147+10	1B8A  21B61B  	        LD      HL,QUARTR       ; Point to 0.25
4197:32157+17	1B8D  CDD314  	        CALL    SUBPHL          ; Subtract value from 0.25
4198:32174+17	1B90  CD3F17  	        CALL    TSTSGN          ; Test sign of value
4199:32191+4	1B93  37      	        SCF                     ; Flag positive
4200:32195+10	1B94  F29E1B  	        JP      P,SIN1          ; Positive - Ok
4201:32205+17	1B97  CDCA14  	        CALL    ROUND           ; Add 0.5 to value
4202:32222+17	1B9A  CD3F17  	        CALL    TSTSGN          ; Test sign of value
4203:32239+4	1B9D  B7      	        OR      A               ; Flag negative
4204:32243+11	1B9E  F5      	SIN1:   PUSH    AF              ; Save sign
4205:32254+10+7	1B9F  F46817  	        CALL    P,INVSGN        ; Negate value if positive
4206:32264+10	1BA2  21B61B  	        LD      HL,QUARTR       ; Point to 0.25
4207:32274+17	1BA5  CDCD14  	        CALL    ADDPHL          ; Add 0.25 to value
4208:32291+10	1BA8  F1      	        POP     AF              ; Restore sign
4209:32301+10+7	1BA9  D46817  	        CALL    NC,INVSGN       ; Negative - Make positive
4210:32311+10	1BAC  21BA1B  	        LD      HL,SINTAB       ; Coefficient table
4211:32321+10	1BAF  C3981A  	        JP      SUMSER          ; Evaluate sum of series
4212:				
4213:     -	1BB2  DB0F4981	HALFPI: .BYTE   0DBH,00FH,049H,081H     ; 1.5708 (PI/2)
4214:				
4215:     -	1BB6  0000007F	QUARTR: .BYTE   000H,000H,000H,07FH     ; 0.25
4216:				
4217:     -	1BBA  05      	SINTAB: .BYTE   5                       ; Table used by SIN
4218:     -	1BBB  BAD71E86	        .BYTE   0BAH,0D7H,01EH,086H     ; 39.711
4219:     -	1BBF  64269987	        .BYTE   064H,026H,099H,087H     ;-76.575
4220:     -	1BC3  58342387	        .BYTE   058H,034H,023H,087H     ; 81.602
4221:     -	1BC7  E05DA586	        .BYTE   0E0H,05DH,0A5H,086H     ;-41.342
4222:     -	1BCB  DA0F4983	        .BYTE   0DAH,00FH,049H,083H     ;  6.2832
4223:				
4224:32331+17	1BCF  CD7017  	TAN:    CALL    STAKFP          ; Put angle on stack
4225:32348+17	1BD2  CD691B  	        CALL    SIN             ; Get SIN of angle
4226:32365+10	1BD5  C1      	        POP     BC              ; Restore angle
4227:32375+10	1BD6  E1      	        POP     HL
4228:32385+17	1BD7  CD7017  	        CALL    STAKFP          ; Save SIN of angle
4229:32402+4	1BDA  EB      	        EX      DE,HL           ; BCDE = Angle
4230:32406+20	1BDB  ED53BE1E	        LD      (FPREG),DE      ; Angle to FPREG
4231:32426+20	1BDF  ED43C01E	        LD      (FPREG+2),BC
4232:32446+17	1BE3  CD631B  	        CALL    COS             ; Get COS of angle
4233:32463+10	1BE6  C38E16  	        JP      DIV             ; TAN = SIN / COS
4234:				
4235:32473+17	1BE9  CD3F17  	ATN:    CALL    TSTSGN          ; Test sign of value
4236:32490+10+7	1BEC  FCD719  	        CALL    M,NEGAFT        ; Negate result after if -ve
4237:32500+10+7	1BEF  FC6817  	        CALL    M,INVSGN        ; Negate value if -ve
4238:32510+13	1BF2  3AC11E  	        LD      A,(FPEXP)       ; Get exponent
4239:32523+7	1BF5  FE81    	        CP      81H             ; Number less than 1?
4240:32530+10	1BF7  DA061C  	        JP      C,ATN1          ; Yes - Get arc tangnt
4241:32540+10	1BFA  010081  	        LD      BC,8100H        ; BCDE = 1
4242:32550+4	1BFD  51      	        LD      D,C
4243:32554+4	1BFE  59      	        LD      E,C
4244:32558+17	1BFF  CD9016  	        CALL    DVBCDE          ; Get reciprocal of number
4245:32575+10	1C02  21D314  	        LD      HL,SUBPHL       ; Sub angle from PI/2
4246:32585+11	1C05  E5      	        PUSH    HL              ; Save for angle > 1
4247:32596+10	1C06  21101C  	ATN1:   LD      HL,ATNTAB       ; Coefficient table
4248:32606+17	1C09  CD981A  	        CALL    SUMSER          ; Evaluate sum of series
4249:32623+10	1C0C  21B21B  	        LD      HL,HALFPI       ; PI/2 - angle in case > 1
4250:32633+10	1C0F  C9      	        RET                     ; Number > 1 - Sub from PI/2
4251:				
4252:     -	1C10  09      	ATNTAB: .BYTE   9                       ; Table used by ATN
4253:     -	1C11  4AD73B78	        .BYTE   04AH,0D7H,03BH,078H     ; 1/17
4254:     -	1C15  026E847B	        .BYTE   002H,06EH,084H,07BH     ;-1/15
4255:     -	1C19  FEC12F7C	        .BYTE   0FEH,0C1H,02FH,07CH     ; 1/13
4256:     -	1C1D  74319A7D	        .BYTE   074H,031H,09AH,07DH     ;-1/11
4257:     -	1C21  843D5A7D	        .BYTE   084H,03DH,05AH,07DH     ; 1/9
4258:     -	1C25  C87F917E	        .BYTE   0C8H,07FH,091H,07EH     ;-1/7
4259:     -	1C29  E4BB4C7E	        .BYTE   0E4H,0BBH,04CH,07EH     ; 1/5
4260:     -	1C2D  6CAAAA7F	        .BYTE   06CH,0AAH,0AAH,07FH     ;-1/3
4261:     -	1C31  00000081	        .BYTE   000H,000H,000H,081H     ; 1/1
4262:				
4263:32643+10	1C35  C30000  	MONITR: JP      $0000           ; Restart (Normally Monitor Start)
4264:				
4265:32653+7	1C38  3E0C    	CLS:    LD      A,CS            ; ASCII Clear screen
4266:32660+11	1C3A  CF      	        RST     08H             ; Output character
4267:32671+10	1C3B  C9      	ARET:   RET                     ; A RETurn instruction
4268:32681+14	1C3C  ED45    	ARETN:  RETN                    ; A RETurN from NMI
4269:				
4270:32695+17	1C3E  CDA114  	WIDTH:  CALL    GETINT          ; Get integer 0-255
4271:32712+4	1C41  7B      	        LD      A,E             ; Width to A
4272:32716+13	1C42  32251E  	        LD      (LWIDTH),A      ; Set width
4273:32729+10	1C45  C9      	        RET
4274:				
4275:32739+17	1C46  CDF60C  	LINES:  CALL    GETNUM          ; Get a number
4276:32756+17	1C49  CD0109  	        CALL    DEINT           ; Get integer -32768 to 32767
4277:32773+20	1C4C  ED53291E	        LD      (LINESC),DE     ; Set lines counter
4278:32793+20	1C50  ED532B1E	        LD      (LINESN),DE     ; Set lines number
4279:32813+10	1C54  C9      	        RET
4280:				
4281:32823+17	1C55  CD0109  	DEEK:   CALL    DEINT           ; Get integer -32768 to 32767
4282:32840+11	1C58  D5      	        PUSH    DE              ; Save number
4283:32851+10	1C59  E1      	        POP     HL              ; Number to HL
4284:32861+7	1C5A  46      	        LD      B,(HL)          ; Get LSB of contents
4285:32868+6	1C5B  23      	        INC     HL
4286:32874+7	1C5C  7E      	        LD      A,(HL)          ; Get MSB of contents
4287:32881+10	1C5D  C3D210  	        JP      ABPASS          ; Return integer AB
4288:				
4289:32891+17	1C60  CDF60C  	DOKE:   CALL    GETNUM          ; Get a number
4290:32908+17	1C63  CD0109  	        CALL    DEINT           ; Get integer -32768 to 32767
4291:32925+11	1C66  D5      	        PUSH    DE              ; Save address
4292:32936+17	1C67  CDBC06  	        CALL    CHKSYN          ; Make sure ',' follows
4293:     -	1C6A  2C      	        .BYTE   ','
4294:32953+17	1C6B  CDF60C  	        CALL    GETNUM          ; Get a number
4295:32970+17	1C6E  CD0109  	        CALL    DEINT           ; Get integer -32768 to 32767
4296:32987+19	1C71  E3      	        EX      (SP),HL         ; Save value,get address
4297:33006+7	1C72  73      	        LD      (HL),E          ; Save LSB of value
4298:33013+6	1C73  23      	        INC     HL
4299:33019+7	1C74  72      	        LD      (HL),D          ; Save MSB of value
4300:33026+10	1C75  E1      	        POP     HL              ; Restore code string address
4301:33036+10	1C76  C9      	        RET
4302:				
4303:				        ; Load Intel HEX into program memory.
4304:				        ; uses  : af, bc, de, hl
4305:				        ; (C) feilipu
4306:				        
4307:     -	1C77          	HLOAD:
4308:33046+5+6	1C77  C0      	        ret NZ                  ; Return if any more on line
4309:33051+17	1C78  CD961C  	        call HLD_WAIT_COLON     ; wait for first colon and address data
4310:33068+6	1C7B  1B      	        dec de                  ; go one Byte lower
4311:33074+16	1C7C  2A891E  	        ld hl,(LSTRAM)          ; get last ram address       
4312:33090+4	1C7F  AF      	        xor a                   ; clear carry flag
4313:33094+15	1C80  ED52    	        sbc hl,de
4314:33109+7+5	1C82  380B    	        jr C,HLD_HIGH_RAM       ; if last ram lower leave it, otherwise
4315:33116+20	1C84  ED53891E	        ld (LSTRAM),de          ; store new last ram location
4316:33136+10	1C88  21CEFF  	        ld hl,-50               ; reserve 50 bytes for string space
4317:33146+11	1C8B  19      	        add hl,de               ; allocate string space
4318:33157+16	1C8C  22341E  	        ld (STRSPC),hl          ; save string space location
4319:     -	1C8F          	HLD_HIGH_RAM:
4320:33173+6	1C8F  13      	        inc de
4321:33179+20	1C90  ED53E71D	        ld (USR+1),de           ; store first address as "USR(x)" location
4322:33199+12	1C94  1821    	        jr HLD_READ_DATA        ; now get the first data
4323:				        
4324:     -	1C96          	HLD_WAIT_COLON:
4325:33211+11	1C96  D7      	        rst 10h                 ; Rx byte in A
4326:33222+7	1C97  FE3A    	        cp ':'                  ; wait for ':'
4327:33229+7+5	1C99  20FB    	        jr NZ,HLD_WAIT_COLON
4328:33236+7	1C9B  0E00    	        ld c,0                  ; reset C to compute checksum
4329:33243+17	1C9D  CDD41C  	        call HLD_READ_BYTE      ; read byte count
4330:33260+4	1CA0  47      	        ld b,a                  ; store it in B
4331:33264+17	1CA1  CDD41C  	        call HLD_READ_BYTE      ; read upper byte of address
4332:33281+4	1CA4  57      	        ld d,a                  ; store in D
4333:33285+17	1CA5  CDD41C  	        call HLD_READ_BYTE      ; read lower byte of address
4334:33302+4	1CA8  5F      	        ld e,a                  ; store in E
4335:33306+17	1CA9  CDD41C  	        call HLD_READ_BYTE      ; read record type
4336:33323+4	1CAC  3D      	        dec a                   ; check if record type is 01 (end of file)
4337:33327+7+5	1CAD  281A    	        jr Z,HLD_END_LOAD
4338:33334+4	1CAF  3C      	        inc a                   ; check if record type is 00 (data)
4339:33338+10	1CB0  C2FD03  	        jp NZ,TMERR             ; if not, type mismatch error
4340:33348+10	1CB3  C9      	        ret
4341:				
4342:     -	1CB4          	HLD_READ:
4343:33358+17	1CB4  CD961C  	        call HLD_WAIT_COLON     ; wait for the next colon and address data
4344:     -	1CB7          	HLD_READ_DATA:
4345:33375+17	1CB7  CDD41C  	        call HLD_READ_BYTE
4346:33392+7	1CBA  12      	        ld (de),a               ; write the byte at the RAM address
4347:33399+6	1CBB  13      	        inc de
4348:33405+8+5	1CBC  10F9    	        djnz HLD_READ_DATA      ; if b non zero, loop to get more data
4349:				
4350:     -	1CBE          	HLD_READ_CHKSUM:
4351:33413+17	1CBE  CDD41C  	        call HLD_READ_BYTE      ; read checksum, but we don't need to keep it
4352:33430+4	1CC1  79      	        ld a,c                  ; lower byte of C checksum should be 0
4353:33434+4	1CC2  B7      	        or a
4354:33438+10	1CC3  C27C1D  	        jp NZ,HXERR             ; non zero, we have an issue
4355:33448+10	1CC6  C3B41C  	        jp HLD_READ
4356:				
4357:     -	1CC9          	HLD_END_LOAD:
4358:33458+17	1CC9  CDD41C  	        call HLD_READ_BYTE      ; read checksum, but we don't need to keep it
4359:33475+4	1CCC  79      	        ld a,c                  ; lower byte of C checksum should be 0
4360:33479+4	1CCD  B7      	        or a
4361:33483+10	1CCE  C27C1D  	        jp NZ,HXERR             ; non zero, we have an issue
4362:33493+10	1CD1  C3E000  	        jp BRKRET               ; return to command line
4363:				
4364:     -	1CD4          	HLD_READ_BYTE:                  ; returns byte in A, checksum in C
4365:33503+17	1CD4  CDE51C  	        call HLD_READ_NIBBLE    ; read the first nibble
4366:33520+4	1CD7  07      	        rlca                    ; shift it left by 4 bits
4367:33524+4	1CD8  07      	        rlca
4368:33528+4	1CD9  07      	        rlca
4369:33532+4	1CDA  07      	        rlca
4370:33536+4	1CDB  6F      	        ld l,a                  ; temporarily store the first nibble in L
4371:33540+17	1CDC  CDE51C  	        call HLD_READ_NIBBLE    ; get the second (low) nibble
4372:33557+4	1CDF  B5      	        or l                    ; assemble two nibbles into one byte in A
4373:33561+4	1CE0  6F      	        ld l,a                  ; put assembled byte back into L
4374:33565+4	1CE1  81      	        add a,c                 ; add the byte read to C (for checksum)
4375:33569+4	1CE2  4F      	        ld c,a
4376:33573+4	1CE3  7D      	        ld a,l
4377:33577+10	1CE4  C9      	        ret                     ; return the byte read in A (L = char received too)  
4378:				
4379:     -	1CE5          	HLD_READ_NIBBLE:
4380:33587+11	1CE5  D7      	        rst 10h                 ; Rx byte in A
4381:33598+7	1CE6  D630    	        sub '0'
4382:33605+7	1CE8  FE0A    	        cp 10
4383:33612+5+6	1CEA  D8      	        ret C                   ; if A<10 just return
4384:33617+7	1CEB  D607    	        sub 7                   ; else subtract 'A'-'0' (17) and add 10
4385:33624+10	1CED  C9      	        ret
4386:				
4387:				        ; HEX$(nn) Convert 16 bit number to Hexadecimal string
4388:				        ; (C) Searle
4389:				
4390:33634+17	1CEE  CDF90C  	HEX:    CALL    TSTNUM          ; Verify it's a number
4391:33651+17	1CF1  CD0109  	        CALL    DEINT           ; Get integer -32768 to 32767
4392:33668+11	1CF4  C5      	        PUSH    BC              ; Save contents of BC
4393:33679+10	1CF5  21C31E  	        LD      HL,PBUFF
4394:33689+4	1CF8  7A      	        LD      A,D             ; Get high order into A
4395:33693+7	1CF9  FE00    	        CP      $0
4396:33700+7+5	1CFB  280C    	        JR      Z,HEX2          ; Skip output if both high digits are zero
4397:33707+17	1CFD  CD261D  	        CALL    BYT2ASC         ; Convert D to ASCII
4398:33724+4	1D00  78      	        LD      A,B
4399:33728+7	1D01  FE30    	        CP      '0'
4400:33735+7+5	1D03  2802    	        JR      Z,HEX1          ; Don't store high digit if zero
4401:33742+7	1D05  70      	        LD      (HL),B          ; Store it to PBUFF
4402:33749+6	1D06  23      	        INC     HL              ; Next location
4403:33755+7	1D07  71      	HEX1:   LD      (HL),C          ; Store C to PBUFF+1
4404:33762+6	1D08  23      	        INC     HL              ; Next location
4405:33768+4	1D09  7B      	HEX2:   LD      A,E             ; Get lower byte
4406:33772+17	1D0A  CD261D  	        CALL    BYT2ASC         ; Convert E to ASCII
4407:33789+4	1D0D  7A      	        LD      A,D
4408:33793+7	1D0E  FE00    	        CP      $0
4409:33800+7+5	1D10  2005    	        JR      NZ,HEX3         ; If upper byte was not zero then always print lower byte
4410:33807+4	1D12  78      	        LD      A,B
4411:33811+7	1D13  FE30    	        CP      '0'             ; If high digit of lower byte is zero then don't print
4412:33818+7+5	1D15  2802    	        JR      Z,HEX4
4413:33825+7	1D17  70      	HEX3:   LD      (HL),B          ; to PBUFF+2
4414:33832+6	1D18  23      	        INC     HL              ; Next location
4415:33838+7	1D19  71      	HEX4:   LD      (HL),C          ; to PBUFF+3
4416:33845+6	1D1A  23      	        INC     HL              ; PBUFF+4 to zero
4417:33851+4	1D1B  AF      	        XOR     A               ; Terminating character
4418:33855+7	1D1C  77      	        LD      (HL),A          ; Store zero to terminate
4419:33862+6	1D1D  23      	        INC     HL              ; Make sure PBUFF is terminated
4420:33868+7	1D1E  77      	        LD      (HL),A          ; Store the double zero there
4421:33875+10	1D1F  C1      	        POP     BC              ; Get BC back
4422:33885+10	1D20  21C31E  	        LD      HL,PBUFF        ; Reset to start of PBUFF
4423:33895+10	1D23  C38811  	        JP      STR1            ; Convert the PBUFF to a string and return it
4424:				
4425:33905+4	1D26  47      	BYT2ASC:LD      B,A             ; Save original value
4426:33909+7	1D27  E60F    	        AND     $0F             ; Strip off upper nybble
4427:33916+7	1D29  FE0A    	        CP      $0A             ; 0-9?
4428:33923+7+5	1D2B  3802    	        JR      C,ADD30         ; If A-F, add 7 more
4429:33930+7	1D2D  C607    	        ADD     A,$07           ; Bring value up to ASCII A-F
4430:33937+7	1D2F  C630    	ADD30:  ADD     A,$30           ; And make ASCII
4431:33944+4	1D31  4F      	        LD      C,A             ; Save converted char to C
4432:33948+4	1D32  78      	        LD      A,B             ; Retrieve original value
4433:33952+4	1D33  0F      	        RRCA                    ; and Rotate it right
4434:33956+4	1D34  0F      	        RRCA
4435:33960+4	1D35  0F      	        RRCA
4436:33964+4	1D36  0F      	        RRCA
4437:33968+7	1D37  E60F    	        AND     $0F             ; Mask off upper nybble
4438:33975+7	1D39  FE0A    	        CP      $0A             ; 0-9? < A hex?
4439:33982+7+5	1D3B  3802    	        JR      C,ADD301        ; Skip Add 7
4440:33989+7	1D3D  C607    	        ADD     A,$07           ; Bring it up to ASCII A-F
4441:33996+7	1D3F  C630    	ADD301: ADD     A,$30           ; And make it full ASCII
4442:34003+4	1D41  47      	        LD      B,A             ; Store high order byte
4443:34007+10	1D42  C9      	        RET
4444:				
4445:				        ; Convert "&Hnnnn" to FPREG
4446:				        ; Gets a character from (HL) checks for Hexadecimal ASCII numbers "&Hnnnn"
4447:				        ; Char is in A, NC if char is ;<=>?@ A-z, CY is set if 0-9
4448:				        ; (C) Searle
4449:				
4450:34017+4	1D43  EB      	HEXTFP: EX      DE,HL           ; Move code string pointer to DE
4451:34021+10	1D44  210000  	        LD      HL,$0000        ; Zero out the value
4452:34031+17	1D47  CD5C1D  	        CALL    GETHEX          ; Check the number for valid hex
4453:34048+10	1D4A  DA7C1D  	        JP      C,HXERR         ; First value wasn't hex, HX error
4454:34058+12	1D4D  1805    	        JR      HEXLP1          ; Convert first character
4455:34070+17	1D4F  CD5C1D  	HEXLP:  CALL    GETHEX          ; Get second and addtional characters
4456:34087+7+5	1D52  381F    	        JR      C,HEXIT         ; Exit if not a hex character
4457:34094+11	1D54  29      	HEXLP1: ADD     HL,HL           ; Rotate 4 bits to the left
4458:34105+11	1D55  29      	        ADD     HL,HL
4459:34116+11	1D56  29      	        ADD     HL,HL
4460:34127+11	1D57  29      	        ADD     HL,HL
4461:34138+4	1D58  B5      	        OR      L               ; Add in D0-D3 into L
4462:34142+4	1D59  6F      	        LD      L,A             ; Save new value
4463:34146+12	1D5A  18F3    	        JR      HEXLP           ; And continue until all hex characters are in
4464:				
4465:34158+6	1D5C  13      	GETHEX: INC     DE              ; Next location
4466:34164+7	1D5D  1A      	        LD      A,(DE)          ; Load character at pointer
4467:34171+7	1D5E  FE20    	        CP      ' '
4468:34178+10	1D60  CA5C1D  	        JP      Z,GETHEX        ; Skip spaces
4469:34188+7	1D63  D630    	        SUB     $30             ; Get absolute value
4470:34195+5+6	1D65  D8      	        RET     C               ; < "0", error
4471:34200+7	1D66  FE0A    	        CP      $0A
4472:34207+7+5	1D68  3805    	        JR      C,NOSUB7        ; Is already in the range 0-9
4473:34214+7	1D6A  D607    	        SUB     $07             ; Reduce to A-F
4474:34221+7	1D6C  FE0A    	        CP      $0A             ; Value should be $0A-$0F at this point
4475:34228+5+6	1D6E  D8      	        RET     C               ; CY set if was :            ; < = > ? @
4476:34233+7	1D6F  FE10    	NOSUB7: CP      $10             ; > Greater than "F"?
4477:34240+4	1D71  3F      	        CCF
4478:34244+10	1D72  C9      	        RET                     ; CY set if it wasn't valid hex
4479:				    
4480:34254+4	1D73  EB      	HEXIT:  EX      DE,HL           ; Value into DE, Code string into HL
4481:34258+4	1D74  7A      	        LD      A,D             ; Load DE into AC
4482:34262+4	1D75  4B      	        LD      C,E             ; For prep to 
4483:34266+11	1D76  E5      	        PUSH    HL
4484:34277+17	1D77  CDD110  	        CALL    ACPASS          ; ACPASS to set AC as integer into FPREG
4485:34294+10	1D7A  E1      	        POP     HL
4486:34304+10	1D7B  C9      	        RET
4487:				
4488:34314+7	1D7C  1E26    	HXERR:  LD      E,HX            ; ?HEX Error
4489:34321+10	1D7E  C3FF03  	        JP      ERROR
4490:				
4491:				        ; BIN$(NN) Convert integer to a 1-16 char binary string
4492:				        ; (C) Searle
4493:				
4494:34331+17	1D81  CDF90C  	BIN:    CALL    TSTNUM          ; Verify it's a number
4495:34348+17	1D84  CD0109  	        CALL    DEINT           ; Get integer -32768 to 32767
4496:34365+11	1D87  C5      	BIN2:   PUSH    BC              ; Save contents of BC
4497:34376+10	1D88  21C31E  	        LD      HL,PBUFF
4498:34386+7	1D8B  0611    	        LD      B,17            ; One higher than max char count
4499:     -	1D8D          	ZEROSUP:                        ; Suppress leading zeros
4500:34393+4	1D8D  05      	        DEC     B               ; Max 16 chars
4501:34397+4	1D8E  78      	        LD      A,B
4502:34401+7	1D8F  FE01    	        CP      $01
4503:34408+7+5	1D91  2808    	        JR      Z,BITOUT        ; Always output at least one character
4504:34415+8	1D93  CB13    	        RL      E
4505:34423+8	1D95  CB12    	        RL      D
4506:34431+7+5	1D97  30F4    	        JR      NC,ZEROSUP
4507:34438+12	1D99  1804    	        JR      BITOUT2
4508:     -	1D9B          	BITOUT:      
4509:34450+8	1D9B  CB13    	        RL      E
4510:34458+8	1D9D  CB12    	        RL      D               ; Top bit now in carry
4511:     -	1D9F          	BITOUT2:
4512:34466+7	1D9F  3E30    	        LD      A,'0'           ; Char for '0'
4513:34473+7	1DA1  CE00    	        ADC     A,0             ; If carry set then '0' --> '1'
4514:34480+7	1DA3  77      	        LD      (HL),A
4515:34487+6	1DA4  23      	        INC     HL
4516:34493+4	1DA5  05      	        DEC     B
4517:34497+7+5	1DA6  20F3    	        JR      NZ,BITOUT
4518:34504+4	1DA8  AF      	        XOR     A               ; Terminating character
4519:34508+7	1DA9  77      	        LD      (HL),A          ; Store zero to terminate
4520:34515+6	1DAA  23      	        INC     HL              ; Make sure PBUFF is terminated
4521:34521+7	1DAB  77      	        LD      (HL),A          ; Store the double zero there
4522:34528+10	1DAC  C1      	        POP     BC
4523:34538+10	1DAD  21C31E  	        LD      HL,PBUFF
4524:34548+10	1DB0  C38811  	        JP      STR1
4525:				
4526:				        ; Convert "&Bnnnn" to FPREG
4527:				        ; Gets a character from (HL) checks for Binary ASCII numbers "&Bnnnn"
4528:				        ; (C) Searle
4529:				
4530:34558+4	1DB3  EB      	BINTFP: EX      DE,HL           ; Move code string pointer to DE
4531:34562+10	1DB4  210000  	        LD      HL,$0000        ; Zero out the value
4532:34572+17	1DB7  CDD01D  	        CALL    CHKBIN          ; Check the number for valid bin
4533:34589+10	1DBA  DADE1D  	        JP      C,BINERR        ; First value wasn't bin, HX error
4534:34599+7	1DBD  D630    	BINIT:  SUB     '0'
4535:34606+11	1DBF  29      	        ADD     HL,HL           ; Rotate HL left
4536:34617+4	1DC0  B5      	        OR      L
4537:34621+4	1DC1  6F      	        LD      L,A
4538:34625+17	1DC2  CDD01D  	        CALL    CHKBIN          ; Get second and addtional characters
4539:34642+7+5	1DC5  30F6    	        JR      NC,BINIT        ; Process if a bin character
4540:34649+4	1DC7  EB      	        EX      DE,HL           ; Value into DE, Code string into HL
4541:34653+4	1DC8  7A      	        LD      A,D             ; Load DE into AC
4542:34657+4	1DC9  4B      	        LD      C,E             ; For prep to 
4543:34661+11	1DCA  E5      	        PUSH    HL
4544:34672+17	1DCB  CDD110  	        CALL    ACPASS          ; ACPASS to set AC as integer into FPREG
4545:34689+10	1DCE  E1      	        POP     HL
4546:34699+10	1DCF  C9      	        RET
4547:				
4548:				        ; Char is in A, NC if char is 0 or 1
4549:				
4550:34709+6	1DD0  13      	CHKBIN: INC     DE
4551:34715+7	1DD1  1A      	        LD      A,(DE)
4552:34722+7	1DD2  FE20    	        CP      ' '
4553:34729+10	1DD4  CAD01D  	        JP      Z,CHKBIN        ; Skip spaces
4554:34739+7	1DD7  FE30    	        CP      '0'             ; Set C if < '0'
4555:34746+5+6	1DD9  D8      	        RET     C
4556:34751+7	1DDA  FE32    	        CP      '2'
4557:34758+4	1DDC  3F      	        CCF                     ; Set C if > '1'
4558:34762+10	1DDD  C9      	        RET
4559:				
4560:34772+7	1DDE  1E28    	BINERR: LD      E,BN            ; ?BIN Error
4561:34779+10	1DE0  C3FF03  	        JP      ERROR
4562:				
4563:     -	1DE3          	.end
**** test.asm ****
  88:     -	1DE3          	_WORKSPACE:
  89:				
  90:     -	9E5E          	    dephase
  91:     -	9E5E          	prg_end:
  92:				
**** test.asm ****
  93:     -	9E5E          	_eof:



Statistics:

     4	passes
     0	jr promotions
  1222	symbols
  7774	bytes



Symbol Table:

?a0000         =14A5      5285
?a0001         =1562      5474
ABPASS          10D2      4306
ABS             1764      5988
ACCSUM           8E0      2272
ACPASS          10D1      4305
ADD30           1D2F      7471
ADD301          1D3F      7487
ADDEXP          16F8      5880
ADDIG           1894      6292
ADDPHL          14CD      5325
ADDR_RTC       =D0        208
ALLFOL          13C9      5065
ANTVLU           C02      3074
ARET            1C3B      7227
ARETN           1C3C      7228
ARLDSV           FE8      4072
ARREND         =1EB4      7860
ARRLP           1284      4740
ASC             139A      5018
ASCTFP          1837      6199
ASPCS            B64      2916
ATN             1BE9      7145
ATN1            1C06      7174
ATNTAB          1C10      7184
ATOH             91B      2331
A_RTS_OFF      = 1BE      446
A_RTS_ON       = 1C7      455
BADINP           B89      2953
BAKSTK           38E      910
BAKTMP          1377      4983
BASRST_00       00        0
BASRST_08       08        8
BASRST_10       10        16
BASRST_18       18        24
BASSTART        4E        78
BASTXT         =1E38      7736
BFREE           E6        230
BIN             1D81      7553
BIN2            1D87      7559
BINERR          1DDE      7646
BINIT           1DBD      7613
BINTFP          1DB3      7603
BITOUT          1D9B      7579
BITOUT2         1D9F      7583
BKSP           =08        8
BN             =28        40
BNORM           1535      5429
BNRMLP          1538      5432
BOOT_PHASE0    =83        131
BOOT_PHASE1    =A5        165
BOOT_PHASE1_LOOP=AE        174
BOOT_PHASE2    =B9        185
BRK              892      2194
BRKFLG         =1E30      7728
BRKLIN         =1EA8      7848
BRKMSG           388      904
BRKRET          E0        224
BS             =10        16
BSERR           101E      4126
BUFFER         =1E3B      7739
BYT2ASC         1D26      7462
BYTSFT          1673      5747
B_BEEP         =50        80
B_DSKSEL       =71        113
B_FATCD        =7A        122
B_FATCREATE    =7D        125
B_FATOPEN      =74        116
B_FATREAD      =77        119
B_FATWRITE     =80        128
B_IICRECV      =56        86
B_IICSEND      =53        83
B_KEYREAD      =6B        107
B_KEYSEND      =6E        110
B_PRINTAHEX    =62        98
B_PRINTCHAR    =59        89
B_PRINTINLINE  =5F        95
B_PRINTLN      =65        101
B_PRINTSTR     =5C        92
B_READCHAR     =68        104
CFEVAL           F78      3960
CHARTY           F1E      3870
CHEKFN          1171      4465
CHKBIN          1DD0      7632
CHKLTR           8ED      2285
CHKSTK           3C8      968
CHKSUM         =1E2D      7725
CHKSYN           6BC      1724
CHKTYP           CFB      3323
CHR             13AB      5035
CLEAR            944      2372
CLOTST           6F5      1781
CLREG            526      1318
CLRPTR           501      1281
CLS             1C38      7224
CMPFP           17C1      6081
CMPLG1           E84      3716
CMPLOG           E82      3714
CMPNUM          17A7      6055
CMPRES           EC6      3782
CMPSTR           EAE      3758
CN             =20        32
CNVNUM          1843      6211
COLD            4E        78
COMMAN         =1E26      7718
COMMAND        =1944      6468
COMMAND_BACKSPACE=1985      6533
COMMAND_LUT    =18B2      6322
COMMAND_PROCESS=19AB      6571
COMMAND_PROCESS_FOUND=19E6      6630
COMMAND_PROCESS_LOOP=19AE      6574
COMMAND_PROCESS_LOOP_STR1=19B7      6583
COMMAND_PROCESS_LOOP_STR2=19CD      6605
COMMAND_PROCESS_NEXT_ENTRY=19D2      6610
COMMAND_PROCESS_NEXT_ENTRYI=19D1      6609
COMMAND_PROCESS_NOT_FOUND=19DD      6621
COMMAND_READ   =1956      6486
COMPL           159B      5531
CONCAT          1309      4873
CONEXP          1873      6259
CONPOS          1532      5426
CONSOLE_INIT   =DC        220
CONSOLE_INIT_CTC=DC        220
CONSOLE_INIT_SIO=E4        228
CONT             8C5      2245
CONTAD         =1EAE      7854
CONVAR           DEA      3562
COS             1B63      7011
COUNT            763      1891
CPYLIT           5F8      1528
CR             =0D        13
CRARLP          103E      4158
CREARY          1023      4131
CRESTR           A52      2642
CRNCLP           559      1369
CRTMST          11AA      4522
CRTST           11B6      4534
CRTSTE          11CC      4556
CRUNCH           550      1360
CS             =0C        12
CSTART          5A        90
CS_APU_CTRL    =F9        249
CS_APU_DATA    =F8        248
CS_BANK        =00        0
CS_CTC_0       =04        4
CS_CTC_1       =05        5
CS_CTC_2       =06        6
CS_CTC_3       =07        7
CS_DIP         =01        1
CS_PIA_CR      =33        51
CS_PIA_PA      =30        48
CS_PIA_PB      =31        49
CS_PIA_PC      =32        50
CS_PIO_AC      =F6        246
CS_PIO_AD      =F4        244
CS_PIO_BC      =F7        247
CS_PIO_BD      =F5        245
CS_SIO_A_C     =09        9
CS_SIO_A_D     =08        8
CS_SIO_B_C     =0B        11
CS_SIO_B_D     =0A        10
CTLOFG         =1E28      7720
CTRLC          =03        3
CTRLG          =07        7
CTRLO          =0F        15
CTRLQ          =11        17
CTRLR          =12        18
CTRLS          =13        19
CTRLU          =15        21
CUROPR         =1E9F      7839
CURPOS         =1E85      7813
DATA             9F0      2544
DATFLG         =1E88      7816
DATLIN         =1EA3      7843
DATSNR           3E5      997
DCBCDE          17FD      6141
DD             =12        18
DDERR            3F4      1012
DEEK            1C55      7253
DEF             10E6      4326
DEFSIZ          1046      4166
DEINT            901      2305
DEL            =7F        127
DELCHR           628      1576
DEPINT           8FB      2299
DHEX_TO_BYTE   = 235      565
DHEX_TO_BYTE_FAILED= 251      593
DIGTXT          1947      6471
DIM              EF0      3824
DIMRET           EE7      3815
DINPOS           6EB      1771
DIV             168E      5774
DIV1           =1DED      7661
DIV10           1678      5752
DIV2           =1DF1      7665
DIV3           =1DF5      7669
DIV4           =1DF8      7672
DIVLP           16B5      5813
DIVSUP         =1DEC      7660
DOAGN            53F      1343
DOCOM            B35      2869
DODEL            608      1544
DOEBIT          1990      6544
DOFN            1113      4371
DOKE            1C60      7264
DONULL           B23      2851
DOSPC            B5F      2911
DOTAB            B4C      2892
DPOINT          186F      6255
DTSTR           11BA      4538
DVBCDE          1690      5776
DZ             =14        20
DZERR            3EE      1006
ECHDEL           61C      1564
EDIGIT          18BB      6331
ENDBUF           5FF      1535
ENDCON          1882      6274
ENDDIM          10AC      4268
ENDINP           B14      2836
ENDNAM           F12      3858
ENDPRG           8A1      2209
ENFMEM           3D1      977
ERRIN            41F      1055
ERRLIN         =1EAC      7852
ERRMSG           376      886
ERROR            3FF      1023
ERRORS           2F4      756
ERR_SYNTAX     =19FC      6652
ESC            =1B        27
EVAL             D08      3336
EVAL1            D0B      3339
EVAL2            D14      3348
EVAL3            D17      3351
EVLPAR           DD1      3537
EVNOT            ED0      3792
EXCUTE           82F      2095
EXEC_RST_08    = DD5      3541
EXEC_RST_10    = DD9      3545
EXEC_RST_18    = DE5      3557
EXP             1A37      6711
EXPLP           1861      6241
EXPTAB          1A77      6775
EXPTEN          19A2      6562
EXTIG            C67      3175
FANDT            C90      3216
FC             =08        8
FCERR            916      2326
FDTLP            C78      3192
FINDEL          1084      4228
FLGDIF          174A      5962
FLGREL          1751      5969
FNARG          =1EBA      7866
FNCTAB           159      345
FNDARY           FEE      4078
FNDELP          1089      4233
FNDEND           4D1      1233
FNDNUM          149E      5278
FNDTOK           742      1858
FNDVAR           F5B      3931
FNDWRD           583      1411
FNOFST           DFB      3579
FNRGNM         =1EB8      7864
FNTHR            F6D      3949
FNVAL            E22      3618
FOPRND           D40      3392
FOR              78D      1933
FORFLG         =1EA5      7845
FORFND           7C1      1985
FORSLP           7A1      1953
FPADD           14DC      5340
FPBCDE          1579      5497
FPEXP          =1EC1      7873
FPINT           17D4      6100
FPMULT          1625      5669
FPREG          =1EBE      7870
FPROND          1582      5506
FPSINT           8F5      2293
FRE             10B0      4272
FRENUM          10CC      4300
FRMEVL           DED      3565
GARBGE          1248      4680
GARBLP          124B      4683
GETCHR           84F      2127
GETCMD           446      1094
GETHEX          1D5C      7516
GETINT          14A1      5281
GETLEN          138F      5007
GETLN            91C      2332
GETNUM           CF6      3318
GETNXT           59E      1438
GETSTR          1353      4947
GETVAR           EF5      3829
GNXARY          1283      4739
GOFUNC           E2A      3626
GOSUB            999      2457
GOTO             9AA      2474
GRBARY          12A5      4773
GRBDON          121D      4637
GRBLP           1259      4697
GSTRCU          1356      4950
GSTRDE          135A      4954
GSTRHL          1359      4953
GTFLNM          139E      5022
GTFNAM           EFA      3834
GTLNLP           91F      2335
GTSIXD          190C      6412
GTVLUS           BDA      3034
HALF            19C1      6593
HALFPI          1BB2      7090
HEX             1CEE      7406
HEX1            1D07      7431
HEX2            1D09      7433
HEX3            1D17      7447
HEX4            1D19      7449
HEXIT           1D73      7539
HEXLP           1D4F      7503
HEXLP1          1D54      7508
HEXTFP          1D43      7491
HEX_TO_BIN     = 255      597
HEX_TO_BIN_2   = 263      611
HEX_TO_INVALID_2= 26A      618
HLD_END_LOAD    1CC9      7369
HLD_HIGH_RAM    1C8F      7311
HLD_READ        1CB4      7348
HLD_READ_BYTE   1CD4      7380
HLD_READ_CHKSUM 1CBE      7358
HLD_READ_DATA   1CB7      7351
HLD_READ_NIBBLE 1CE5      7397
HLD_WAIT_COLON  1C96      7318
HLOAD           1C77      7287
HX             =26        38
HXERR           1D7C      7548
ID             =16        22
IDE_CMD_IDENT  =EC        236
IDE_CMD_READSEC=20        32
IDE_DEV_TABLE  =1307      4871
IDE_RD         =40        64
IDE_REG_ALTSTS =16        22
IDE_REG_CMDSTS =0F        15
IDE_REG_DATA   =08        8
IDE_REG_DRVADDR=17        23
IDE_REG_ERROR  =09        9
IDE_REG_HCYL   =0D        13
IDE_REG_HEAD   =0E        14
IDE_REG_LBA0   =0B        11
IDE_REG_LBA1   =0C        12
IDE_REG_LBA2   =0D        13
IDE_REG_LBA3   =0E        14
IDE_REG_LCYL   =0C        12
IDE_REG_SECTOR =0A        10
IDE_REG_SSECTOR=0B        11
IDE_RST        =80        128
IDE_WR         =20        32
IDTEST          1163      4451
IF               A97      2711
IFGO             AA5      2725
IFJMP            836      2102
IIC_CLK        =01        1
IIC_DATA       =02        2
INCHL           1790      6032
INCLEN           6E7      1767
INDFND           3AB      939
INEWLN           499      1177
INIT            62        98
INITAB           31E      798
INITBE           375      885
INMSG            37D      893
INP             145E      5214
INPBIN           C2C      3116
INPBRK           89E      2206
INPORT         =1E22      7714
INPSUB         =1E21      7713
INPUT            B9A      2970
INRNG           1915      6421
INT             1804      6148
INTVAR           510      1296
INT_VEC        =1B        27
INVSGN          1768      5992
IO_AY0_ADDR    =40        64
IO_AY0_DATA    =41        65
IO_AY1_ADDR    =42        66
IO_AY1_DATA    =43        67
IO_REG0        =20        32
IO_RTC_AMPM    =25        37
IO_RTC_CTR_D   =2D        45
IO_RTC_CTR_E   =2E        46
IO_RTC_CTR_F   =2F        47
IO_RTC_DAY0    =26        38
IO_RTC_DAY1    =27        39
IO_RTC_HOUR    =24        36
IO_RTC_MIN0    =22        34
IO_RTC_MIN1    =23        35
IO_RTC_MON0    =28        40
IO_RTC_MON1    =29        41
IO_RTC_SEC0    =20        32
IO_RTC_SEC1    =21        33
IO_RTC_WEEK    =2C        44
IO_RTC_YEAR1   =2B        43
IO_RTC_YERR0   =2A        42
ITMSEP           C1D      3101
JSTZER          19AC      6572
KILFOR           CE6      3302
KILIN            633      1587
LCRFLG         =1E86      7814
LEFT            13BB      5051
LEN             138B      5003
LET              A07      2567
LETNUM           A69      2665
LETSTR           A22      2594
LF             =0A        10
LFRGNM          1454      5204
LINEAT         =1E36      7734
LINEIN          18C7      6343
LINES           1C46      7238
LINESC         =1E29      7721
LINESN         =1E2B      7723
LINFND           47F      1151
LIST             704      1796
LISTLP           710      1808
LOADFP          1789      6025
LOG             15E4      5604
LOGTAB          15D7      5591
LOKFOR           392      914
LOOPST         =1EA1      7841
LS             =1C        28
LSTBIN         =1EA6      7846
LSTLP2           730      1840
LSTLP3           733      1843
LSTRAM         =1E89      7817
LSTRND         =1E1D      7709
LTSTND           C40      3136
LWIDTH         =1E25      7717
MAKINT          14A4      5284
MAKNUM          1936      6454
MANLP           184B      6219
MATCH            5D0      1488
MEMMSG           14E      334
MEM_FAT_AMOUNT =44B8      17592
MEM_FAT_CLUSTERLEN=44BB      17595
MEM_FAT_COUNT1 =44BC      17596
MEM_FAT_CURDIR =44DF      17631
MEM_FAT_CURRDIR=453F      17727
MEM_FAT_DATASTART=44C1      17601
MEM_FAT_DIRSEC =44CD      17613
MEM_FAT_EXEC_COUNT=4545      17733
MEM_FAT_EXEC_CURR=4543      17731
MEM_FAT_EXEC_START=4547      17735
MEM_FAT_FILEREMAIN=44C9      17609
MEM_FAT_OF0_ATTRIBUTE=452F      17711
MEM_FAT_OF0_CCLUST=4531      17713
MEM_FAT_OF0_DATREM=453B      17723
MEM_FAT_OF0_DATSEC=4537      17719
MEM_FAT_OF0_FATSEC=4533      17715
MEM_FAT_RESERVED=44B6      17590
MEM_FAT_ROOTSTART=44C5      17605
MEM_FAT_SECTORS=44B9      17593
MEM_FAT_TMPFNAME=44CF      17615
MEM_FAT_TMPPOINTER=44BD      17597
MEM_IDE_BUFFER =42B6      17078
MEM_IDE_DEVICE =41CB      16843
MEM_IDE_DEV_TABLE=41D5      16853
MEM_IDE_FSBUFFER=44B6      17590
MEM_IDE_PARTITION=41CD      16845
MEM_IDE_POINTER=41D1      16849
MEM_IDE_SELECTED=4215      16917
MEM_IDE_STATUS =41CC      16844
MEM_IDE_STRING_0=4216      16918
MEM_IDE_STRING_1=423E      16958
MEM_IDE_STRING_2=4266      16998
MEM_IDE_STRING_3=428E      17038
MID             13F5      5109
MID1            13C1      5057
MIDNUM          1459      5209
MINCDE          1524      5412
MINUS            DD9      3545
MKTMST          11A7      4519
MLDBLP          1826      6182
MLDEBC          181D      6173
MLOOP           7E        126
MLSP10          1723      5923
MO             =24        36
MONITR          1C35      7221
MORDT            C4C      3148
MORINP           642      1602
MOVBUF           4B8      1208
MOVDIR           5D8      1496
MOVLP            3BA      954
MOVSTR           3B7      951
MOVUP            3B4      948
MRPRNT           AB7      2743
MSG_CLEAR      = 1B6      438
MSIZE           7B        123
MUL8LP          1650      5712
MULLN2          161C      5660
MULT            1623      5667
MULT8           1647      5703
MULTEN          188D      6285
MULVAL         =1ED0      7888
MVSTPT           A5A      2650
NEDMOR           BD6      3030
NEGAFT          19D7      6615
NEW              500      1280
NEXITM           B6F      2927
NEXT             C9B      3227
NEXT1            C9E      3230
NF             =00        0
NFERR            3F1      1009
NMIFLG         =1E2F      7727
NOCHNG           5C8      1480
NOENED          19AF      6575
NOLIN            8B4      2228
NOMADD          1661      5729
NOMLAD          1834      6196
NOPMPT           BB4      2996
NORMAL          154F      5455
NOSPC            5BF      1471
NOSUB7          1D6F      7535
NOSWAP          14FE      5374
NOTAMP           DCC      3532
NOTSTR           F2D      3885
NOT_IMPLEMENTED=19F5      6645
NOXOR           1484      5252
NSCFOR           F3D      3901
NULFLG         =1E27      7719
NULL             8D8      2264
NULLP            B2A      2858
NULLS          =1E24      7716
NUMASC          18DA      6362
NXTARY          1005      4101
NXTBYT           5AE      1454
NXTCHR           5EF      1519
NXTDAT         =1EB6      7862
NXTDTA           9EF      2543
NXTITM           BCE      3022
NXTOPR         =1EAA      7850
NXTSTL           9F6      2550
NXTSTT           9F9      2553
OD             =06        6
OKMSG            382      898
OM             =0C        12
OMERR            3E0      992
ON               A79      2681
ONGO             A88      2696
ONGOLP           A89      2697
ONJMP            837      2103
OPNPAR           D04      3332
OPRND            D82      3458
OP_CALL        =1A57      6743
OP_CD          =1E27      7719
OP_CLR         =1BEB      7147
OP_DASM        =1AD8      6872
OP_DIR         =1E23      7715
OP_DUMP        =1A77      6775
OP_EXEC        =1A3E      6718
OP_FSEXEC      =1E44      7748
OP_IIC_IN      =1B9F      7071
OP_IIC_OUT     =1B3F      6975
OP_IO_IN       =1B08      6920
OP_IO_OUT      =1B1E      6942
OP_LSDSK       =1E00      7680
OP_RTIME       =1BEF      7151
OP_SELDSK      =1E04      7684
OP_SET         =1AA7      6823
OP_STIME       =1D87      7559
OS             =1A        26
OTKLN            630      1584
OTPORT         =1DEA      7658
OUTC             6C7      1735
OUTEXP          19A0      6560
OUTIT            6AE      1710
OUTNBS           6B4      1716
OUTNCR           6EF      1775
OUTSUB         =1DE9      7657
OUTWRD           74C      1868
OV             =0A        10
OVERR            3FA      1018
OVTST1          1716      5910
OVTST2          171B      5915
OVTST3          171C      5916
PADD            18B6      6326
PAND             E44      3652
PASSA           10E1      4321
PBUFF          =1EC3      7875
PEEK            14B2      5298
PEND             899      2201
PHLTFP          177D      6013
PLUCDE          158F      5519
PNORM           1557      5463
POKE            14B9      5305
POPAF           123A      4666
POPHL           1375      4981
POPHRT          1375      4981
POPNOK           438      1080
POR              E43      3651
POR1             E6B      3691
POS             10DE      4318
POSINT           8F8      2296
POST_CHECK_APU =1E7D      7805
POST_CHECK_IDE_30=1EA8      7848
POST_CHECK_IDE_40=1EBB      7867
POST_CHECK_PIO =1E58      7768
POST_START     =1E48      7752
POST_TEST_RTC  =1ED5      7893
POUT            146A      5226
POWER           19ED      6637
POWER1          19FD      6653
POWER2          1A1F      6687
POWERS          19C5      6597
PRG_RAM_START  =4110      16656
PRG_RAM_TOP    =FF00      65280
PRINT            ABB      2747
PRINTINLINE    = 1D0      464
PRITAB           2DF      735
PRNTCRLF         B19      2841
PRNTHL          18CF      6351
PRNTLP           ABE      2750
PRNTNB           B01      2817
PRNTOK           439      1081
PRNTST           B05      2821
PRNUMS          1201      4609
PROCES           65B      1627
PROGND         =1EB0      7856
PROGST         =1ED3      7891
PROG_MEM_START =4000      16384
PROG_ROM_START = 100      256
PROMPT           543      1347
PRS             1202      4610
PRS1            1205      4613
PRSLP           120C      4620
PSUB            14D7      5335
PTRLP            4C5      1221
PUTBUF           69A      1690
PUTCTL           69F      1695
PUTFID           80C      2060
QTSTLP          11BD      4541
QTSTR           11B7      4535
QUARTR          1BB6      7094
READ             BC9      3017
READFG         =1EA7      7847
REDO             B76      2934
REM              9F2      2546
RESDIV          16C8      5832
RESEED          1B4F      6991
RESET           59        89
RESTNL           873      2163
RESTOR           85E      2142
RESZER          154A      5450
RETADR           FB2      4018
RETINT          1756      5974
RETLIN           9EA      2538
RETNAD           5D4      1492
RETNUL           FB5      4021
RETNUM           DE5      3557
RETREL          1748      5960
RETURN           9CB      2507
RG             =04        4
RIGHT           13EB      5099
RIGHT1          13BF      5055
RINPUT         =1E31      7729
RLTLP            D24      3364
RND             1AD5      6869
RND1            1B19      6937
RND2            1B3D      6973
RNDTAB          1B57      6999
RNGTST          19B2      6578
RONDB           156B      5483
RONDUP          156A      5482
ROUND           14CA      5322
RSCALE          18AB      6315
RSLNBK           784      1924
RSTSTR          140E      5134
RST_00         =00        0
RST_08         =08        8
RST_10         =10        16
RST_18         =18        24
RUN              98D      2445
RUNCNT           810      2064
RUNFST           50C      1292
RUNLIN           9A9      2473
SAVEXP          154B      5451
SAVSTP           803      2051
SAVSTR          1192      4498
SBSCPT           FC0      4032
SCALE           15AF      5551
SCALLP          15B1      5553
SCALMI          1876      6262
SCALPL          188C      6284
SCNEND          12E4      4836
SCPTLP           FC6      4038
SEARCH           59C      1436
SEED           =1DFA      7674
SETIO           148E      5262
SETLIN           75A      1882
SETLIT           5E6      1510
SETPTR           4C0      1216
SETTOP          A2        162
SFTPRG           487      1159
SGN             174E      5966
SGNEXP           E33      3635
SGNRES         =1EC2      7874
SHRITE          15BE      5566
SHRLP           15C1      5569
SHRT1           15C5      5573
SIGNON          F5        245
SIGNS           1792      6034
SIN             1B69      7017
SIN1            1B9E      7070
SINTAB          1BBA      7098
SIXDIG          18F7      6391
SMPVAR          126C      4716
SMSER1          1AAC      6828
SN             =02        2
SNERR            3EB      1003
SPCFST          18E8      6376
SPCLP            B68      2920
SQR             19DC      6620
SRCHLN           4DD      1245
SRCHLP           4E0      1248
SSTSA           1340      4928
ST             =1E        30
STACK          =1E40      7744
STACK_RAM_TOP  =FFFF      65535
STAKFP          1770      6000
STALL            888      2184
START_ADDR     =8000      32768
START_ROM      =00        0
STKTHS           D68      3432
STLOOK         =1F37      7991
STOP             897      2199
STORED           967      2407
STPOOL          12B5      4789
STR             1182      4482
STR1            1188      4488
STRADD          12B8      4792
STRBOT         =1E9D      7837
STRCONV_BYTES_TO_HEX= 26C      620
STRCONV_BYTES_TO_HEX_1= 27B      635
STRCONV_BYTES_TO_HEX_2= 285      645
STRENT           C20      3104
STRSPC         =1E34      7732
STR_Banner_Start=2689      9865
STR_PD_HEADER  =186B      6251
STTLIN           B0C      2828
SUBCDE          14D9      5337
SUBPHL          14D3      5331
SUMLP           1ABD      6845
SUMSER          1A98      6808
SUPTLZ          1984      6532
SVNAM2           F11      3857
SVSTAD          11B0      4528
SYS_BUF_START  =4010      16400
SYS_RAM_START  =4000      16384
TAN             1BCF      7119
TESTOS          123C      4668
TESTR           121B      4635
TM             =18        24
TMERR            3FD      1021
TMPSTR         =1E99      7833
TMSTPL         =1E8D      7821
TMSTPT         =1E8B      7819
TOPOOL          13B7      5047
TOSTRA          1349      4937
TRYAGN          195A      6490
TSALP           134A      4938
TSTBRK           879      2169
TSTMEM          90        144
TSTNUM           CF9      3321
TSTOPL          11D8      4568
TSTRED           E70      3696
TSTREM           5E9      1513
TSTSGN          173F      5951
TSTSTR           CFA      3322
TTYLIN           639      1593
TYPE           =1E87      7815
UF             =22        34
UFERR            3F7      1015
UL             =0E        14
ULERR            9C6      2502
UNITY           15D3      5587
UPDATA           874      2164
USR            =1DE6      7654
VAL             1425      5157
VAL1            1443      5187
VAL2            144D      5197
VAL3            1450      5200
VAREND         =1EB2      7858
VAR_CONSOLE_BAUD=18        24
VAR_CONSOLE_CONF=0F        15
VDP_MEM        =80        128
VDP_REG        =81        129
WAIT            1470      5232
WAITLP          1485      5253
WARM            51        81
WARMST          DD        221
WIDTH           1C3E      7230
WORDS            18F      399
WORDTB           29B      667
WRKSPC         =1DE3      7651
ZDATA          =83        131
ZDIV           =AC        172
ZEND           =80        128
ZEQUAL         =B1        177
ZERARY          1064      4196
ZERBYT         = 381      897
ZEROLP           FA1      4001
ZEROSUP         1D8D      7565
ZFN            =A4        164
ZFOR           =81        129
ZGOSUB         =8C        140
ZGOTO          =88        136
ZGTR           =B0        176
ZLEFT          =CB        203
ZLTH           =B2        178
ZMINUS         =AA        170
ZNEW           =A1        161
ZNOT           =A7        167
ZONELP           B43      2883
ZOR            =AF        175
ZPLUS          =A9        169
ZPRINT         =9C        156
ZREM           =8E        142
ZSGN           =B3        179
ZSPC           =A5        165
ZSTEP          =A8        168
ZTAB           =A2        162
ZTHEN          =A6        166
ZTIMES         =AB        171
ZTO            =A3        163
_BASRST_08      20        32
_BASRST_10      2D        45
_BASRST_18      4B        75
_COMMAND_PROCESS_FOUND=19F4      6644
_OP_CALL       =1A76      6774
_OP_IIC_ACK_ERR=1B84      7044
_OP_IIC_ACK_ERR_str=1B8B      7051
_OP_IIC_IN_LOOP=1BD1      7121
_OP_IIC_IN_LOOP_TEXT=1BDE      7134
_OP_IIC_OUT_LOOP=1B55      6997
_OP_IIC_OUT_SEND=1B71      7025
_OP_RTIME_NN   =1BF2      7154
_OP_RTIME_RD_CMD=1CAA      7338
_OP_SELDSK_INVALID=1E13      7699
_OP_SELDSK_INVALID_STR=1E2B      7723
_OP_SET_LOOP   =1ABF      6847
_OP_STIME_INVALID=1D4D      7501
_OP_STIME_PROMPT=1D64      7524
_OP_STIME_PROMPT_ERR=1D7C      7548
_OP_STIME_STR_DAY=1CAB      7339
_OP_STIME_STR_HOUR=1CFC      7420
_OP_STIME_STR_MIN=1D17      7447
_OP_STIME_STR_MON=1CC6      7366
_OP_STIME_STR_SEC=1D32      7474
_OP_STIME_STR_YEAR=1CE1      7393
_POST_CHECK_APU_FAILED=1E9C      7836
_POST_CHECK_IDE_FAILED=1ECE      7886
_POST_CHECK_PIO_FAILED=1E71      7793
_POST_TEST_RTC_INVALID=1F0F      7951
_POST_TEST_RTC_NOTFOUND=1F08      7944
_STR_NOT_FOUND =1A17      6679
_STR_NOT_IMPLEMENTED=1A03      6659
_STR_SYNTAX    =1A2B      6699
_WORKSPACE      1DE3      7651
_beep_pause_l1 = E01      3585
_compare_filename_loop=234A      9034
_compare_filename_nomatch=2358      9048
_eof            9E5E      40542
_fat_cd_navigate=24FF      9471
_fat_cd_navigate_end=2545      9541
_fat_cd_navigate_errfile=256D      9581
_fat_cd_navigate_errfile_str=259F      9631
_fat_cd_navigate_error=2557      9559
_fat_cd_navigate_error_str=2575      9589
_fat_cd_navigate_findsec=2504      9476
_fat_cd_navigate_findsec_skipslash=2530      9520
_fat_cd_navigate_goback_fl=24BB      9403
_fat_cd_navigate_inerror=2565      9573
_fat_cd_navigate_inerrorS=255F      9567
_fat_cd_navigate_inerrore=2566      9574
_fat_cd_navigate_inputerr_str=258C      9612
_fat_cd_navigate_l2=2536      9526
_fat_exec_notexec=2665      9829
_fat_exec_notfound=264C      9804
_fat_exec_read_done=2634      9780
_fat_exec_readloop1=2616      9750
_fat_get_root_table_invalid=213A      8506
_fat_getfatsec_notroot=2179      8569
_fat_increment_32=22D0      8912
_fat_lfs_loop  =2246      8774
_fat_lfs_loop_compare_end=2282      8834
_fat_lfs_loop_compare_match=2286      8838
_fat_lfs_loop_compare_next_sector=2258      8792
_fat_math_add32=22E4      8932
_fat_math_mul32=2315      8981
_fat_math_mul32_l=231C      8988
_fat_math_mul32_noadd=2329      9001
_fat_math_sector_add_16=22BC      8892
_fat_print_directory_dir=243A      9274
_fat_print_directory_loop=23CD      9165
_fat_print_directory_loop_break=2499      9369
_fat_print_directory_loop_file=23E9      9193
_fat_print_directory_loop_next=2465      9317
_fat_print_directory_loop_next_sector=2470      9328
_format_filename_fat16_clean=2361      9057
_format_filename_fat16_loop=2368      9064
_format_filename_fat16_loop_copy=237B      9083
_format_filename_fat16_loop_skip_8=2372      9074
_ide_readsector_512_floop= E5D      3677
_ideif_drv_sel_fail=15D2      5586
_ideif_drv_sel_fstr0=168F      5775
_ideif_drv_sel_pstr=1686      5766
_ideif_drv_sel_sstr0=169D      5789
_ideif_drv_sel_syn=16AA      5802
_ideif_init_drive_charloop=1499      5273
_ideif_init_drive_found=147B      5243
_ideif_init_drive_loop=1463      5219
_ideif_init_drive_nodrv=1476      5238
_ideif_init_drive_prt_fnd=14F7      5367
_ideif_init_drive_prt_l1=14E5      5349
_ideif_init_drive_prt_ln=14EF      5359
_ideif_prnt_devtable_hdr=1612      5650
_ideif_prnt_devtable_l1=1373      4979
_ideif_prnt_devtable_l1_e2=1439      5177
_ideif_prnt_devtable_l1_es=13B8      5048
_ideif_prnt_devtable_l1_ms=1436      5174
_ideif_prnt_devtable_l1_nxt=1380      4992
_ideif_prnt_devtable_l1_s00=13A6      5030
_ideif_prnt_devtable_l1_s01=13AB      5035
_ideif_prnt_devtable_l1_s02=13B0      5040
_ideif_prnt_devtable_l1_sFF=13B5      5045
_ideif_prnt_devtable_l1_sel=137E      4990
_ideif_prnt_devtable_master=1676      5750
_ideif_prnt_devtable_s00=164A      5706
_ideif_prnt_devtable_s01=1655      5717
_ideif_prnt_devtable_s02=1660      5728
_ideif_prnt_devtable_sFF=166B      5739
_ideif_prnt_devtable_slave=167E      5758
_read_bcd_invalid= 18D      397
_shift4        =1DFB      7675
_wait           22        34
beep           = DE8      3560
beep_loop      = DEA      3562
beep_pause     = E00      3584
com_header      8000      32768
com_prg         8040      32832
compare_filename=2346      9030
dasm_00        = 9ED      2541
dasm_01        = CD9      3289
dasm_02        = A73      2675
dasm_03        = CAB      3243
dasm_08        = AF0      2800
dasm_09        = C7E      3198
dasm_0A        = A55      2645
dasm_0B        = CC2      3266
dasm_10        = A35      2613
dasm_12        = A7E      2686
dasm_18        = 9F8      2552
dasm_1A        = A5F      2655
dasm_20        = A12      2578
dasm_22        = D1F      3359
dasm_27        = AB8      2744
dasm_28        = A0B      2571
dasm_2A        = CF0      3312
dasm_2F        = ABC      2748
dasm_30        = A03      2563
dasm_32        = A89      2697
dasm_37        = AC8      2760
dasm_38        = 9FC      2556
dasm_3A        = A69      2665
dasm_3F        = AC4      2756
dasm_76        = ACC      2764
dasm_80C6      = B49      2889
dasm_BE        = AE6      2790
dasm_C3        = 9F1      2545
dasm_C88E      = B6F      2927
dasm_C9        = A41      2625
dasm_CD        = A3B      2619
dasm_D9        = AFD      2813
dasm_DD        = A23      2595
dasm_DD_01     = CE0      3296
dasm_DD_09     = C99      3225
dasm_DD_22     = D35      3381
dasm_DD_23     = CB0      3248
dasm_DD_2A     = D07      3335
dasm_DD_2B     = CC7      3271
dasm_DD_34     = C49      3145
dasm_DD_35     = C66      3174
dasm_DD_86     = B51      2897
dasm_DD_8E     = B77      2935
dasm_DD_96     = B9A      2970
dasm_DD_9E     = BBA      3002
dasm_DD_A6     = BDB      3035
dasm_DD_AE     = C12      3090
dasm_DD_B6     = BF7      3063
dasm_DD_BE     = C2E      3118
dasm_DD_E1     = D87      3463
dasm_DD_E3     = B0D      2829
dasm_DD_E5     = D71      3441
dasm_DD_F9     = D57      3415
dasm_E1        = D81      3457
dasm_E3        = B01      2817
dasm_E5        = D6B      3435
dasm_E9        = A1A      2586
dasm_ED_42     = C90      3216
dasm_ED_43     = D2B      3371
dasm_ED_44     = AC0      2752
dasm_ED_45     = A4B      2635
dasm_ED_46     = AD7      2775
dasm_ED_4A     = C87      3207
dasm_ED_4B     = CFC      3324
dasm_ED_4D     = A46      2630
dasm_ED_56     = ADC      2780
dasm_ED_5E     = AE1      2785
dasm_ED_A0     = B25      2853
dasm_ED_A1     = B37      2871
dasm_ED_A8     = B2E      2862
dasm_ED_A9     = B40      2880
dasm_ED_B0     = B29      2857
dasm_ED_B1     = B3B      2875
dasm_ED_B8     = B32      2866
dasm_ED_B9     = B44      2884
dasm_F3        = AD1      2769
dasm_F9        = D4D      3405
dasm_FB        = AD4      2772
dasm_FD        = A2C      2604
dasm_FD_01     = CE8      3304
dasm_FD_09     = CA2      3234
dasm_FD_22     = D41      3393
dasm_FD_23     = CB9      3257
dasm_FD_2A     = D13      3347
dasm_FD_2B     = CD0      3280
dasm_FD_34     = C55      3157
dasm_FD_35     = C72      3186
dasm_FD_86     = B60      2912
dasm_FD_8E     = B86      2950
dasm_FD_96     = BA6      2982
dasm_FD_9E     = BC8      3016
dasm_FD_A6     = BE7      3047
dasm_FD_AE     = C1E      3102
dasm_FD_B6     = C02      3074
dasm_FD_BE     = C39      3129
dasm_FD_E1     = D8F      3471
dasm_FD_E3     = B19      2841
dasm_FD_E5     = D79      3449
dasm_FD_F9     = D61      3425
dasm_FF        = A50      2640
dasm_UU        = D97      3479
dasm_UW        = D9B      3483
dasm__AND      = BD6      3030
dasm__CP       = C2A      3114
dasm__DEC      = C61      3169
dasm__ED_47    = AA8      2728
dasm__ED_4F    = AB0      2736
dasm__ED_57    = A98      2712
dasm__ED_5F    = AA0      2720
dasm__INC      = C44      3140
dasm__LD       = A94      2708
dasm__OR       = BF3      3059
dasm__SBC      = BB2      2994
dasm__SUB      = B95      2965
dasm__XOR      = C0D      3085
dasm_opcode_table= 595      1429
dasm_print16hex_addr= 3C2      962
dasm_print8hex = 3DA      986
dasm_printFlags_table= DA0      3488
dasm_printRegister8_table= DB0      3504
dasm_printRegister8_table_HL= DD0      3536
dasm_printRegisterIX_table= DB8      3512
dasm_printRegisterIY_table= DC0      3520
dasm_printRegisterSP_table= DC8      3528
disassemble    = 286      646
disassemble_continue= 36C      876
disassemble_err= 35C      860
disassemble_next= 28A      650
disassemble_print_opcode_params_end= 359      857
disassemble_print_opcode_params_loop= 305      773
disassemble_print_opcode_raw= 2C7      711
disassemble_print_opcode_raw_fill= 2DB      731
disassemble_table_first_match= 39E      926
disassemble_table_found= 3B8      952
disassemble_table_notfound= 3BC      956
disassemble_table_seek= 37A      890
disassemble_table_seek_loop= 37E      894
dump_pretty    =1810      6160
dump_pretty_ascii=183A      6202
dump_pretty_ascii_cont=1858      6232
dump_pretty_ascii_loop=1842      6210
dump_pretty_ascii_none=1853      6227
dump_pretty_col=182D      6189
dump_pretty_end=186A      6250
dump_pretty_nextrow=185E      6238
dump_pretty_row=1818      6168
endPrint       = 1DE      478
fat_cd_single  =249B      9371
fat_copy_lba_pointer=233D      9021
fat_exec       =25B6      9654
fat_get_root_table=206D      8301
fat_getfatsec  =2162      8546
fat_openfile   =2217      8727
fat_openfile_noprepare=221F      8735
fat_print_directory=2382      9090
fat_readfilesec=21EA      8682
fat_reset_pointer=232E      9006
format_filename_fat16=235C      9052
ide_printerror = E94      3732
ide_readsector_512_fast= E49      3657
ide_readsector_timeout= E7E      3710
ide_regread_8  = E33      3635
ide_regwrite_8 = E19      3609
ide_reset      = E0D      3597
ide_writesector_256= E93      3731
ideif_drv_sel  =159A      5530
ideif_get_drv_pointer=153A      5434
ideif_init_all =154E      5454
ideif_init_devtable=1347      4935
ideif_init_drive=145A      5210
ideif_prnt_devtable=1365      4965
iic_init       =171C      5916
iic_read_ack   =1763      5987
iic_receive_buffer=16ED      5869
iic_receive_buffer_done=1710      5904
iic_receive_buffer_err=1716      5910
iic_receive_buffer_loop=16FE      5886
iic_receive_byte=17E9      6121
iic_receive_byte_loop=17F6      6134
iic_send_ack   =1789      6025
iic_send_buffer=16C3      5827
iic_send_buffer_done=16E1      5857
iic_send_buffer_err=16E7      5863
iic_send_buffer_loop=16D3      5843
iic_send_byte  =17C3      6083
iic_send_byte_loop=17CF      6095
iic_send_ebit  =1742      5954
iic_send_nack  =17A6      6054
iic_send_sbit  =1729      5929
interrupt_vectors=4000      16384
mon_var_template=44        68
mon_var_template_end= 50F      1295
nxtILC         = 1D3      467
param_01       = 3E8      1000
param_02       = 40F      1039
param_03       = 42C      1068
param_03_done  = 464      1124
param_03_neg   = 44D      1101
param_04       = 468      1128
param_04_i     = 478      1144
param_05       = 47E      1150
param_06       = 48B      1163
param_07       = 4A5      1189
param_08       = 4B2      1202
param_09       = 4C7      1223
param_09_0A    = 4CD      1229
param_0A       = 4BE      1214
param_10       = 4DC      1244
param_11       = 4EC      1260
param_11_12    = 4FB      1275
param_11_12_all= 51B      1307
param_11_12_def= 50E      1294
param_11_12_ix = 513      1299
param_11_12_iy = 518      1304
param_12       = 4F4      1268
param_13       = 52C      1324
param_80       = 54B      1355
param_80_seek  = 552      1362
param_81       = 542      1346
param_comma    = 586      1414
param_printRegister= 561      1377
param_printRegisterA= 57F      1407
param_printRegisterHL= 577      1399
prg_end         9E5E      40542
prg_start       807B      32891
print_16_hex   = 1A9      425
print_32_hex   = 190      400
print_a_hex    = 143      323
print_bcd      = 155      341
print_char     = 115      277
print_clear    = 126      294
print_newLine  = 12D      301
print_reg      = 1E3      483
print_str      = 11D      285
print_str_fixed=18AA      6314
print_wait_out = 138      312
read_bcd       = 177      375
read_char      = 15B      347
read_in_sts    = 16D      365
read_lba_sector=1561      5473
str_dev_done   =160A      5642
str_dev_waitready=15F2      5618
str_error_start= EC9      3785
str_error_start1= EE6      3814
str_error_start2= EEF      3823
str_error_time = EF8      3832
str_post_apu   =1F67      8039
str_post_ide_30=1F16      7958
str_post_ide_40=1F31      7985
str_post_nd    =1F9D      8093
str_post_ok    =1FD5      8149
str_post_pio   =1F4C      8012
str_post_rtc   =1F82      8066
str_post_rtc_iv=1FAB      8107
var_apu_present=410A      16650
var_buffer_len =4100      16640
var_bytes_count=411A      16666
var_curserchar =4106      16646
var_curserlastaddr=4107      16647
var_curseron   =4105      16645
var_curserstate=4104      16644
var_curserx    =4102      16642
var_cursery    =4103      16643
var_dir        =412B      16683
var_idebuffer  =41CB      16843
var_input      =417B      16763
var_last_char  =4101      16641
var_opcode     =4114      16660
var_opcode_length=4116      16662
var_opcode_pcount=4119      16665
var_opcode_start=4110      16656
var_opcode_string=4117      16663
var_opcode_table=4112      16658
var_opcode_x   =4115      16661
var_pio_present=4109      16649
var_ps2mem     =411B      16667
var_scratch    =410B      16651
